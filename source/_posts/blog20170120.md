---
title: jQuery源码分析--$.Deferred()
date: 2017-01-14 20:50:05
category: "jQuery源码分析"
tags: "$.Deferred()"
---
## 直接上例子

```
//源码结构
jQuery.extend({
	
	Deferred : function(){},
	when : function(){}
	
});

//$.Deferred() 相当于 $.Callbacks()
$.Deferred();   ->   $.Callbacks();
$.when();

//简单例子
var dfd = $.Deferred();

setTimeout(function(){
	
	alert(111);
	dfd.resolve();
	
},1000);

dfd.done(function(){
	alert(222);
});


```


## 下面是Deferred源码tuples：
```
[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
[ "notify", "progress", jQuery.Callbacks("memory") ]
```

resolve/reject/notify 相当于Callbacks中的 fire；
done/fail/progress 相当于Callbacks中的 add。


## promise与deferred的关系

promise下面的方法：state、always、then、promise、pipe、done、fail、progress

deferred下面的方法：包括promise下面所有方法以及resolve、reject、notify方法

返回deferred.promise()时，相当于是promise对象，promise对象下面没有resolve、reject、notify方法，所以外部没有办法修改执行是的状态。


## when工具方法

when返回一个不能再外部修改状态的延迟对象promise；
多延迟对象同时完成后触发done、fail、then、progress；


```
when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = core_slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;
					if( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});
```

