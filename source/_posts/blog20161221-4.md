---
title: java学习记录--Java异常处理
date: 2016-12-21 18:17:17
category: "编程语言"
tags: "java学习记录"
---

## Java异常

Error:  Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。一般不编写针对性的代码进行处理。
Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理

## 常见异常类型

*Throwable
	* Error
		* AWTError、ThreadDeath
	* Exception
		* 编译(checked)异常：SQLException、IOException、ClassNotFoundException
		* RuntimeException：NullPointerException、ArithmeticException、ClassCastException、ArrayIndexOutOfBoundsException


## 异常处理机制

* Java提供的是异常处理的抓抛模型。
* Java程序的执行过程中如出现异常，会生成一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为抛出(throw)异常。
* 异常对象的生成
	* 由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，如果在当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出——自动抛出
	* 由开发人员手动创建：Exception exception = new ClassCastException();——创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样
* 如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理。如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法。这个过程将一直继续下去，直到异常被处理。这一过程称为捕获(catch)异常。
* 如果一个异常回到main()方法，并且main()也不处理，则程序运行终止。
* 程序员通常只能处理Exception，而对Error无能为力。

异常处理是通过try-catch-finally语句实现的。

```
try{
	......	//可能产生异常的代码
}
catch( ExceptionName1 e ){
	......	//当产生ExceptionName1型异常时的处置措施
}
catch( ExceptionName2 e ){
...... 	//当产生ExceptionName2型异常时的处置措施
}  
[ finally{
......	 //无论是否发生异常，都无条件执行的语句
		}  ]
```

捕获异常的有关信息：与其它对象一样，可以访问一个异常对象的成员变量或调用它的方法。
getMessage()   获取异常信息，返回字符串
printStackTrace()  获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。

** finally **
捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理。
不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return，finally块中的语句都会被执行。
finally语句和catch语句是任选的


** 声明抛出异常 **

声明抛出异常是Java中处理异常的第二种方式
如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。
在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。

声明抛出异常举例：

```
	public void readFile(String file)  throws FileNotFoundException {
		……
		// 读文件的操作可能产生FileNotFoundException类型的异常
		FileInputStream fis = new FileInputStream(file);
		 ..……
     }
```

** 人工抛出异常 **

* Java异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要人工创建并抛出。
* 首先要生成异常类对象，然后通过throw语句实现抛出操作(提交给Java运行环境)。
IOException e = new IOException();
throw e;
* 可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将会产生语法错误：
		        throw new String("want to throw");


** 创建用户自定义异常类 **

* 一般地，用户自定义异常类都是RuntimeException的子类。
* 自定义异常类通常需要编写几个重载的构造器。
* 自定义的异常类对象通过throw抛出。
* 自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。

用户自定义异常类MyException，用于描述数据取值范围错误信息。用户自己的异常类必须继承现有的异常类。

```

class MyException extends Exception {
   	static final long serialVersionUID = 1L;
	private int idnumber;
 	public MyException(String message, int id) {
		super(message);
		this.idnumber = id;
 	} 
	public int getId() {
		return idnumber;
 	}
}
```