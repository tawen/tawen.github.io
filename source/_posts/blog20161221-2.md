---
title: java学习记录--Java高级类特性一
date: 2016-12-21 16:17:17
category: "编程语言"
tags: "java学习记录"
---

## 面向对象特征之二：继承
* 子类继承了父类，就继承了父类的方法和属性。
* 在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。
* 在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展”。

> 关于继承的规则：子类不能直接访问父类中私有的(private)的成员变量和方法。

Java只支持单继承，不允许多重继承
* 一个子类只能有一个父类
* 一个父类可以派生出多个子类










## 方法的重写(override)

* 重写方法必须和被重写方法具有相同的方法名称、参数列表和返回值类型。
* 重写方法不能使用比被重写方法更严格的访问权限。
* 重写和被重写的方法须同时为static的，或同时为非static的
* 子类方法抛出的异常不能大于父类被重写方法的异常

## 关键字super
*在Java类中使用super来调用父类中的指定操作：
	*super可用于访问父类中定义的属性
	*super可用于调用父类中定义的成员方法
	*super可用于在子类构造方法中调用父类的构造器
*注意：
	*尤其当子父类出现同名成员时，可以用super进行区分
	*super的追溯不仅限于直接父类
	*super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识

** 调用父类的构造器 **
* 子类中所有的构造器默认都会访问父类中空参数的构造器
* 当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的构造器，且必须放在构造器的第一行
* 如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错

## 面向对象特征之三：多态

多态性，是面向对象中最重要的概念，在java中有两种体现：
* 方法的重载(overload)和重写(overwrite)。
* 对象的多态性   ——可以直接应用在抽象类和接口上。

Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。
若编译时类型和运行时类型不一致，就出现多态（Polymorphism）

对象的多态 —在Java中,子类的对象可以替代父类的对象使用
* 一个变量只能有一种确定的数据类型
* 一个引用类型变量可能指向(引用)多种不同类型的对象

> 子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型(upcasting)。

** 一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法 **
```
Student m = new Student();
m.school = “pku”; 	//合法,Student类有school成员变量
Person e = new Student(); 
e.school = “pku”;	//非法,Person类没有school成员变量
```
> 属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误。

正常的方法调用
```
   	Person e = new Person();
  	e.getInfo();
  	Student e = new Student();
   	e.getInfo();
```
虚拟方法调用(多态情况下)
```
Person e = new Student();
e.getInfo();	//调用Student类的getInfo()方法
```
编译时类型和运行时类型
编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类的getInfo()方法。——动态绑定

* 前提：
	* 需要存在继承或者实现关系
	* 要有覆盖操作
* 成员方法：
	* 编译时：要查看引用变量所属的类中是否有所调用的方法。
	* 运行时：调用实际对象所属的类中的重写方法。
* 成员变量：
	* 不具备多态性，只看引用变量所属的类。

** 子类继承父类 **
若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中
对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量


** 对象类型转换 (Casting ) **
* 基本数据类型的Casting：
	* 自动类型转换：小的数据类型可以自动转换成大的数据类型
	  如long g=20;           double d=12.0f
	* 强制类型转换：可以把大的数据类型强制转换(casting)成小的数据类型
	  如 float f=(float)12.0;   int a=(int)1200L
* 对Java对象的强制类型转换称为造型
	* 从子类到父类的类型转换可以自动进行
	* 从父类到子类的类型转换必须通过造型(强制类型转换)实现
	* 无继承关系的引用类型间的转换是非法的
	* 在造型前可以使用instanceof操作符测试一个对象的类型



## Object类、包装类

### ==操作符与equals方法
*基本类型比较值:只要两个变量的值相等，即为true.
*引用类型比较引用(是否指向同一个对象):只有指向同一个对象时，==才返回true.
*用“==”进行比较时，符号两边的数据类型必须兼容(可自动转换的基本数据类型除外)，否则编译出错
*equals()：所有类都继承了Object，也就获得了equals()方法。还可以重写。
*只能比较引用类型，其作用与“==”相同,比较是否指向同一个对象。	 
*格式:obj1.equals(obj2)
*特例：当用equals()方法进行比较时，对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象；
*原因：在这些类中重写了Object类的equals()方法。

### toString() 方法

* toString()方法在Object类中定义，其返回值是String类型，返回类名和它的引用地址。
* 在进行String与其它类型数据的连接操作时，自动调用toString()方法
	Date now=new Date();
	System.out.println(“now=”+now);  相当于
      System.out.println(“now=”+now.toString());   
* 可以根据需要在用户自定义类型中重写toString()方法
	如String 类重写了toString()方法，返回字符串的值。
	s1=“hello”;
	System.out.println(s1);//相当于System.out.println(s1.toString());
基本类型数据转换为String类型时，调用了对应包装类的toString()方法
int a=10;   System.out.println(“a=”+a);

### 包装类(Wrapper)
* 针对八种基本定义相应的引用类型—包装类（封装类）
* 有了类的特点，就可以调用类中的方法。
