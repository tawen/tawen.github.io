---
title: java学习记录--Java集合
date: 2016-12-21 18:17:17
category: "编程语言"
tags: "java学习记录"
---


## Java集合框架

Java 集合可分为 Collection 和 Map 两种体系
* Collection接口：
	* Set：元素无序、不可重复的集合 ---类似高中的“集合”
	* List：元素有序，可重复的集合  ---”动态”数组
* Map接口：具有映射关系“key-value对”的集合 ---类似于高中的“函数” y = f(x)   (x1,y1) (x2,y2)
Collection接口继承树:
![Alt Collection接口继承树](https://tawen.github.io/res/blog20161221jihe.jpg)
Map接口继承树:
![Alt Collection接口继承树](https://tawen.github.io/res/blog20161221jihe1.jpg)


## Iterator迭代器接口

遍历集合方法：

使用 Iterator 接口遍历集合元素

* Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。

* 所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。

* Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建 Iterator 对象，则必须有一个被迭代的集合。

```
Iterator iterator = coll.iterator();
while(iterator.hasNext()){
System.out.println(iterator.next());
}
```
使用 foreach 循环遍历集合元素
```
for(要遍历的元素类型 遍历后元素名称:要遍历的元素名称){
	//执行操作
}
```

## Collection子接口之一：Set接口

> HashSet   LinkedHashSet   TreeSet

### Set概述

* Set接口是Collection的子接口，set接口没有提供额外的方法
* Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。
* Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals 方法

### Set实现类之一：HashSet

* HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。
* HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。
* HashSet 具有以下特点：
	* 不能保证元素的排列顺序
	* HashSet 不是线程安全的
	* 集合元素可以是 null
* 当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据 hashCode 值决定该对象在 HashSet 中的存储位置。
* HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。

hashCode() 方法

* 如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。
* 对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。
* 重写 hashCode() 方法的基本原则
	* 在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值
	* 当两个对象的 equals() 方法比较返回 true 时，这两个对象的 hashCode() 方法的返回值也应相等
	* 对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值

### Set实现类之二：LinkedHashSet

* LinkedHashSet 是 HashSet 的子类
* LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的。
* LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。
* LinkedHashSet 不允许集合元素重复。

### Set实现类之三：TreeSet

TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。
```
Comparator comparator()
Object first()
Object last()
Object lower(Object e)
Object higher(Object e)
SortedSet subSet(fromElement, toElement)
SortedSet headSet(toElement)
SortedSet tailSet(fromElement)
```
TreeSet 两种排序方法：自然排序和定制排序。默认情况下，TreeSet 采用自然排序。

### 排  序——自然排序

* 自然排序：TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序排列
* 如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口。
* 实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。
* Comparable 的典型实现：
	* BigDecimal、BigInteger 以及所有的数值型对应的包装类：按它们对应的数值大小进行比较
	* Character：按字符的 unicode值来进行比较
	* Boolean：true 对应的包装类实例大于 false 对应的包装类实例
	* String：按字符串中字符的 unicode 值进行比较
	* Date、Time：后边的时间、日期比前面的时间、日期大
* 向 TreeSet 中添加元素时，只有第一个元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较。
* 因为只有相同类的两个实例才会比较大小，所以向 TreeSet 中添加的应该是同一个类的对象
* 对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较返回值
* 当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保证该方法与 compareTo(Object obj) 方法有一致的结果：如果两个对象通过 equals() 方法比较返回 true，则通过 * compareTo(Object obj) 方法比较应返回 0

### 排  序——定制排序

* TreeSet的自然排序是根据集合元素的大小，进行元素升序排列。如果需要定制排序，比如降序排列，可通过Comparator接口的帮助。需要重写compare(T o1,T o2)方法。
* 利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。
* 要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。
* 此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异常。
* 使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。


## Collection子接口之二： List接口

> ArrayList  LinkedList  Vector

### List接口概述

* Java中数组用来存储数据的局限性
* List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。
* List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。
* JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。

List 集合里添加了一些根据索引来操作集合元素的方法
```
void add(int index, Object ele)
boolean addAll(int index, Collection eles)
Object get(int index)
int indexOf(Object obj)
int lastIndexOf(Object obj)
Object remove(int index)
Object set(int index, Object ele)
List subList(int fromIndex, int toIndex)
```

### List实现类之一：ArrayList

* ArrayList 是 List 接口的典型实现类
* 本质上，ArrayList是对象引用的一个变长数组
* ArrayList 是线程不安全的，而 Vector 是线程安全的，即使为保证 List 集合线程安全，也不推荐使用Vector
* 
* Arrays.asList(…) 方法返回的 List 集合既不是 ArrayList 实例，也不是 Vector 实例。 Arrays.asList(…)  返回值是一个固定长度的 List 集合

### List实现类之二：LinkedList

对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高
新增方法：
```
void addFirst(Object obj)
void addLast(Object obj)	
Object getFirst()
Object getLast()
Object removeFirst()
Object removeLast()
```

### List 实现类之三：Vector

* Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。
* 在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。
* 新增方法：
```
void addElement(Object obj)
void insertElementAt(Object obj,int index)
void setElementAt(Object obj,int index)
void removeElement(Object obj)
void removeAllElements()
```

### ListIterator接口（了解）
List 额外提供了一个 listIterator() 方法，该方法返回一个 ListIterator 对象， ListIterator 接口继承了 Iterator 接口，提供了专门操作 List 的方法：
```
void add()

boolean hasPrevious()
Object previous()

Boolean hasNext()
Object next()
```

### Iterator和ListIterator主要区别(了解)
一、ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历。但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。
二、ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator 没有此功能。
三、ListIterator有add()方法，可以向List中插入对象，而Iterator不能。
四、都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iterator仅能遍历，不能修改。因为ListIterator的这些功能，可以实现对LinkedList等List数据结构的操作。


## Map接口

> HashMap  TreeMap  Hashtable

### 概述Map接口

* Map与Collection并列存在。用于保存具有映射关系的数据:Key-Value
* Map 中的 key 和  value 都可以是任何引用类型的数据
* Map 中的 key 用Set来存放，不允许重复，即同一个 Map 对象所对应的类，须重写hashCode()和equals()方法。
* 常用String类作为Map的“键”。
* key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value。
### Map 常用方法

添加、删除操作：

```
Object put(Object key,Object value)
Object remove(Object key)
void putAll(Map t)
void clear()

```
元视图操作的方法:

```
Set keySet()
Collection values()
Set entrySet()
```
元素查询的操作：

```
Object get(Object key)
boolean containsKey(Object key)
boolean containsValue(Object value)
int size()
boolean isEmpty()
boolean equals(Object obj)
```

### Map实现类之一：HashMap

* Map接口的常用实现类：HashMap、TreeMap和Properties。
* HashMap是 Map 接口使用频率最高的实现类。
* 允许使用null键和null值，与HashSet一样，不保证映射的顺序。
* HashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法返回 true，hashCode 值也相等。
* HashMap 判断两个 value相等的标准是：两个 value 通过 equals() 方法返回 true。

### Map实现类之二：LinkedHashMap

* LinkedHashMap 是 HashMap 的子类
* 与LinkedHashSet类似，LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致

### Map实现类之三：TreeMap

* TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 Key-Value 对处于有序状态。
* TreeMap 的 Key 的排序：
	* 自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException
	* 定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口
* TreeMap判断两个key相等的标准：两个key通过compareTo()方法或者compare()方法返回0。
* 若使用自定义类作为TreeMap的key，所属类需要重写equals()和hashCode()方法，且equals()方法返回true时，compareTo()方法应返回0。

### Map实现类之四：Hashtable

* Hashtable是个古老的 Map 实现类，线程安全。
* 与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value
* 与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序
* Hashtable判断两个key相等、两个value相等的标准，与hashMap一致。

### Map实现类之五：Properties

* roperties 类是 Hashtable 的子类，该对象用于处理属性文件
* 由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型
* 存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法

```
Properties pros = new Properties();
pros.load(new FileInputStream("jdbc.properties"));
String user = pros.getProperty("user");
System.out.println(user);
```

## Collections工具类

###操作集合的工具类：Collections

* Collections 是一个操作 Set、List 和 Map 等集合的工具类
* Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法
* 排序操作：（均为static方法）
	* reverse(List)：反转 List 中元素的顺序
	* shuffle(List)：对 List 集合元素进行随机排序
	* sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序
	* sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序
	* swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换
* 查找、替换
	* Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素
	* Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素
	* Object min(Collection)
	* Object min(Collection，Comparator)
	* int frequency(Collection，Object)：返回指定集合中指定元素的出现次数
	* void copy(List dest,List src)：将src中的内容复制到dest中
	* boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值

### 同步控制
Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题


### Enumeration

Enumeration 接口是 Iterator 迭代器的 “古老版本”

```
Enumeration stringEnum = new StringTokenizer("a-b*c-d-e-g", "-");
	while(stringEnum.hasMoreElements()){
		Object obj = stringEnum.nextElement();
		System.out.println(obj); 
	}
```