---
title: java学习记录--多线程
date: 2016-12-21 22:17:17
category: "编程语言"
tags: "java学习记录"
---
## 程序、进程、线程的概念

*程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。
*进程(process)是程序的一次执行过程，或是正在运行的一个程序。动态过程：有它自身的产生、存在和消亡的过程。
	*如：运行中的QQ，运行中的MP3播放器
	*程序是静态的，进程是动态的
*线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。
	*若一个程序可同一时间执行多个线程，就是支持多线程的




## Java中多线程的创建和使用

* Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来实现。

* Thread类的特性
	* 每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体
	* 通过该Thread对象的start()方法来调用这个线程

* 构造方法
	* Thread()：创建新的Thread对象
	* Thread(String threadname)：创建线程并指定线程实例名
	* Thread(Runnable target)：指定创建线程的目标对象，它实现了Runnable接口中的run方法
	* Thread(Runnable target, String name)：创建新的Thread对象 


### 继承 Thread 类与实现 Runnable  接口

#### 继承Thread类
* 定义子类继承Thread类。
* 子类中重写Thread类中的run方法。
* 创建Thread子类对象，即创建了线程对象。
* 调用线程对象start方法：启动线程，调用run方法。

#### 实现Runnable接口
* 定义子类，实现Runnable接口。
* 子类中重写Runnable接口中的run方法。
* 通过Thread类含参构造器创建线程对象。
* 将Runnable接口的子类对象作为实际参数传递给
  Thread类的构造方法中。
* 调用Thread类的start方法：开启线程，调用
  Runnable子类接口的run方法。

```
public class Thread extends Object implements Runnable
```
【区别】
继承Thread:       线程代码存放Thread子类run方法中。
实现Runnable：线程代码存在接口的子类的run方法。

【实现方法的好处】
1）避免了单继承的局限性
2）多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。



### Thread类的主要方法

void start():  启动线程，并执行对象的run()方法
run():  线程在被调度时执行的操作
String getName():  返回线程的名称
void setName(String name):设置该线程名称
static currentThread(): 返回当前线程


### 线程的调度与设置优先级

* 调度策略
	* 时间片

	* 抢占式：高优先级的线程抢占CPU 
* Java的调度方法
	* 同优先级线程组成先进先出队列（先到先服务），使用时间片策略
	* 对高优先级，使用优先调度的抢占式策略


* 线程的优先级控制
MAX_PRIORITY（10）;    
MIN _PRIORITY （1）;  
NORM_PRIORITY （5）;
* 涉及的方法：
getPriority() ：返回线程优先值 
setPriority(int newPriority) ：改变线程的优先级
线程创建时继承父线程的优先级

Thread类的有关方法(2)
*static  void  yield()：线程让步
	*暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程
	*若队列中没有同优先级的线程，忽略此方法
*join() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止   
	*低优先级的线程也可以获得执行 
*static  void  sleep(long millis)：(指定时间:毫秒)
	*令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。
	*抛出InterruptedException异常
*stop(): 强制线程生命期结束
*boolean isAlive()：返回boolean，判断线程是否还活着

** 补充：线程的分类 **

Java中的线程分为两类：一种是守护线程，一种是用户线程。
* 它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。
* 守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程。
* Java垃圾回收就是一个典型的守护线程。
* 若JVM中都是守护线程，当前JVM将退出。


## 线程的生命周期
JDK中用Thread.State枚举表示了线程的几种状态


要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态：
* 新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态
* 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件
* 运行：当就绪的线程被调度并获得处理器资源时,便进入运行状态， run()方法定义了线程的操作和功能
* 阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态
* 死亡：线程完成了它的全部工作或线程被提前强制性地中止   


## 线程的同步

Java对于多线程的安全问题提供了专业的解决方式：
      同步机制
synchronized (对象）{
          // 需要被同步的代码；
    }

synchronized还可以放在方法声明中，表示整个方法
      为同步方法。
例如：
    public synchronized void show (String name){ 
            ….
   }


## 线程的通信

* wait() 与 notify() 和 notifyAll()
	* wait()：令当前线程挂起并放弃CPU、同步资源，使别的线程可访问并修改共享资源，而当前线程排队等候再次对资源的访问
	* notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待
	* notifyAll ()：唤醒正在排队等待资源的所有线程结束等待.
* Java.lang.Object提供的这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.IllegalMonitorStateException异常

** wait() 方法 **
* 在当前线程中调用方法：  对象名.wait()
* 使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出 notify (或notifyAll) 为止。
* 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）
* 调用此方法后，当前线程将释放对象监控权  ，然后进入等待
* 在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。

** notify()/notifyAll() **
* 在当前线程中调用方法：  对象名.notify()
* 功能：唤醒等待该对象监控权的一个线程。
* 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）

