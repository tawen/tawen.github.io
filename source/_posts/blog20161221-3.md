---
title: java学习记录--Java高级类特性二
date: 2016-12-21 16:17:17
category: "编程语言"
tags: "java学习记录"
---
## 关键字：static  

** 使用范围：**
在Java类中，可用static修饰属性、方法、代码块、内部类

** 被修饰后的成员具备以下特点: ** 
* 随着类的加载而加载
* 优先于对象存在
* 修饰的成员，被所有对象所共享
* 访问权限允许时，可不创建对象，直接被类调用

类方法(class Method) 
* 没有对象的实例时，可以用类名.方法名()的形式访问由static标记的类方法。
* 在static方法内部只能访问类的static属性，不能访问类的非static属性。
* 因为不需要实例就可以访问static方法，因此static方法内部不能有this。(也不能有super ? YES!)
* 重载的方法需要同时为static的或者非static的。

## 理解main方法的语法  
由于java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public，又因为java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static的，该方法接收一个String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数。 

## 类的成员之四：初始化块

** 初始化块(代码块)作用： **
对Java对象进行初始化
 
** 程序的执行顺序： **
1、声明成员变量的默认值
	

2、显式初始化、多个初始化块依次被执行（同级别下按先后顺序执行）
	

3、构造器再对成员进行赋值操作


## 关键字：final

** 在Java中声明类、属性和方法时，可使用关键字final来修饰,表示“最终”。 **
* final标记的类不能被继承。提高安全性，提高程序的可读性。 
String类、System类、StringBuffer类
* final标记的方法不能被子类重写。
Object类中的getClass()。
* final标记的变量(成员变量或局部变量)即称为常量。名称大写，且只能被赋值一次。
	* final标记的成员变量必须在声明的同时或在每个构造方法中或代码块中显式赋值，然后才能使用。
	* final double PI=3.14;


## 抽象类(abstract class)

* 用abstract关键字来修饰一个类时，这个类叫做抽象类；
* 用abstract来修饰一个方法时，该方法叫做抽象方法。
* 抽象方法：只有方法的声明，没有方法的实现。以分号结束：abstract int abstractMethod( int a );
* 含有抽象方法的类必须被声明为抽象类。
* 抽象类不能被实例化。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。
* 不能用abstract修饰属性、私有方法、构造器、静态方法、final的方法。

## 更彻底的抽象：接口(interface)

* 有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。
* 接口(interface)是抽象方法和常量值的定义的集合。
* 从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现。
* 实现接口类：
* class SubClass implements InterfaceA{ }
* 一个类可以实现多个接口，接口也可以继承其它接口。

*接口的特点：
	*用interface来定义。
	*接口中的所有成员变量都默认是由public static final修饰的。
	*接口中的所有方法都默认是由public abstract修饰的。
	*接口没有构造器。
	*接口采用多继承机制。

* 实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类。
* 接口的主要用途就是被实现类实现。（面向接口编程）
* 与继承关系类似，接口与实现类之间存在多态性
* 定义Java类的语法格式：先写extends，后写implements
* 如果实现接口的类中没有实现接口中的全部方法，必须将此类定义为抽象类 
* 接口也可以继承另一个接口，使用extends关键字。


** 工厂方法(FactoryMethod)  **

概述：
定义一个用于创建对象的接口，让子类决定实例化哪一个类。FactoryMethod使一个类的实例化延迟到其子类。

适用性：
1. 当一个类不知道它所必须创建的对象的类的时候
2. 当一个类希望由它的子类来指定它所创建的对象的时候 
3. 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候


## 类的成员之五## 

* 在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。
* Inner class一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。
* Inner class的名字不能与包含它的类名相同；
* Inner class可以使用外部类的私有数据，因为它是外部类的成员，同一个类的成员之间可相互访问。而外部类要访问内部类中的成员需要:内部类.成员或者内部类对象.成员。
* 分类：成员内部类（static成员内部类和非static成员内部类）
	     局部内部类（不谈修饰符）、匿名内部类

*Inner class作为类的成员：
	*可以声明为final的
	*和外部类不同，Inner class可声明为private或protected；
	*Inner class 可以声明为static的，但此时就不能再使用外层类的非static的成员变量；
*Inner class作为类：
	*可以声明为abstract类 ，因此可以被其它的内部类继承

> 【注意】非static的内部类中的成员不能声明为static的，只有在外部类或static的内部类中才可声明static成员。

** 匿名内部类 **
匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。
```
new 父类构造器（实参列表）|实现接口(){
    //匿名内部类的类体部分
}
```