[{"title":"大前端工具集","date":"2018-04-26T07:37:15.000Z","path":"2018/04/26/blog20180426/","text":"大前端工具集 这个项目的定位是 大前端程序猿的百宝箱。主要针对 前端方向和 Node 方向；主要内容是国内外优秀的库、工具、套路、设计/交互或关注的前端组织/博客等等，反正用 瑞士军刀 来总结这篇文章再合适不过了。 对于列在这里的几乎所有项目，我都有去实践与了解，所以我会尽量给出中肯的建议和理解，也希望大家能多关注我的评语:) 感谢和期待大家的 PR，我会及时回复的~ 目录 前端组织/前端博客 博客搭建 HTML CSS 浏览端 JS React &amp; RN Project Build Node Package Node Project 精选阅读 前端技术 Node 学习资料 前端面试 其他技术 工具/软件 Web APP Mac 软件篇 Linux Chrome Plugins Git 服务端 数据端 客户端 设计/交互 速查手册 杂七杂八 前端炫技-炫酷狂拽叼炸天的 Web 小结 TODO 正文前端组织/前端博客 虽混过外企俩家，但劳资英文这项的技能点还是灰色的…so，俺关注的站点主要以中文为主 GitHub - 没 都不好意思面基有木有！！！12345678910- [MDN](https://developer.mozilla.org/zh-CN/) - 无数的资源再等着你探索，追标准和新特性肯定得关注的网站- [Awesomes.cn](https://www.awesomes.cn/) - 国人维护的前端资源库，深度对接到 ```Github```，分类和展现清晰，值得收藏- [如何跟上前端开发的最新前沿](https://uptodate.frontendrescue.org/zh/) - RT，不解释- [慕课](http://www.imooc.com/) - 大量的在线计算机课程。 虽然初、中级居多，但是不乏有巨作值得细细品尝- [阮一峰](http://javascript.ruanyifeng.com/) - 关注多年，拜读其 [ES6](http://es6.ruanyifeng.com/) 系列。虽网传靠写书进鸟阿里，但博客内容确实够丰富- [W3Cplus](http://www.w3cplus.com/) - 大漠(《图解 CSS3》作者)在国内的影响力杠杠的，```Sass``` 专家级- [淘宝前端团队](http://taobaofed.org/) - 内容涵盖 ```Web``` 和 ```Node```，要深度有深度，要广度有广度- [奇舞团博客](http://www.75team.com/) - 坚持是最宝贵的，别人的奇舞周刊早已经过百期了- [大搜车前端](http://f2e.souche.com/blog/) - 前端网红 [小芋头君](http://weibo.com/676588498) 所在的团队，文章质量高，尤其是 Node 方向的- [百度 FEX](http://fex.baidu.com/) - 代表作 ```FIS```、```UEditor```、```WebUploader```、```KityMinder 腾讯全端 AlloyTeam - 腾讯 Web 前端团队，博客真的有点丑… 粉丝日志 for 张丹 - 大爱作者写的 系列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184- [张鑫旭](http://www.zhangxinxu.com/wordpress/) - 成名多年的、高产的前端大湿，```CSS```猛人&lt;h3 id=&quot;blog_build&quot;&gt;博客搭建&lt;/h3&gt;- [Hexo](https://hexo.io/zh-cn/) - 快速、简洁且高效的博客框架，照着文档分分钟就可以在本地跑起来。```Github``` 地址:[Hexo](https://github.com/hexojs/hexo)- [Jekyll](http://jekyll.bootcss.com/) - 将纯文本转化为静态网站和博客。由于环境依赖的问题，所以安装起来可能稍费劲那么一点。```Github``` 地址：[Jekyll](https://github.com/jekyll/jekyll)- [GithubPages](https://pages.github.com/) - 免费的静态站点。配合着 ```Hexo``` 或 ```Jekyll``` 的模板，分分搭建出一套炫酷的个人博客- [Tumblr](https://www.tumblr.com/) - 轻博客的祖师爷，各种各样的主题感觉不错- [Wordpress](https://zh-cn.wordpress.com/) - 这玩意古老到都不想介绍&gt; 使用 ```Hexo/Jekyll + GitPage```，前端搭建静态博客那是相当 easy。用 ```Markdown``` 写文章做记录，再 ```push``` 到 ```Github``` 上，分分钟高大上有木有再推荐三款视觉效果极佳的 ```Hexo``` 主题，且在 ```Github``` 上的 ```star``` 都很不错：- [NexT](https://github.com/iissnan/hexo-theme-next)- [Yilia](https://github.com/litten/hexo-theme-yilia)- [Tranquilpeak](https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak)不能偏心，所以也推荐三款 ```Jekyll``` 的好主题：- [So Simple](https://github.com/mmistakes/so-simple-theme) 如果你看过俺的博客，对这个主题就肯定不会陌生啦- [HPSTR](https://github.com/mmistakes/hpstr-jekyll-theme) 当初 [fefork](http://www.fefork.com/) 差点选这个主题:)- [beautiful](https://github.com/daattali/beautiful-jekyll#readme)&lt;h3 id=&quot;html&quot;&gt;HTML&lt;/h3&gt;纯 ```HTML``` 相关其实没有好玩的项目，所以这儿展示的内容主要都是一些模板，而且以下列出来的都是免费的，方便拿取搭架后台或者博客- [HEAD](https://github.com/joshbuchea/HEAD) - 最全的 ```&lt;head&gt;``` 列表，真心佩服这种偏执的整理能力- [blur-admin](https://github.com/akveo/blur-admin) - 视觉冲击极强的管理后台，各种动画效果。PS：因为团队有[ant-design](https://github.com/ant-design/ant-design)的使用经验，感觉使用起来不是很顺畅，这套后台又是基于```AngularJS```，所以再三权限之后还是没实际使用，劳资还是别给团队添乱了，囧...- [AdminLTE](https://github.com/almasaeed2010/AdminLTE) - 很小清新的后台模板，每次看[preview](https://almsaeedstudio.com/preview) 页面都觉得很有视觉冲击- [gentelella](https://github.com/puikinsh/gentelella) - 刚用这个搭建了我司内部用的的数据平台，效果喜人。模板实现的功能比较全，比如登录、注册甚至各种 ```widget```，所以最终交付的时候，自己几乎没写几行CSS。- [material-design-lite](https://github.com/google/material-design-lite) - ```Star``` 数超过2W的开源模板项目，包含了多套简洁的 ```templates```，可以用于博客、后台或者企业首页。&lt;h3 id=&quot;css&quot;&gt;CSS&lt;/h3&gt;- [MetroUI](http://metroui.org.ua/) - 好看好用，重点是样式特别、个性- [Font-Awesome](http://fontawesome.io/) - 图标字体库。相类似的库有不少，大厂都喜欢造轮子嘛:)- [LoadersCSS](https://connoratherton.com/loaders) - 用 CSS 技术实现 loading 动画； 补一句，想熟悉、理解 ```keyframes、animation、transform、transition``` 的童鞋可以直接去读其源码(只有千把行代码)，读完就算出师鸟:)- [text-spinners](https://github.com/tawian/text-spinners) - 又是一款 spinners 效果的库，用来做 loading 正合适。- [WeUI](https://github.com/weui/weui) - 一套同微信原生视觉体验一致的基础样式库 为微信 Web 开发量身设计，令用户的使用感知更加统一- [PostCSS](https://github.com/postcss/postcss) - 最近才知道大名鼎鼎[Autoprefixer](https://github.com/postcss/autoprefixer)是其插件 推荐大漠的文章[《PostCSS深入学习》](http://www.w3cplus.com/PostCSS/postcss-deep-dive-what-you-need-to-know.html)，有关 PostCSS 不是什么？PostCSS 是什么？PostCSS 可以做什么等等问题，文章里面有答案- [CSSgram](https://github.com/una/CSSgram) - 图片滤镜库，终于可以用 CSS 在 web 上实现滤镜的效果鸟 IE不支持，不过新的移动设备支持没问题 [Can I Use](http://caniuse.com/#search=CSS%20Blend%20Modes)- [HINT.css](https://github.com/chinchang/hint.css) - 一款非常小巧的提示框效果- [Balloon.css](http://kazzkiq.github.io/balloon.css/) - 同上，一款非常小巧的提示框效果- [Hover.css](http://ianlunn.github.io/Hover/) - 很多鼠标 Hover 态的效果，可以给产品学习一下:)- [Cursor](http://css-cursor.techstream.org/) - 记录各浏览器对Cursor的支持情况- [csscss](https://github.com/zmoazeni/csscss) - 用于检查 CSS 代码冗余- [purecss](http://purecss.io/) - 小巧的响应式 CSS 库，Yahoo!出品- [hamburgers](https://jonsuh.com/hamburgers/) - 简单的动画库，让 Click(or Tap) 变得美妙- [cssmatic](http://www.cssmatic.com) - 一个帮忙调试CSS效果的工具&lt;h3 id=&quot;javascript&quot;&gt;浏览端 JS&lt;/h3&gt;- [requirejs](https://github.com/requirejs/requirejs) - JS模块化是构建复杂项目的第一步 中文学习文档奉上：[RequireJS 中文网](http://www.requirejs.cn/)- [three.js](https://github.com/mrdoob/three.js) - JavaScript 3D 库。超多的 [examples](http://threejs.org/examples/) 等着你去发现，你只需要关注内存和风扇就行了- [ECharts](http://echarts.baidu.com/index.html) - 好用，最关键的是支持的图表展示非常之多，强烈推荐- [Swiper](http://www.swiper.com.cn) - 强大的 Slider 库 其实这类效果库非常多，但文档能那么专业的就很少鸟- [babel](https://babeljs.io/) - ```ES6``` 用起来。这个插件可以让我们用新的 **标准/提案** 写 ```JavaScript``` 代码，然后再向下 **转换编译**，最终生成随处可用的 ```JavaScript``` 代码。中文文档奉上[《babel-handbook》](https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/README.md)- [dvajs](https://github.com/dvajs/dva) - 基于 Redux 的一层封装，推荐的原因是因为阿里同学写文档都比较大而全，还可以顺道学习周边知识:)- [fullPage](http://alvarotrigo.com/fullPage/) - 非常好用的全屏滑动库，看 Demo 就明白- [PhotoSwipe](http://photoswipe.com/) - 偶常用的 js 库 官网上有这么一句很关键、重要&quot;no dependencies&quot;- [Vuejs](http://cn.vuejs.org) - 比较喜欢其作者... 所以劳资正在看源码学习学习- [ScrollReveal](https://github.com/jlmakes/scrollreveal.js) - star 10000+ 轻量级 JS 库。作用为当元素进入视窗的时候展示它们，README 中有示例，上手非常简单。官网体验地址：[ScrollReveal](https://scrollrevealjs.org/)- [vue-admin](https://github.com/fundon/vue-admin) - 基于 Vue.js 开发的后台，示例地址：[demo](https://vue-admin.fundon.me)- [mixitup](https://github.com/patrickkunka/mixitup) 一款基于 ```jQuery``` 的 **排序/过滤** 的JS库，最关键是有着美妙的动画效果- [favico.js](http://lab.ejci.net/favico.js/) - 动态改变浏览器标签栏中的网站图标，非常好玩- [ant.design](http://ant.design) - 蚂蚁金服搞的良心项目，文档美好的令人发指 样式优雅，强烈推荐内部系统尝试此库- [highlightjs](https://highlightjs.org/) - 代码高亮库，支持非常多的语言- [daterangepicker](http://www.daterangepicker.com) - 时间选择插件的不二选择，基于 ```Bootstrap``` 和 [Moment.js](http://momentjs.com/)- [nodePPT](https://github.com/ksky521/nodePPT) - 前同事三水的大作，好用必须得支持:) 用 Markdown 写 PPT，还可以 HTML 混排，上手飞快- [excellentexport](https://github.com/jmaister/excellentexport) - 纯前端的 Excel 导出，非常之方便- [Sortable](https://github.com/RubaXa/Sortable) - 拖拽神器，用了就知道- [toastr](https://github.com/CodeSeven/toastr) - 信息提示的库，推荐的原因是卖相好、功能强大 [demo](http://codeseven.github.io/toastr/demo.html)- [peity.js](http://benpickles.github.io/peity/) - jQuery的图表插件，特别cute，感觉萌萌哒 将HTML转换成一个小的```&lt;svg&gt;```饼图、圆环图、折线图等等- [emojify.js](https://github.com/Ranks/emojify.js) - 能够将```emoji```关键词转换为```emoji```图片的```JS```插件 可以快速的为你的网站提供```emoji```表情支持- [Push.js](https://github.com/Nickersoft/push.js) - 基于 ```Notification API``` 实现的桌面效果的提示栏。浏览器支持情况不错，如[http://caniuse.com/#search=Notification](http://caniuse.com/#search=Notification)- [Highcharts](http://www.hcharts.cn/) - Highcharts 中文网，又是一个图表库 确实功能强大，但是觉得不好看... PS：官网就做的不好看，脏脏的赶脚- [NProgress](https://github.com/rstacruz/nprogress/) - 使页面加载时有更好的loading效果- [Noticejs](https://github.com/jaredreich/notie.js) - 一个简单的通知库，木有依赖- [onepage-scroll](https://github.com/peachananr/onepage-scroll) - 依赖 jQuery 的单页滚动库，和 [fullPage](http://alvarotrigo.com/fullPage/) 类似- [videojs](http://videojs.com/) - 当下视频需求都用上```&lt;video&gt;```鸟 样式和交互统一的问题交给 videojs 搞定:)- [clipboard](http://zenorocha.github.io/clipboard.js/) - 仅 2KB 大小，搞定剪贴板功能，屌不屌~ 但是，Safari 不支持...- [impress.js](https://github.com/impress/impress.js) - 用来写 PPT 不错，偶也曾为其写过一篇[impress.js 初体验](http://www.cnblogs.com/Darren_code/archive/2013/01/04/impressjs.html)- [Cropper](http://fengyuanchen.github.io/cropper/) - 国人开发的图片裁剪库&gt; ___```Swiper/PhotoSwipe/fullPage``` 有这仨库，微信里常见的 H5 页完全不是问题哒___&lt;h3 id=&quot;react&quot;&gt;React &amp; RN&lt;/h3&gt;- [awesome-react-native](https://github.com/jondot/awesome-react-native) - 不解释&lt;h3 id=&quot;project_build&quot;&gt;Project Build&lt;/h3&gt;- [pm2](https://www.npmjs.com/package/pm2) - 是一个带有负载均衡功能的 Node 应用的进程管理器； 是 [Forever](https://www.npmjs.com/package/forever) 的进阶库，想了解的可以看这篇文章[《拥抱PM2》](http://se77en.cc/2013/06/27/goodbye-node-forever-hello-pm2-translation/)- [Webpack](http://webpack.github.io/) - 项目构建工具，由于过于复杂和太强大，所以劳资还没去深入研究。推荐篇教程：[webpack 教程资源收集](https://github.com/naraku666/webpack-tutorial-collection)- [Gulp](https://github.com/gulpjs/gulp/) - Gulp 是基于 Node 实现 Web 前端自动化开发的工具。 俺总结了篇[《gulp使用小结》](http://www.fefork.com/gulp_1/)，推荐您阅读:)- [Bower](http://bower.io/) - 前端项目的包管理其实是件复杂的事 谁谁谁依赖谁谁谁，谁谁谁依赖谁谁谁的某个版本...卧槽 Bower 就是搞定这件事儿的，亲爹是 Twitter 推荐篇 Bower 的中文文章：[《bower 解决 js 的依赖管理》](http://blog.fens.me/nodejs-bower-intro/)- [Grunt](http://gruntjs.com/) - 和 Gulp 类似，都是项目构建的常见选择 对比这俩的文章可谓不少，推荐篇[《Gulp vs Grunt》](http://www.benben.cc/blog/?p=407) 英盲又想看文档，可以去[Grunt 中文网](http://www.gruntjs.net/)- [FIS](http://fex-team.github.io/fis3/) - 度厂出品的前端构建工具 文档清晰，功能强大，推荐了解和使用- [Gitlab CI](https://ci.gitlab.org/) - 一套基于[Gitlab](https://about.gitlab.com/)的持续集成服务- [Travis CI](https://travis-ci.org/) - 为 Github 上的项目打造的 CI 服务。记得 2013年 开始陆续看到文章介绍，刚在官网上看到，目前已经有 30W 开源项目和 23.5W 用户在使用。大概看了一下 [getting started](https://travis-ci.org/getting_started)，简单几步就可以实现开源项目的持续集成。&gt; Gulp + Webpack 的使用__套路__参考: [learning-gulp](https://github.com/demohi/learning-gulp)&gt; Gulp 资料收集：[use-gulp](https://github.com/Platform-CUF/use-gulp)&gt; 推荐篇与 Webpack 相关的文章《[CSS Modules](http://boke.io/tan-tan-css-modules/)》&gt; Webpack 用起来吼吼：[webpack-howto](https://github.com/petehunt/webpack-howto)&lt;h3 id=&quot;node_package&quot;&gt;Node Package&lt;/h3&gt;&gt; 作为一名大前端甚至是多端，```Node``` 绝逼是必备的一块&gt; 有关 ```Node``` 的学习资料，请访问 [Node 学习资料](https://github.com/nieweidong/fetool#node_read)##### 这里介绍些有特色且前端有必要知道的包- [anywhere](https://www.npmjs.com/package/anywhere) - 随时随地将你的当前目录变成一个静态文件服务器的根目录- [supervisor](https://www.npmjs.com/package/supervisor) - 监控 Node 代码，自动重启。 A supervisor program for running nodejs programs- [nodemon](https://github.com/remy/nodemon) - 监控 Node 代码，自动重启。 Nodemon is a utility that will monitor for any changes in your source and automatically restart your server.- [pm2](https://www.npmjs.com/package/pm2) - 是一个带有负载均衡功能的 Node 应用的进程管理器； 是 [Forever](https://www.npmjs.com/package/forever) 的进阶库，想了解的可以看这篇文章[《拥抱PM2》](http://se77en.cc/2013/06/27/goodbye-node-forever-hello-pm2-translation/)- [cz-cli](https://github.com/commitizen/cz-cli) - 刚用上的一个 ```git ci``` 工具，让我们的项目提交代码更规范、更有套路。打算写篇文章分享下，文章正在准备中，写完后会补地址。- [async](https://www.npmjs.com/package/async) - 一个流程控制工具包，提供直接而强大的异步功能- [optimist](https://www.npmjs.com/package/optimist) - 当需要处理 ```CLI``` 中的 ```argv``` 时(即命令行传参)，用它就行了- [lodash](https://www.npmjs.com/package/lodash) - JS 工具库 ```Underscore.js```的一个 fork 发展而来- [socket.io](https://github.com/socketio/socket.io) - 预计 Node 的实时框架 聊天室、页游等对实时性有高要求的较适用- [Inquirer.js](https://github.com/SBoudrias/Inquirer.js) - 实现的效果比 [Commander](https://github.com/tj/commander.js) 简单、有趣，贴个 GIF供大家参考：[loc](https://raw.githubusercontent.com/nieweidong/local-info/master/img/loc.gif)- [Commander](https://github.com/tj/commander.js) - 用 Commander.js 可以方便的创建基于 Node 的命令行工具，比如 [vue-cli](https://github.com/vuejs/vue-cli) 这类，瞬间觉得自己又高大上了呢~- [Mongoose](https://github.com/Automattic/mongoose) - 让 NodeJS 更容易操作 Mongodb 数据库； 附上一篇[Mongoose 学习参考文档](https://cnodejs.org/topic/504b4924e2b84515770103dd)- [CNPM](http://npm.taobao.org/) - 淘宝 NPM 镜像，提供了 NPM 同步的服务 当然可不仅仅这样，利用 CNPM 可以打造__企业/个人__私有的 NPM 服务 推荐篇搭建私有NPM的文章：[《CNPM搭建私有的NPM服务》](http://blog.fens.me/nodejs-cnpm-npm/)- [koa](http://koajs.com/) - 玩 Node 都知道 express，但使用 koa 的就少很多，门槛比 Ex 稍高 通过 generator 避免繁琐的回调函数嵌套，强烈推崇 [官方的文章教程](https://github.com/guo-yu/koa-guide)- [Shipit](https://github.com/shipitjs/shipit) - 一个强大的自动化部署工具。 shipit 很多地方非常类似 gulp，他们的核心都是任务系统。- [node-inspector](https://www.npmjs.com/package/node-inspector) - Node 调试工具，使用起来跟 Chrome 的 JS 调试器很相似- [winston](https://www.npmjs.com/package/winston) - Node 服务最流行的日志库之一- [co](https://www.npmjs.com/package/co) - 用 generator 写法让异步代码同步- [thenify-all](https://www.npmjs.com/package/thenify-all) - 把异步的方法变成 Promise 的 Promisifies all the selected functions in an object- [PhantomJS](http://phantomjs.org/) - 一般用来做抓取截图和无界面测试 也可以用来操作 DOM 和网络监测，很好玩的库 [Quick Start](http://phantomjs.org/quick-start.html)- [ava](https://www.npmjs.com/package/ava) - 偶是应TJ大神推荐而得之的 ```ava``` 未来的测试运行器- [Mocha](https://github.com/mochajs/mocha) - Node 里最常用的测试框架； 它支持多种 Node 的 Assert libs； 同时支持异步和同步的测试，同时支持多种方式导出结果； 也支持直接在 browser 上跑 JS 代码测试。- [koa-validate](https://www.npmjs.com/package/koa-validate) - ```koa``` 的校验库 可以非常方便的对 ```queryString``` 或 ```postBody``` 的信息进行验证- [line-reader](https://www.npmjs.com/package/line-reader) - 基于```steam```的按行读文件，偶处理日志时用哒 要不实现一个按行读文件，又得 ```steam```、 又得 ```chunk```，还是比较麻烦的- [binary](https://github.com/substack/node-binary) 作者是大神 [substack](https://github.com/substack)，对应的处理 ```PHP/Python``` 中的 ```unpack``` 方法。英文解释：Unpack multibyte binary values from buffers and streams.- [everyauth](https://www.npmjs.com/package/everyauth) - OAuth 的集成解决方案- [shelljs](http://documentup.com/shelljs/shelljs) - 写 Node 时难免需要用 shell 去操作些神马 shelljs 是基于 Node 的 shell 工具，API 及其简单- [hashids](https://www.npmjs.com/package/hashids) - 看名称就懂，给 userid 加解密用的- [node-pool](https://github.com/coopernurse/node-pool) - 让 ```Node``` 有连接池的概念- [colors](https://www.npmjs.com/package/colors) - 花俏的小工具 让打印```console.log```时有更好的展示样式- [n](https://www.npmjs.com/package/n) - 控制Node的版本，想升级一行代码搞定&gt; ```supervisor``` 和 ```nodemon``` 这俩都是监控 Node 代码，使得每次修改代码后会，开发 Node 程序必备&gt; 以上库俺都有使用过，甚至有不少都是项目开发中、各种特定场景下必用的，有任何使用问题欢迎沟通哈:)&lt;h3 id=&quot;node_project&quot;&gt;Node Project&lt;/h3&gt;_暂无_&lt;h2 id=&quot;read&quot;&gt;精选阅读&lt;/h2&gt;&lt;h3 id=&quot;fedev&quot;&gt;前端技术&lt;/h3&gt;- [2015D2前端论坛](http://www.imooc.com/learn/590) - Node方向非常值得看，有干货，相信东哥推荐哈- [前端开发规范手册](http://zhibimo.com/read/Ashu/front-end-style-guide/index.html) - 此手册主要实现的目标：代码一致性和最佳实践- [《babel-handbook》](https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/README.md) - 可以用新的规范(如 ```ES6```)写代码，经过 ```babel``` 编译后生成没有兼容问题的代码- [JavaScript Standard Style](http://standardjs.com/) - 强烈推荐，尤其适合技术 Leader。优秀的 JS 编码规范是好前端团队的开始- [ECMAScript 6入门](http://es6.ruanyifeng.com/) - 阮一峰大神所著，一本开源的JS教程 全面介绍 ECMAScript 6新引入的语法特性- [ReactNative 中文版](http://wiki.jikexueyuan.com/project/react-native/) - 翻译自官方的中文文档- [ReactWebpackCookBook](https://fakefish.github.io/react-webpack-cookbook/index.html) - 此书会引导读者是进入```React```和```Webpack```的世界。 俩都是非常前沿的技术，同时使用会更有趣。- [Sass指南](https://github.com/W3cplus/sass-guidelines) - Sass指南主要作用是用来帮助大家更好的书写 Sass和维护 Sass。- [ReactNative 学习指南](https://github.com/ele828/react-native-guide) - 新玩意层出不穷... 对于能持续学习的童鞋，这是个美好的时代- [HTML/CSS 编码规范](http://www.css88.com/doc/codeguide/) - 编写灵活、稳定、高质量的```HTML```和```CSS```代码的规范- [移动前端入门](http://gold.xitu.io/entry/56c29abfa34131005b8cb1f3) - 入门价值高，移动方向常见问题的较好总结- [GulpBook](https://github.com/nimojs/gulp-book) - Gulp 是基于 Node 实现 Web 前端自动化开发的工具&lt;h3 id=&quot;node_read&quot;&gt;Node 学习资料&lt;/h3&gt;- [Node.js 中文资料导航](https://github.com/youyudehexie/node123) - Node 的中文资料导航，```start1300+ 从零开始 NodeJS 系列文章 - 基本上每一篇都看过，强烈推荐 Node.js 包教不包会 - 值得阅读，看完绝不用买书鸟 七天学会 NodeJS - 劳资还没看，不过看目录还不错:) Style Guide - 这是一份关于如何写出一致且美观的 代码的风格指南12345678910- [koa实战](http://book.apebook.org/minghe/koa-action/index.html) - “[明河](https://github.com/minghe)出品”这四字已经说明一切。PS：正在连载中- [stream-handbook](https://github.com/jabez128/stream-handbook) - 如果学习 NodeJS，那么流一定是需要掌握的概念&lt;h3 id=&quot;interview&quot;&gt;前端面试&lt;/h3&gt;- [笔试面试知识整理](https://github.com/HIT-Alibaba/interview) - 打开其 Gitbook 上的地址我都惊呆了。虽然有部分内容待完善，但是光浏览目录都是享受。- [在 LinkedIn 做面试官的故事](http://dongfei.baijia.baidu.com/article/52449) - 非面试题，介绍 LinkedIn 的面试过程 文章有很多中肯的建议和想法，推荐阅读- [大漠：写给前端面试者](http://www.w3cplus.com/css/write-to-front-end-developer-interview.html) - 这篇文章不涉及任何的面试题 大漠与大家聊聊面试者与被面者之间的感受...- [前端面试题](https://github.com/h5bp/Front-end-Developer-Interview-Questions/tree/master/Translations/Chinese) - Git 上非常火的前端面试题，```start17k+ 前端面经 - 主要内容是些前端面试笔试题和面试套路，值得阅读 其他技术 微信小程序开发资源汇总 - 天津第一程出品。微信小程序开发资源汇总。 命令行的艺术 - 熟练使用命令行是优秀工程师的基础 MongoDB 极简实践入门 - 入门推荐的套路，非常浅显易懂 Mac 设置指南 - Mac 使用必看 尤其适合 偏执狂/强迫症 患者:) Markdown 资料 - 简单看些语法入门，快速用起来 工具/软件 Web 百度脑图 - 非常方便的思维导图工具。功能强、样式佳、无广告，算百度出的良心产品之一。除了 Evernote，脑图是我非常依赖的记录工具 CanIuse - 前端必备；查看浏览器对各种新特性的兼容情况 overapi - 最全的开发人员在线速查手册 ProcessOn - 和百度脑图的功能类似，脑图工具。但是还有社交、通讯的功能，提倡 协作绘图 的理念。感觉网页跳转的时候有点慢，模板样式比百度脑图好看(个人观点)，而且团队协作的功能真的相当好用。 Slides - 一个所见即所得的 WebPPT 编辑器。虽然装X效果一般，但是比较推荐，因为无论懂不懂 UI，做出来的效果不会太难看 faviconer.co - 一个所见即所得的icon生成器，很好用 smallpdf - 提供各种格式和 PDF 互相转换 Cmd Markdown - 好用的 Web 版 Markdown 编辑器 VimAwesome - Vim 插件集合，Vim 党必备 Tower - 小而美的多人协同工具。 不光只有 Web 版，还有 iPhone、iPad、Android、微信版。 StackEdit - 又是一款 Web 版 Markdown 编辑器 墨刀 - 一个在线移动应用原型制作工具。 旨在帮助产品经理快速制作可在手机端展示的移动应用原型。 htm2pdf - HTML to PDF Speaker Deck - 在线的演讲稿展示平台 RunJS - 在线编辑、展示、分享、交流你的 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061- [Bootswatch](https://bootswatch.com/) - ```Bootstrap``` 的免费模板- [AdminLTE](https://github.com/almasaeed2010/AdminLTE/) - 又是一个 ```Bootstrap``` 的免费管理后台&lt;h3 id=&quot;app&quot;&gt;APP&lt;/h3&gt;&gt; 以下列表中的 APP 都是不区分系统平台的- [印象笔记](https://www.yinxiang.com/) - 免费账号完全够用，跨平台跨终端的记录软件- [365日历](http://www.365rili.com/) - 首先肯定比系统自带的日历强大，要不推荐个蛋蛋 俺一般用来搞目标管理，比如学习计划和工作计划 生活中会订阅演唱会、电影首映的信息- [多看阅读](http://www.duokan.com/) - kindle 确实好，但是懒得随身带着 多看还算不错，书较多且偶尔有特价比较爽- [Surge](https://itunes.apple.com/cn/app/surge-web-developer-tool-proxy/id1040100637?mt=8&amp;v0=WWW-GCCN-ITSTOP100-PAIDAPPS&amp;l=&amp;ign-mpt=uo%3D4) - 非免费 牛逼的网络开发与调试工具，前端必备- [Monkey](https://github.com/coderyi/Monkey) - Monkey 是 iPhone 上一个 GitHub 第三方客户端。 展示 GitHub 上的开发者的排名，以及仓库的排名&lt;h3 id=&quot;mac_soft&quot;&gt;Mac 软件篇&lt;/h3&gt;&gt; 对于美好事务的追求无论何时都不算晚。Mac 下的软件那么多，又是免费又是付费，应该怎么选呢？我来分享下我的推荐列表，推荐的优先级老规矩，从上往下依次降低。- [Alfred](https://www.alfredapp.com/) - **免费**，绝对的推荐Top1，很提效率，高级版 ```Powerpack``` 售价 ```£17```。除了能快速搜索和打开应用程序之外，查找文本文件、全文检索、调起浏览器搜索和计数器都是俺经常使用的功能。如果想知道具体咋用，推荐阅读老池(池建强)的文章：[《神兵利器—Alfred》](http://www.cnblogs.com/chijianqiang/p/alfred.html)- [iTerm2](http://www.iterm2.com/) - **免费**。```Mac``` 终端功能少又不好看，```iTerm2``` 可以解救你~ 推荐篇文章：[《让你的命令行丰富多彩》](http://swiftcafe.io/2015/07/25/iterm/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io)- [HyperDock](https://bahoom.com/hyperdock/) - 售价 ```￥68```，感觉还是很值的(特么我还想说，```Windows``` 数年前就自带的功能，在 ```Mac``` 上还收费，略忧伤)。预览和快速切换窗口太有必要了，能用快捷键控制窗口，能让拖拽到边缘的窗口自动调整大小(window早就有的功能)，真心能提高效率。推荐篇中文的文章：[让Mac的窗口飞](http://www.cnblogs.com/ider/p/let-mac-window-fly-with-hyperdock.html)- [ATOM](https://atom.io) - **免费**。2015/7 之前，在桌面环境下偶最喜欢的编辑器是 ```Sublime```，但之后就是 ```ATOM```，俺也专门为它写了篇 [《使用纪要》](https://github.com/nieweidong/learn-atom)- [Surge](https://itunes.apple.com/us/app/surge-web-developer-tool-proxy/id1040100637) - ```$49.99```。关注 ```IOS``` 开发或者常备梯子的同学，肯定都知道这大名鼎鼎的软件。价钱从 ```￥68``` 涨到 ```$99``` 也让偶咋舌，背后的故事就不细说了，感兴趣可自行去谷歌百度一下。PS：翻墙软件 [小飞机ShadowsocksX](https://shadowsocks.com/) 也非常棒，同样推荐：“轻量级科学上网姿势，改变您的生活体验！”- [ngrok](https://ngrok.com/) - 一条命令解决的外网访问内网问题,无需任何配置,下载客户端之后直接一条命令让外网访问内网不再是距离.- [1Password](https://1password.com/) - **免费** 试用一个月，售价不便宜 ```$64.99```。如果觉得对各种账号的密码管理心累，那么推荐你使用，这个钱肯定值，```Mac``` 和 ```iPhone``` 通用，爽歪歪。如果账号密码都是那种一、俩个套路，而且被盗也随意，那么用不用就无所谓啦- [Go2Shell](http://zipzapmac.com/Go2Shell) - 一款适合程序员的神器。可以快速在当前目录打开 Shell 的工具，比如直接在 Finder 里打开 ITerm2。- [Sequel Pro](http://www.sequelpro.com) - **免费**。好用的 Mysql工具- [OmniPlan](https://www.omnigroup.com/omniplan/) - **免费** 试用 14天。甘特图工具，项目 Leader必备。- [Manico](http://manico.im/) - **免费** 版已经很好用了，全功能版售价 ```￥25```。快捷启动和切换 ```APP``` 的工具，高效的第一步- [Moom](http://manytricks.com/moom/) - 售价 **$10**，有试用版。个人觉得这钱花的值，设置快捷键之后可以方便的调整每个窗口的位置。我不管在家还是公司都是开双屏，外接屏幕三分之一 ```iTerm```，三分之二 ```ATOM```，日常使用时各种全屏、居中、靠左、靠右等用快捷键来回着换，辛福感满满的。- [CheatSheet](https://www.mediaatelier.com/CheatSheet/) - **免费**。能够显示当前程序的快捷键列表，默认的快捷键是长按 ⌘- [奇妙清单](https://www.wunderlist.com/zh/) - **免费** 漂亮的任务清单管理工具。有简中和繁中版，操作和样式都比较简洁，推荐有 TODO需求的人士使用。最关键的是其支持所有设备而且免费。- [马克鳗](http://www.getmarkman.com/) - **免费** 版已经够用啦，收费版是 ```60/年```。英文名 ```MarkMan```，非常强大好用的标注、测量工具，__强烈推荐__- [BrowseShot](https://itunes.apple.com/cn/app/browseshot/id615916400) - **免费**。偶正在使用的网页截图工具，强烈推荐- [Wireshark](https://www.wireshark.org/) - **免费**。说实话，```Mac``` 下木有 ```Fiddler``` 挺不习惯，不过在有更强大的替代品，虽然有点复杂...还好后来下载到便宜(```￥68```)的 ```Surge``` 做替代品- [LICEcap](http://www.cockos.com/licecap/) - **免费**。屏幕录制工具，支持导出 GIF 动画图片格式 轻量级、使用简单，录制过程中可以改变录屏范围- [Bartender 2](https://www.macbartender.com/) - 售价 ```$20.97```，但是可 **免费** 试用四周。Mac右上角菜单的管理工具，试用之后右上角的菜单瞬间清爽了，反正试用下也不花钱:)- [BeyondCompare](http://www.scootersoftware.com) - **免费**。在Windows下就开始用了 比对文件和文件夹杠杠好使，Merge必备工具- [SourceTree](https://www.sourcetreeapp.com/) - **免费**。属于大名鼎鼎的 ```Atlassian```，一款好用的的 ```Git``` 客户端工具，重点是 **支持中文**，哈哈:)- [focus booster](https://www.focusboosterapp.com/) - **免费** 已经够用，当然还有更高级的 ```INDIVIDUAL/PROFESSIONAL```，售价分别是 ```$3/$5```。因为比较在意时间管理，所以当工作压力较大时，这软件是俺的必备之物- [WebTorrent](https://webtorrent.io/) - **免费**。直接播放种子，你懂得。年轻的斯坦福大神 [Feross](http://feross.org/) 开发，Git上的开源项目哦。- [WebStorm](http://www.jetbrains.com/webstorm/) - **$129**，可试用一个月。功能超强的前端 ```IDE```，谁用谁知道 PS：貌似俺插件装多了，用着卡卡的，风扇呼呼转...然后俺就卸载装了，装了 ```ATOM```...- [MindNode](http://mindnode.com/) - 售价 **$29.99**，有免费试用版。这是款漂亮的思维导图工具。其实 [百度脑图](http://naotu.baidu.com/) 这类 Web 上的工具绝对够用了，不太推荐...- [Mou](http://25.io/mou/) - 我曾使用过的 Markdown 编辑器，不推荐使用。原本已经准备去掉，但是偶还是想让大家了解下这个有意思的事情：[《一年了，那个闻名遐迩的 Mou 你还记得吗？》](http://matrix.sspai.com/p/c7a3c9c0)- [Fliqlo](http://fliqlo.com/) - 视觉控会喜欢的屏保软件。纯深色界面上铺满着大大的时间，非常好的简约效果。以上列出来的都是偶觉得比较有意思、有特点的软件。当然，类似 ```Docker```、```Polarr(泼辣修图)``` 等这类都太小众；```有道翻译 ```、```Evernote```、```Foxmail``` 等这类又太大众；然后有些软件买了觉得有点“亏”，比如刚出手买入的 ```Final Cut Pro```，其实机器自带的 ```iMovie``` 就挺好了（完美诠释《Final从入手到放弃》）。所以，这几类就不一一往这列举啦~&lt;h3 id=&quot;linux&quot;&gt;Linux&lt;/h3&gt;&gt; 作为一名程序员兼工具控，我期待自己无比高效首先，都是免费哒；然后，所列项目都是针对 ```CLI(命令行界面)``` 哒；最后，探索无止境- [oh-my-zsh](http://ohmyz.sh/) - ___终端党___ 必备，好处太多太多，比如炫酷的外观，超强的易用性...推荐大家阅读知乎的问题：[《为什么说 zsh 是 shell 中的极品？》](https://www.zhihu.com/question/21418449)- [spf13-vim](https://github.com/spf13/spf13-vim) - 对于 Vim 偶之前做了好多文档和记录，但是自从了解有这个套路，那些记录都可以丢掉了。不过建议想了解的去看看 .vimrc 中的 Plugin，确实足够大而全。PS：如果遇见 ```neocomplete does not work``` 之类的错误，可以参考 [Problems with Vim and lua?](http://stackoverflow.com/questions/26724859/problems-with-vim-and-lua)- [Vundle](https://github.com/VundleVim/Vundle.vim) - Vim 党必备。用于管理各种 Vim 插件，有 Git 就可以安装 ```$ git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle tree - linux 以树状图逐级列出目录的内容，装逼效果和实用功能都不错 cloc - 可用来计算 文件夹中各种语言的代码占比情况。展示内容非常直观，如某目录下 有多少个文件，共多少空格行数、注释行数、代码行数，就这些简单粗暴的内容。常见的安装方式可通过 ```npm``` 来进行安装。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253- [oneapm](http://www.oneapm.com/) - 强大的运维工具，提供多种监控客户端； 有采集、分析、展示等一套功能； PS：我这用了服务器监控(免费哦)- [httpie](https://github.com/jkbrzt/httpie) - 一个 CLI 中的 HTTP 客户端，用法简单，非常适合用来搞调试、测试- [ESLint](http://eslint.org/) - 前端大神[Nicholas C. Zakas](http://nczonline.net/)创建。JavaScript 辅助编码的规范工具，有效控制偶们的代码质量- [Lucario](https://github.com/raphamorim/lucario) 暗色系主题，支持 Vim, Atom, Sublime Text, TextMate, Terminal.app, iTerm, Xcode and XTerm- [cmatrix](http://www.asty.org/cmatrix/) - 作用就是装逼，可以在屏幕上显示经典的黑客帝国的数码雨效果(看官方文档上也有其他效果，俺就不往细研究了)。在 Mac 下安装非常简单，一步搞定：`$ brew install cmatrix`**Mac**- [Homebrew](http://brew.sh/) - 有了他 ```OS X``` 程序猿能更好的专注代码层面。最近在看《七周七语言》，里面出现各种语言环境，用 ```brew``` 来安装、管理各种解释器和编译器，省心省力！- [Xcode](https://developer.apple.com/xcode/) - 因为玩 ```Swift``` 所以早早就下载了，后来才知道原来 ```Mac``` 下如果不安装 ```Xcode```，部分常用的指令都不支持，囧&lt;h3 id=&quot;BrowserPlugins&quot;&gt;Chrome 浏览器插件&lt;/h3&gt;&gt; ```Chrome``` 应用商店必定是需要翻墙的哈。以下插件都是俺多年积累淘出来的，数量不多，所以就不区分 ```Github``` 插件和非 ```Github``` 插件了。按照俺推荐的强度自上向下展示，且大多数插件就是偶工作和生活必备，希望能对大家有用。后续如有新发现好插件，偶也会及时更新哒。- [Postman](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop) - ```POST``` 接口调试终结者，异常强大的接口调试工具。稍稍有一点学习成本，推荐之- [JSONView](https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc) - 就是个 ```JSON``` 格式的查看工具，可以很方便的展示数据，麻麻再也不用担心偶调试接口啦。PS：同类插件有不少，所以用的开心就行- [二维码生成器](https://chrome.google.com/webstore/detail/%E4%BA%8C%E7%BB%B4%E7%A0%81qr%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/pflgjjogbmmcmfhfcnlohagkablhbpmg) - RT。PS：这FF早已经自带生成二维码工具了，```Chrome``` 还得装插件才行，任性...- [WEB前端助手(FeHelper)](https://chrome.google.com/webstore/detail/web%E5%89%8D%E7%AB%AF%E5%8A%A9%E6%89%8Bfehelper/pkgccpejnmalmdinmhkkfafefagiiiad) - [百度FE](https://www.baidufe.com/)出品，功能超全的 Chrome 插件。简单列一下其功能：QR码生成器、字符串编解码工具、JSON格式化查看器、前端编码规范检测、代码压缩工具、页面取色工具、统计并分析网页加载性能等等- [Eye Dropper](https://chrome.google.com/webstore/detail/eye-dropper/hmdcmlfkchdmnmnmheododdhjedfccka) - 前端必备的颜色提取神器，操作简单容易上手- [Vimium](https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb) 和 ```Vim``` 快捷键一样，浏览网站时不需要鼠标咯- [Page Ruler](https://chrome.google.com/webstore/detail/page-ruler/jlpkojjdgbllmedoapgfodplfhcbnbpn) - 前端必备的尺子。计算页面元素间距、位置等信息的时候，你就知道它的好了，无脑上手，你值得拥有- [FireShot](https://chrome.google.com/webstore/detail/capture-webpage-screensho/mcbpblocgmgfnpjjppndjkmgjaogfceg) - 可以截取整个网页、部分页面，然后支持导出为各种格式。俺微博上发的网页全景图都是靠这个插件截取的- [Awesome Autocomplete for GitHub](https://chrome.google.com/webstore/detail/awesome-autocomplete-for/djkfdjpoelphhdclfjhnffmnlnoknfnd) - 看名称就基本明白了。让你在 Github上使用搜索框的体验变得更好。- [Infinity](https://chrome.google.com/webstore/detail/infinity-new-tab/dbfmnekepjoapopniengjbcpnbljalfg) - 好不好用有点见仁见智了，但是我个人比较喜欢。使用后会让你的 **新标签页** 耳目一新，有漂亮的背景和各种常用的功能，比如地图、天气、```Gmail```、```Chrome```商店等等。当然，在这个插件的设置中还可以设置壁纸、动画效果等等- [Momentum](https://chrome.google.com/webstore/detail/momentum/laookkfknpbbblfpciffpaejjkokdgca) - 同样也是 **新标签页** 的插件，但是不管是视觉上(高清大图)还是功能上，都比 [Infinity](https://chrome.google.com/webstore/detail/infinity-new-tab/dbfmnekepjoapopniengjbcpnbljalfg) 高大上不少，```Setting``` 里面有不少设置和快捷键，都很好上手的。[Infinity](https://chrome.google.com/webstore/detail/infinity-new-tab/dbfmnekepjoapopniengjbcpnbljalfg)胜在中文和直观，[Momentum](https://chrome.google.com/webstore/detail/momentum/laookkfknpbbblfpciffpaejjkokdgca)胜在视觉冲击。俺基本上这俩款看心情换着用，所以希望你也都能喜欢:)- [Google翻译](https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb) - 英文不好又得经常浏览英文资料的，一般都准备好了翻译工具。不过能在浏览器里达到划词翻译的方案就不多了，偶推荐这个Google翻译(PS：如不能翻墙，有道词典的扩展也同样支持划词翻译)。- [Octotree](https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc) - 在浏览器左侧展示 ```Github``` 项目的文件导航，使目录结构一目了然，而且我们国内 ```Github``` 的访问速度又不稳定，用这个工具也就很提效率了。对经常使用 ```Github``` 的同学强烈推荐- [BuiltWith](https://chrome.google.com/webstore/detail/builtwith-technology-prof/dapjbgnjinbpoindlpdmhochffioedbn) / [wappalyzer](https://chrome.google.com/webstore/detail/wappalyzer/gppongmhjkpfnbhagpmjfkannfbllamg) / [Chrome Sniffer Plus](https://chrome.google.com/webstore/detail/chrome-sniffer-plus/fhhdlnnepfjhlhilgmeepgkhjmhhhjkh) - 几款超强的网站分析工具，可以给出网站非常多的技术栈信息。大到 ```Web Servers```、服务端的 ```Frameworks``` 或 ```JS``` 框架，小到 ```meta```、编码格式甚至 ```Analytics```，非常推荐- [Adblock Plus](https://chrome.google.com/webstore/detail/adblock-plus/cfhdojbkjhnklbpkdaibdccddilifddb/related) - 非常非常有名的免费的过滤广告的插件。PS：广告屏蔽这个见仁见智，其实俺个人还是比较接受一些个性化推荐的广告- [Wide Github](https://chrome.google.com/webstore/detail/wide-github/kaalofacklcidaampbokdplbklpeldpj/related) - 无聊又实用的 ```Github``` 插件。无聊是因为这个插件就特么一个功能，**加宽**，能让 ```Github``` 页面变宽，每行展示更多的内容，尤其配合着[Octotree](https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc)，展示效果极佳。非常推荐 ```Mac``` 用户实用，因为屏幕比较不大，变宽后阅读感觉更好- [Gmail](https://chrome.google.com/webstore/detail/google-mail-checker/mihcahmgecmbnbcchbopgniflfhgnkff) - 方便查看自己的 ```Gmail``` 邮件- [Imagus](https://chrome.google.com/webstore/detail/imagus/immpkjjlgappgfkkfieppnmlhakdmaab) 鼠标指针悬停在链接或缩略图上时直接在当前页面的弹出视图上显示这些图片、HTML5 视频/音频和内容专辑...看新浪微博时贼有用:)- [DevTools Author](https://chrome.google.com/webstore/detail/devtools-author/egfhcfdfnajldliefpdoaojgahefjhhi) - 纯装逼的插件，可以选择你的 ```Chrome``` 开发者工具的主题，且支持的主题超过25种，视觉装逼控必备。设置分大概三步，官网有文字说明，```youtube``` 上的视频教程奉上(Customization With DevTools Author)[https://www.youtube.com/watch?v=AUZagMLMAJc]- [GitPlug](https://chrome.google.com/webstore/detail/porter-plug/lngoojfoglemfpbeiomhgheccpdheilp) - 在 ```Github``` 项目页中嵌入有关的图表信息，直观的展示当前项目的 ```Star Trend```，能方便看到当前这个开源项目的发起时间，火爆趋势；对比较知名的项目还有相关的 ```News``` 展示- [OctoLinker](https://chrome.google.com/webstore/detail/octolinker/jlmafbaeoofdegohdhinkhilhclaklkp) - 在 ```package.json``` 或任意 ```.js``` 文件中，可以方便的对 ```require()``` 的 ```package``` 进去点击，跳转去对应的 ```Github``` 页面。PS：特么不太好表达，建议你去这个插件的概述页，里面有个十来秒的视频，看完就明白鸟- [GitHub Hovercard](https://github.com/Justineo/github-hovercard) - GitHub 增强工具，悬停可显示对应的用户、仓库、issue 等的详情。- [ReRes](https://chrome.google.com/webstore/detail/reres/gieocpkbblidnocefjakldecahgeeica) - 可以用来更改页面请求响应的内容。通过指定规则，您可以把请求映射到其他的url，也可以映射到本机的文件或者目录。ReRes支持单个url映射，也支持目录映射。补充：1. 翻墙代理的插件偶没使用，偶手机和电脑的翻墙都是配的 ```Surge``` 无脑搞定，不过翻墙代理插件推荐[Proxy SwitchySharp](https://chrome.google.com/webstore/detail/proxy-switchysharp/dpplabbmogkhghncfbfdeeokoefdjegm)，熊掌公司里大多用的都是它2. 日常开发相关的插件就以上这些，还有几款如知乎的插件、购物插件等这类与开发效率不沾边的，俺就不这上头列了哈&lt;h3 id=&quot;git&quot;&gt;Git&lt;/h3&gt;- [Git 教程-廖雪峰](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000) - 俺有看过不少 Git 的文章，确实这个系列是最通俗易懂的- [GitAwards](http://github-awards.com/) - Git 工具，可以查看 Git 排名- [Git 速查](https://github.com/flyhigher139/Git-Cheat-Sheet) - 分类清晰的速查表- [Git 简明指南](http://rogerdudler.github.io/git-guide/index.zh.html) - 入门```Github```的简明指南，木有高深内容:)- [Git 学习资料整理](https://github.com/xirong/my-git) - 内容包括很多 Git 的相关资料，```star 1200+ GitHub 漫游指南 - 一篇还算不错的 Git 学习总结，就是乱了点… 我理解作者_漫游_的意思是漫无目的想到哪写到哪~ 看到作者为鸟达成 Git 连击的成就，也是蛮拼的:) 服务端 如 Ruby、Python、Perl 等相似的服务端语言的学习资源。 _暂无_ 数据端 Mongoose - 让 NodeJS 更容易操作 Mongodb 数据库。 附上一篇Mongoose 学习参考文档 客户端 面对大名鼎鼎的 Electron，我懵逼了。犹豫了一会儿，不知道把其放在哪个分类中，于是我单开了一个 客户端 的类目。 Electron - 如果你想利用 web 技术构建跨平台的桌面程序，那么赶紧来了解 Electron。 设计/交互 作为负责最终效果呈现的前端工程师，多少得了解些 设计和交互 的，这也是为什么 fetool 会单独的存在这一章…当然话又说回来了，偶毕业的第一份工作是设计:) 站酷 - 里面好东西太多，俺当年真没少再上面淘素材 UI中国 - 光听名字就知道有多高大上鸟:) 速查手册 RT，这篇都是些文档或者API，一般这类东西都在大家浏览器的书签内，偶这也列一下大前端常用的手册地址 JavaScript Standard Style - 强烈推荐，尤其适合技术 Leader。优秀的 JS 编码规范是好前端团队的开始 HEAD - 最全的 &lt;head&gt; 列表，真心佩服这种偏执的整理能力 百度CDN公共库 - 基本常见的库都收录拉，搞 demo 的时候特方便 HTML 和 CSS 代码规范 - 编写灵活、稳定、高质量的 HTML 和 CSS 代码的规范 Linux命令中文手册 - 木有系统的好好学习 Linux，所以命令更不熟悉 真羡慕那些CLI玩的飞起的:) Git 速查 - 分类清晰的速查表 jQueryAPI 1.11.3 - ZeptoAPI 基本和 jQuery 一样，所以看一份就好 CSS - CSS 在线参考手册 Redux 中文文档 - 作为个前端，React 还是得尝试下的。英文文档就不给大家推荐了~ Express API - 中文手册:) 4.x和3.x都有 CI用户指南 - 一个轻量级的 PHP 框架用户指南 推荐指数低的原因是劳资PHP比较弱，囧 Yaf - 鸟哥(惠新宸)所写的 PHP 框架 推荐指数低的原因同上… 杂七杂八 放些开发中较有用的杂物在这儿 提問的智慧 - RT，简体版。“當你拋出一個技術問題時，最終是否能得到有用的回答，往往取決於你所提問和追問的方式。本指南將教你如何正確的提問以獲得你滿意的答案。”——摘自原文 租房要点 - 适用于北上广深杭，大城市打拼租房确实是硬伤 QQ 群规 - 突然某天，有个 QQ 群让我加群 原本我是拒绝的，但当我看完这篇 QQ 群规后… 劳资真的被感动到了，太牛逼、够专业！ 最后，我默默加群鸟:) .gitignore 文件 - 介绍不同语言项目的 gitignore 模板 Docsify - 一个轻量级的、支持 Markdown语法的文档生成器。ps：还提供了详细的中文文档哦。 程序员如何优雅的挣零花钱？ - 中肯的文章，如果读完能有些许收获，那么恭喜你 git-draw - 黑魔法，可以修改自己 Git 上的 Contributions GitBook - 写记录的好地方 Codebabes - 学编程的网站。 重点是每通过一个测试，尼玛对应的妞会脱一件衣服… PS：要翻墙哦~ emailframe - 邮件展示确实比较坑，建议有需要的收藏 ReadmeSample - 项目高大上的第一步就是包装，所以来看看 README 的书写套路吧 PS：劳资怎么这么无聊… 前端炫技-炫酷狂拽叼炸天站点 three.js - JavaScript 3D 库。超多的 examples 等着你去发现，你只需要关注内存和风扇就行了 windows93 - 模拟 Win93 桌面，思路、体验和整体效果比较有意思 GeekTyper - 好玩又具有 Geek 精神的网站，虽然创建的目的是个恶作剧 PS：网站需要翻墙 2016.makemepulse.com - 帅哭了。请使用现代浏览器打开 前端技能栈 - 好玩的前端技能栈展示 Mapbox - 非常叼的开源项目，有方便的 JSAPI(还有 SDK)。 不过免费版只能浅尝，流量有限。 PS：网站需要翻墙 mixitup 一款基于 jQuery 的 排序/过滤 的JS库，最关键是有着美妙的动画效果 Clark Duvall - 一枚歪果仁的个人 blog，范儿叼叼的 earth - 全球天气的可视化项目 SuperScrollorama - 好玩好看的动画库，链接是 SuperScrollorama 的展示页 parallax.js - 一个视差引擎的官网，在电脑和手机上都有很好的体验 CSS字母 - 用 CSS 实现英文字母，叼叼的 墨刀 - 一个在线移动应用原型制作工具。 旨在帮助产品经理快速制作可在手机端展示的移动应用原型。","tags":[{"name":"大前端工具集","slug":"大前端工具集","permalink":"http://tawen.github.io/tags/大前端工具集/"}]},{"title":"排序算法","date":"2018-03-27T01:40:05.000Z","path":"2018/03/27/blog20180327/","text":"排序算法排序的稳定性 是指对于相等的元素，排序之后，任然保存2个元素的位置没有变，就是稳定的排序，反之就是不稳定排序。 交换排序算法 冒泡排序 插入排序 选择排序 希尔排序 快排 归并排序 堆排序 线性排序算法 桶排序 交换排序算法排序算法的复杂度由 比较的次数 和 交换的次数 一起决定。 直接选择排序 从未排序的序列中选择最小的元素，与放在第一个位置的元素交换 依次类推，直到全部排序 在a【i,n】中最小的元素和 a[i]交换位置。空间复杂度O(1)，时间复杂度 O(n^2) 冒泡排序 相邻的2各元素比较，大的向后移，经过一轮比较，做大的元素排在最后 第二轮，第二大的元素排倒数第二个位置 直到全部排好 这样，即使是排好序的拿冒泡排序排序，比较的时间复杂度O(n^2) 插入排序 第一个元素算作已经排好 取下一个元素，从已经排好的序列元素中，从后向前扫描 如果排好序的元素大于 新元素，排好序的元素移到下一个位置 重复3，直到直到最后的插入位置 重复2 类似插入扑克牌的效果 最坏的情况： 待排序的是一个逆序排放的数组，这样导致每一轮都要移动元素；此时复杂度是是0(n^2)最好的情况： 待排序的是一已经顺序排放的数字，此时只需要做一轮比较就够了 0（n）。因此可以看到，对大部分数据已经有序这样的数组排序，使用插入排序非常有优势 空间复杂度O（1） 希尔排序递减增量排序算法，对插入排序的改进，实质是分组插入排序，又叫缩小增量排序 先将待排数列分割成若干子序列（增量为m) 对每个子序列使用插入排序 减小增量，再排序 对全体元素做一次插入排序 希尔排序提升排序的奥秘就在于数据元素越有序，使用插入排序效率越高 快速排序递归一次，pivot 左边都比它小，右边都比它大。这是递归，分治的思想。 对 A[p…r] : 分解：A[p..q-1] A[q+1..r],使得 A[p…q-1]&lt;A[q]&lt;A[q+1..r] 解决：递归调用 快排，，对子数组A[p..q-1],A[q+1..r]排序 合并（子问题相互独立的，因此用分治算法就可以了） 具体步骤： 从数列中选择一个元素，作为基准 pivot。通常取分区的第一个或最后一个 重排数列，比 pivot 小得排左边，比pivot大的排右边，相等的随便。 一句话就是挖坑填数 递归的，使用相同的方式，重排左右两边的子序列 扫描过程分2种： 挖坑排序，2头向中间扫描，先从后向前找，再从前向后找。 单向扫描 1234567891011121314151617181920212223242526272829303132333435void quicksort(int *a, int left, int right)&#123; if (left&lt;right)//加上这个，不然有死循环，造成堆栈溢出，这也是递归结束条件 &#123; int i = partion(a,left,right);//使得局部有序，i作为分隔 quicksort(a,left,i-1); quicksort(a,i+1,right); &#125;&#125;// 挖坑填数，2边向中间扫描int partion(int *a, int start,int end)&#123; int i=start,j=end; int tmp = a[i]; // 这里要做越界检查 while(i&lt;j)&#123; // 从后向前扫描，找到第一个小于tmp的值，来填a[i] while(i&lt;j &amp;&amp; a[j]&gt;=tmp)&#123; j--; &#125; if (i&lt;j)//找到了,这时候a[j]为坑 &#123; a[i++] = a[j]; &#125; // 从左向右扫描，找一个大于 tmp的 数， 去填坑a[j] while(i&lt;j &amp;&amp; a[i]&lt;tmp)&#123; i++; &#125; if (i&lt;j) &#123; a[j++]=a[i]; &#125; &#125; //扫描完成后，i==j a[i]=tmp; return i;&#125; 平均复杂度 O(n*logn)最坏O(n^2)空间复杂度 快速排序是对冒泡排序的改进，划分交换排序。 归并排序merge分治算法，必然用到递归 2个有序数组的合并操作是O(n)的复杂度因此我们可以将无序的数组，分成2个子数组分别排序，然后再merge,依次类推 归并排序的步骤: 分解。将一个数组分成n/2个子数组,每个序列2个元素，(2路归并) 解决。 将各个子数组都排好序，然后 merge 2个有序数组 合并 if (length&gt;1) { merge_sort(a,length/2); merge_sort(a+length/2,length-length/2); merge_array(a,length/2,a+length/2,length-length/2); } 堆排序利用堆这种数据结构设计的一种排序算法 先来了解下 堆 结构 堆分小根堆和大根堆 堆： 任一节点小于（或大于）其所有的孩子节点，如果是大于所有孩子节点，这就是一颗大根堆，也就是根节点是堆上的最大值；如果节点小于所有的子节点，这就是一颗小跟堆，也即是根节点是堆上所有节点的最小值。 堆也被称为优先队列堆总是一颗完全树 堆用数组来存储，i节点的父节点就是(i-1)/2,左右子节点小标是 2i+1，2i+2。 堆的操作有： 建堆插入：都是插入到数组最后，然后再调整满足堆次序删除：删除总是发生在 A[0]处，也就是只删除根节点 这样难怪堆被称为 优先队列。插入和删除分别在 数组尾部和头部，只是需要再次调整以满足堆次序。 堆的应用场景有：优先队列 如iOS中的NSOperationQueue 就是维护一个优先队列堆排序 我们来看看如何使用堆 来做排序? 1.将待排序数列看做一颗完全二叉树的存储结构2.堆化数组，结束后，根a[0]变成了最小的值（小根堆）3.取a[0]值，然后对堆做删除操作，此时，堆会重新 堆化数组，a[0]又是下一个最小的值。删除操作通常是先把数组最后的元素提到a[0]位置，然后从根节点开始进行一次从上向下的调整；调整时，先从左右孩子中找最小的交换。如果父节点比每个节点都小就不用调整。（因此，在堆排序是可以直接让 a[0]和数组最后一个元素互换，但要先保存好a[0],或者a[n-1],这样导致了使用堆排序时，递增排序使用大根堆，递减排序使用小根堆。） 循环3，就可以按从小到大的顺序取出所有数组元素。 堆排序主要时间花在建堆期间和堆化数组，找数列中最大树只需要O(1)时间复杂度 void heap_sort(int *a, int length){ // 建立堆 大根堆，递增排序 heap_build(a,length); for (int i = length-1; i &gt;0; --i) { //交换 heap_swop(&amp;a[0],&amp;a[i]); //调整 heap_adjust(a,i); } } 推排序还可以用来求 top-K 大(小)的问题。 接下来，我们看一组排序的动画，你看看能不能猜到他们使用了什么排序算法完成。 答案是： 快排 |归并排序|堆排序选择排序|冒泡排序|希尔排序 国外也有人通过舞蹈的方式编排了几种基本的排序算法，非常有趣。点这里去看看 线性排序算法上面的算法都是基于比较的排序，时间复杂度最好也是 NlogN.而非基于比较的排序，可以突破NlogN的时间下限。当然，非比较的排序，也是需要有一些限定条件的。 桶排序 bucket sort比如给全校学生做个分数排序，最大分100分。我们使用一个100个空间的辅助数据，以key为分数，value为命中的次数。通过O(n)复杂度就可以完成排序任务。这种排序方式就是桶排序。 也就是分配一个hash[100]的空间，初始化为0,遍历一遍，出现的数字就hash[k]++,这样再次遍历一次，就可以得到n个数的顺序了。 ###小结 常见的排序算法都是比较排序，比较排序的时间复杂度通常为 O(n^2) 或 O(nlogn)但是如果带排序的数字有一些特俗性时，我们可以根据这来设计更加优化的排序算法。","tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://tawen.github.io/tags/排序算法/"}]},{"title":"刘姓姓名收集","date":"2018-03-21T01:40:05.000Z","path":"2018/03/21/blog20180321/","text":"明星刘亦菲、刘诗诗、刘思思、刘若英、刘恺威、刘昊然、刘嘉玲、刘晓庆、刘敏涛、刘翔 历史名人刘毅、刘玉娘、刘索拉、刘玉玲、刘邦、刘盈、刘弘、刘恒、刘启、刘彻、刘弗陵、刘洵、刘玄德 自己yy刘腾文、刘思雨、刘启睿、刘斯怡、刘兰祁、刘岚枫 网上收集刘书瑶、刘晨宇、浏览器、刘念 好听名字梦琪、之雅、之桃、慕青、尔岚、初夏、沛菡、傲珊、曼文、乐菱、惜文、香寒、新柔、语蓉、海安、夜蓉、涵柏、水桃、醉蓝、语琴、从彤、傲晴、语兰、又菱、碧彤、元霜、怜梦、紫寒、妙彤、曼易、南莲、紫翠、雨寒、易烟、如萱、若南、寻真、晓亦、向珊、慕灵、以蕊、映易、雪柳、海云、凝天、沛珊、寒云、冰旋、宛儿、绿真、晓霜、碧凡、夏菡、曼香、若烟、半梦、雅绿、冰蓝、灵槐、平安、书翠、翠风、代云、梦曼、幼翠、听寒、梦柏、醉易、访旋、亦玉、凌萱、访卉、怀亦、笑蓝、靖柏、夜蕾、冰夏、梦松、书雪、乐枫、念薇、靖雁、从寒、觅波、静曼、凡旋、以亦、念露、芷蕾、千兰、新波、代真、新蕾、雁玉、冷卉、紫山、千琴、傲芙、盼山、怀蝶、冰兰、山柏、翠萱、问旋、白易、问筠、如霜、半芹、丹珍、冰彤、亦寒、之瑶、冰露、尔珍、谷雪、乐萱、涵菡、海莲、傲蕾、青槐、易梦、惜雪、宛海、之柔、夏青、亦瑶、妙菡、紫蓝、幻柏、元风、冰枫、访蕊、芷蕊、凡蕾、凡柔、安蕾、天荷、含玉、书兰、雅琴、书瑶、从安、夏槐、念芹、代曼、幻珊、谷丝、秋翠、白晴、海露、代荷、含玉、书蕾、听白、灵雁、雪青、乐瑶、含烟、涵双、平蝶、雅蕊、傲之、灵薇、含蕾、从梦、从蓉、初丹。听兰、听蓉、语芙、夏彤、凌瑶、忆翠、幻灵、怜菡、紫南、依珊、妙竹、访烟、怜蕾、映寒、友绿、冰萍、惜霜、凌香、芷蕾、雁卉、迎梦、元柏、代萱、紫真、千青、凌寒、紫安、寒安、怀蕊、秋荷、涵雁、以山、凡梅、盼曼、翠彤、谷冬、冷安、千萍、冰烟、雅阳、友绿、南松、诗云、飞风、寄灵、书芹、幼蓉、以蓝、笑寒、忆寒、秋烟、芷巧、水香、映之、醉波、幻莲、夜山、芷卉、向彤、小玉、幼南、凡梦、尔曼、念波、迎松、青寒、笑天、涵蕾、碧菡、映秋、盼烟、忆山、以寒、寒香、小凡、代亦、梦露、映波、友蕊、寄凡、怜蕾、雁枫、水绿、曼荷、笑珊、寒珊、谷南、慕儿、夏岚、友儿、小萱、紫青、妙菱、冬寒、曼柔、语蝶、青筠、夜安、觅海、问安、晓槐、雅山、访云、翠容、寒凡、晓绿、以菱、冬云、含玉、访枫、含卉、夜白、冷安、灵竹、醉薇、元珊、幻波、盼夏、元瑶、迎曼、水云、访琴、谷波、笑白、妙海、紫霜、凌旋、孤丝、怜寒、凡松、青丝、翠安、如天、凌雪、绮菱、代云、香薇、冬灵、凌珍、沛文、紫槐、幻柏、采文、雪旋、盼海、映梦、安雁、映容、凝阳、访风、天亦、觅风、小霜、雪萍、半雪、山柳、谷雪、靖易、白薇、梦菡、飞绿、如波、又晴、友易、香菱、冬亦、问雁、海冬、秋灵、凝芙、念烟、白山、从灵、尔芙、迎蓉、念寒、翠绿、翠芙、靖儿、妙柏、千凝、小珍、妙旋、雪枫、夏菡、绮琴、雨双、听枫、觅荷、凡之、晓凡、雅彤、孤风、从安、绮彤、之玉、雨珍、幻丝、代梅、青亦、元菱、海瑶、飞槐、听露、梦岚、幻竹、谷云、忆霜、水瑶、慕晴、秋双、雨真、觅珍、丹雪、元枫、思天、如松、妙晴、谷秋、妙松、晓夏、宛筠、碧琴、盼兰、小夏、安容、青曼、千儿、寻双、涵瑶、冷梅、秋柔、思菱、醉波、醉柳、以寒、迎夏、向雪、以丹、依凝、如柏、雁菱、凝竹、宛白、初柔、南蕾、书萱、梦槐、南琴、绿海、沛儿、晓瑶、凝蝶、紫雪、念双、念真、曼寒、凡霜、飞雪、雪兰、雅霜、从蓉、冷雪、靖巧、翠丝、觅翠、凡白、乐蓉、迎波、丹烟、梦旋、书双、念桃、夜天、安筠、觅柔、初南、秋蝶、千易、安露、诗蕊、山雁、友菱、香露、晓兰、白卉、语山、冷珍、秋翠、夏柳、如之、忆南、书易、翠桃、寄瑶、如曼、问柳、幻桃、又菡、醉蝶、亦绿、诗珊、听芹、新之、易巧、念云、晓灵、静枫、夏蓉、如南、幼丝、秋白、冰安、秋白、南风、醉山、初彤、凝海、紫文、凌晴、雅琴、傲安、傲之、初蝶、代芹、诗霜、碧灵、诗柳、夏柳、采白、慕梅、乐安、冬菱、紫安、宛凝、雨雪、易真、安荷、静竹、代柔、丹秋、绮梅、依白、凝荷、幼珊、忆彤、凌青、之桃、芷荷、听荷、代玉、念珍、梦菲、夜春、千秋、白秋、谷菱、飞松、初瑶、惜灵、梦易、新瑶、曼梅、碧曼、友瑶、雨兰、夜柳、芷珍、含芙、夜云、依萱、凝雁、以莲、安南、幼晴、尔琴、飞阳、白凡、沛萍、雪瑶、向卉、采文、乐珍、寒荷、觅双、白桃、安卉、迎曼、盼雁、乐松、涵山、问枫、以柳、含海、翠曼、忆梅、涵柳、海蓝、晓曼、代珊、忆丹、静芙、绮兰、梦安、紫丝、千雁、凝珍、香萱、梦容、冷雁、飞柏、天真、翠琴、寄真、秋荷、代珊、初雪、雅柏、怜容、如风、南露、紫易、冰凡、海雪、语蓉、碧玉、语风、凝梦、从雪、白枫、傲云、白梅、念露、慕凝、雅柔、盼柳、半青、从霜、怀柔、怜晴、夜蓉、代双、以南、若菱、芷文、南晴、梦寒、初翠、灵波、问夏、惜海、亦旋、沛芹、幼萱、白凝、初露、迎海、绮玉、凌香、寻芹、秋柳、尔白、映真、含雁、寒松、寻雪、青烟、问蕊、灵阳、雪巧、丹萱、凡双、孤萍、紫菱、寻凝、傲柏、傲儿、友容、灵枫、尔丝、曼凝、若蕊、问丝、思枫、水卉、问梅、念寒、诗双、翠霜、夜香、寒蕾、凡阳、冷玉、平彤、语薇、幻珊、紫夏、凌波、芷蝶、丹南、之双、凡波、思雁、白莲、从菡、如容、采柳、沛岚、惜儿、夜玉、水儿、半凡、语海、听莲、幻枫、念亍⒈绿凝、冰菱、语蕊、思烟、忆枫、映菱、凌兰、曼岚、若枫、傲薇、凡灵、乐蕊、秋灵、谷槐、觅云","tags":[{"name":"刘姓姓名收集","slug":"刘姓姓名收集","permalink":"http://tawen.github.io/tags/刘姓姓名收集/"}]},{"title":"vue 响应式原理","date":"2018-03-12T01:40:05.000Z","path":"2018/03/12/blog20180312/","text":"关于Vue.jsVue.js是一款MVVM框架，上手快速简单易用，通过响应式在修改数据的时候更新视图。Vue.js的响应式原理依赖于Object.defineProperty，尤大大在Vue.js文档中就已经提到过，这也是Vue.js不支持IE8 以及更低版本浏览器的原因。Vue通过设定对象属性的 setter/getter 方法来监听数据的变化，通过getter进行依赖收集，而每个setter方法就是一个观察者，在数据变更的时候通知订阅者更新视图。 将数据data变成可观察（observable）的那么Vue是如何将所有data下面的所有属性变成可观察的（observable）呢？ 1234567891011121314151617181920212223242526272829303132333435function observer(value, cb) &#123; Object.keys(value).forEach((key) =&gt; defineReactive(value, key, value[key] , cb))&#125;function defineReactive (obj, key, val, cb) &#123; Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: ()=&gt;&#123; /*....依赖收集等....*/ /*Github:https://github.com/answershuto*/ &#125;, set:newVal=&gt; &#123; cb();/*订阅者收到消息的回调*/ &#125; &#125;)&#125;class Vue &#123; constructor(options) &#123; this._data = options.data; observer(this._data, options.render) &#125;&#125;let app = new Vue(&#123; el: '#app', data: &#123; text: 'text', text2: 'text2' &#125;, render()&#123; console.log(\"render\"); &#125;&#125;) 为了便于理解，首先考虑一种最简单的情况，不考虑数组等情况，代码如上所示。在initData中会调用observe这个函数将Vue的数据设置成observable的。当_data数据发生改变的时候就会触发set，对订阅者进行回调（在这里是render）。 那么问题来了，需要对app._data.text操作才会触发set。为了偷懒，我们需要一种方便的方法通过app.text直接设置就能触发set对视图进行重绘。那么就需要用到代理。 代理我们可以在Vue的构造函数constructor中为data执行一个代理proxy。这样我们就把data上面的属性代理到了vm实例上。 123456789101112131415161718_proxy(options.data);/*构造函数中*//*代理*/function _proxy (data) &#123; const that = this; Object.keys(data).forEach(key =&gt; &#123; Object.defineProperty(that, key, &#123; configurable: true, enumerable: true, get: function proxyGetter () &#123; return that._data[key]; &#125;, set: function proxySetter (val) &#123; that._data[key] = val; &#125; &#125;) &#125;);&#125; 我们就可以用app.text代替app._data.text了。","tags":[{"name":"vue 响应式原理","slug":"vue-响应式原理","permalink":"http://tawen.github.io/tags/vue-响应式原理/"}]},{"title":"如何在 Vue.js 中使用第三方库","date":"2018-03-08T01:40:05.000Z","path":"2018/03/08/blog20180308/","text":"在诸多 Vue.js 应用中, Lodash, Moment, Axios, Async等都是一些非常有用的 JavaScript 库. 但随着项目越来越复杂, 可能会采取组件化和模块化的方式来组织代码, 还可能要使应用支持不同环境下的服务端渲染. 除非你找到了一个简单而又健壮的方式来引入这些库供不同的组件和模块使用, 不然, 这些第三方库的管理会给你带来一些麻烦. 全局变量在项目中添加第三方库的最简单方式是讲其作为一个全局变量, 挂载到 window 对象上: entry.js 1window._ = require(&apos;lodash&apos;); MyComponent.vue12345export default &#123; created() &#123; console.log(_.isEmpty() ? &apos;Lodash everywhere!&apos; : &apos;Uh oh..&apos;); &#125;&#125; 这种方式不适合于服务端渲染, 因为服务端没有 window 对象, 是 undefined, 当试图去访问属性时会报错. 在每个文件中引入另一个简单的方式是在每一个需要该库的文件中导入: MyComponent.vue 1234567import _ from &apos;lodash&apos;;export default &#123; created() &#123; console.log(_.isEmpty() ? &apos;Lodash is available here!&apos; : &apos;Uh oh..&apos;); &#125;&#125; 这种方式是允许的, 但是比较繁琐, 并且带来的问题是: 你必须记住在哪些文件引用了该库, 如果项目不再依赖这个库时, 得去找到每一个引用该库的文件并删除该库的引用. 如果构建工具没设置正确, 可能导致该库的多份拷贝被引用. 优雅的方式在 Vuejs 项目中使用 JavaScript 库的一个优雅方式是讲其代理到 Vue 的原型对象上去. 按照这种方式, 我们引入 Moment 库: entry.js 12import moment from &apos;moment&apos;;Object.defineProperty(Vue.prototype, &apos;$moment&apos;, &#123; value: moment &#125;); 由于所有的组件都会从 Vue 的原型对象上继承它们的方法, 因此在所有组件/实例中都可以通过 this.$moment: 的方式访问 Moment 而不需要定义全局变量或者手动的引入. MyNewComponent.vue12345export default &#123; created() &#123; console.log(&apos;The time is &apos; . this.$moment().format(&quot;HH:mm&quot;)); &#125;&#125; 接下来就了解下这种方式的工作原理. Object.defineProperty一般而言, 可以按照下面的方式来给对象设置属性:1Vue.prototype.$moment = moment; 可以这样做, 但是 Object.defineProperty 允许我们通过一个 descriptor 来定义属性. Descriptor 运行我们去设置对象属性的一些底层(low-level)细节, 如是否允许属性可写? 是否允许属性在 for 循环中被遍历. 通常, 我们不会为此感到困扰, 因为大部分时候, 对于属性赋值, 我们不需要考虑这样的细节. 但这有一个明显的优点: 通过 descriptor 创建的属性默认是只读的. 这就意味着, 一些处于迷糊状态的(coffee-deprived)开发者不能在组件内去做一些很愚蠢的事情, 就像这样: 12this.$http = &apos;Assign some random thing to the instance method&apos;;this.$http.get(&apos;/&apos;); // TypeError: this.$http.get is not a function 此外, 试图给只读实例的方法重新赋值会得到 TypeError: Cannot assign to read only property 的错误. $你可能会注意到, 代理第三库的属性会有一个 $ 前缀, 也可能看到其它类似 $refs, $on, $mount 的属性和方式, 它们也有这个前缀. 这个不是强制要求, 给属性添加 $ 前缀是提供那些处于迷糊状态(coffee-deprived)的开发者这是一个公开的 API, 和 Vuejs 的一些内部属性和方法区分开来. this你还可能注意到, 在组件内是通过 this.libraryName 的方式来使用第三方库的, 当你知道它是一个实例方法时就不会感到意外了. 但与全局变量不同, 通过 this 来使用第三方库时, 必须确保 this 处于正确的作用域. 在回调方法中 this 的作用域会有不同, 但箭头式回调风格能保证 this 的作用域是正确的:123456this.$http.get(&apos;/&apos;).then(res =&gt; &#123; if (res.status !== 200) &#123; this.$http.get(&apos;/&apos;) // etc // Only works in a fat arrow callback. &#125;&#125;); 插件如果你想在多个项目中使用同一个库, 或者想将其分享给其他人, 可以将其写成一个插件:12import MyLibraryPlugin from &apos;my-library-plugin&apos;;Vue.use(MyLibraryPlugin); 在应用的入口引入插件之后, 就可以在任何一个组件内像使用 Vue Router, Vuex 一样使用你定义的库了. 写一个插件首先, 创建一个文件用于编写自己的插件. 在示例中, 我会将 Axios 作为插件添加到项目中, 因而我给文件起名为 axios.js. 其次, 插件要对外暴露一个 install 方法, 该方法的第一个参数是 Vue 的构造函数: axios.js 12345export default &#123; install: function(Vue) &#123; // Do stuff &#125;&#125; 可以使用先前将库添加到原型对象上的方法: axios.js1234567import axios from &apos;axios&apos;;export default &#123; install: function(Vue,) &#123; Object.defineProperty(Vue.prototype, &apos;$http&apos;, &#123; value: axios &#125;); &#125;&#125; 最后, 利用 Vue 的实例方法 use 将插件添加到项目中: entry.js12345678import AxiosPlugin from &apos;./axios.js&apos;;Vue.use(AxiosPlugin);new Vue(&#123; created() &#123; console.log(this.$http ? &apos;Axios works!&apos; : &apos;Uh oh..&apos;); &#125;&#125;) 彩蛋: 插件的可选参数插件的 install 方法可以接受可选参数. 一些开发可能不喜欢将 Axios 实例命名为 $http, 因为这是 Vue Resource 提供的一个通用名字. 因而可以提供一个可选的参数允许他们随意命名: axions.js1234567import axios from &apos;axios&apos;;export default &#123; install: function(Vue, name = &apos;$http&apos;) &#123; Object.defineProperty(Vue.prototype, name, &#123; value: axios &#125;); &#125;&#125; entry.js12345678import AxiosPlugin from &apos;./axios.js&apos;;Vue.use(AxiosPlugin, &apos;$axios&apos;);new Vue(&#123; created() &#123; console.log(this.$axios ? &apos;Axios works!&apos; : &apos;Uh oh..&apos;); &#125;&#125;)","tags":[{"name":"如何在 Vue.js 中使用第三方库 ","slug":"如何在-Vue-js-中使用第三方库","permalink":"http://tawen.github.io/tags/如何在-Vue-js-中使用第三方库/"}]},{"title":"BAT脚本编写教程简单入门篇","date":"2018-01-17T06:02:05.000Z","path":"2018/01/17/blog20180126/","text":"批处理文件最常用的几个命令：echo表示显示此命令后的字符echo on 表示在此语句后所有运行的命令都显示命令行本身echo off 表示在此语句后所有运行的命令都不显示命令行本身@与echo off相像，但它是加在每个命令行的最前面，表示运行时不显示这一行的命令行（只能影响当前行）。call 调用另一个批处理文件（如果不用call而直接调用别的批处理文件，那么执行完那个批处理文件后将无法返回当前文件并执行当前文件的后续命令）。pause 运行此句会暂停批处理的执行并在屏幕上显示Press any key to continue…的提示，等待用户按任意键后继续rem 表示此命令后的字符为注释，不执行。title BAT的标题cls 清除屏幕 1234567891011TITLE BAT脚本例子1 echo -----------枚举C盘目录下所有文件----------- echo= echo= dir c:\\*.* rem 输出到文本文件 dir c:\\*.* &gt; example1.txt echo= echo= echo -------------------------------------------- PAUSE echo= 表示输出空白行，关于空白行的输出还有其他方式，具体可参考网址：http://blog.sina.com.cn/s/blog_4b466ad00101dfqu.html若输入PAUSE&gt;NUL 则表示暂停且不提示“按下任意键继续 设置字体颜色和窗体大小：设置字体颜色：COLOR 02 （0代表背景色，2代表前景色）常用的颜色有以下值：0 黑色，1蓝色，2 绿色，3 浅绿色，4红色，5紫色，6黄色，7白色，8灰色，9浅蓝，A浅绿，B浅蓝色，C浅红色，D浅紫色，E浅黄色，F亮白色）。设置窗体大小：MODE CON: COLS=宽度 LINES=高度 文件夹简单操作：12345678910111213141516171819202122232425TITLE BAT脚本例子2 COLOR A echo -----------BAT脚本例子2----------- echo= echo= echo 当前工作路径为：%cd% rem 输出文件目录的树形目录 TREE /f &gt;tree_list.txt rem CD切换不同盘符时候需要加上/d CD /D C:\\ echo 当前工作路径为：%cd% DIR rem 创建目录bat_example2 MD bat_example2 DIR rem 拷贝目录 /s /e /y 说明：在复制文件的同时也复制空目录或子目录，如果目标路径已经有相同文件了，使用覆盖方式而不进行提示 Xcopy C:\\bat_example2 D:\\bat_example2 /s /e /y rem 删除目录bat_example2 rem RD /Q /S bat_example2 rem DIR echo= echo= echo -------------------------------------------- PAUSE 关于文件夹的其他操作，可参考网址：http://www.jb51.net/article/11313.htm 文件操作123456789101112131415161718192021TITLE BAT脚本例子3 COLOR A echo -----------BAT脚本例子3----------- echo= echo= TYPE tree_list1.txt rem 复制（合并）文件 /Y 表示目标路径存在该文件则不提示直接覆盖 COPY /Y tree_list2.txt + tree_list3.txt C:\\ DEL tree_list4.txt /f /s /q /a rem /f 表示强制删除文件 rem /s表示子目录都要删除该文件 rem /q表示无声，不提示 rem /a根据属性选择要删除的文件 rem 需要特别注意的是：move不能跨分区移动文件夹 MOVE example3 example3_1 echo= echo= echo -------------------------------------------- PAUSE 网络命令123456789101112131415@ECHO OFF TITLE BAT脚本例子4 COLOR A echo -----------BAT脚本例子4----------- echo= PING www.baidu.com echo= echo ----------------------------------- IPCONFIG echo= echo ----------------------------------- ARP echo= echo ----------------------------------- PAUSE 系统相关12345678910111213@ECHO OFF TITLE BAT脚本例子5 COLOR A echo -----------BAT脚本例子5----------- echo= echo -----------显示计算机用户----------- NET USER echo= echo -----------显示进程列表----------- TASKLIST echo= echo ----------------------------------- PAUSE 最后总结，其实BAT主要是运用DOS命令，所以只要掌握好DOS命令，使用BAT就轻松多了。当然，BAT实际运用并不只是这些简单的命令，还有比较复杂的语法，将在下一篇做介绍。 参考网址：http://www.jb51.net/article/49627.htm","tags":[{"name":".bat","slug":"bat","permalink":"http://tawen.github.io/tags/bat/"}]},{"title":"揭秘react生态体系","date":"2018-01-17T06:02:05.000Z","path":"2018/01/17/blog20180119/","text":"前言react 的生态体系比较庞大，它在web端，移动端，服务器端，VR领域都有涉及。 react可以说是目前为止最热门，生态最完善，应用范围最广的前端框架。react结合它的整个生态，它可以横跨web端，移动端，服务器端，乃至VR领域。 可以毫不夸张地说，react已不单纯是一个框架，而是一个行业解决方案。 下面就来说说 react庞大生态体系的构成。 一，react生态之——web端react本身是面向web端的，它很轻便灵活，只是MVC架构中的view(视图)层。由于只是view层，所以它需要配合生态体系中的其他框架或模块来使用。 react的web生态构成1，路由react的路由解决方案有多个，这里只提用的最多，也最为推荐的react-router。现已更新到v4.1版本。另外，推荐使用react-router-redux和react-router搭配使用，可保持路由器与应用程序状态同步。 2，状态管理器react只是UI层，对于如何管理应用的状态，facebook提出了flux架构，而基于这一架构，react生态陆续出现了redux、refluxjs、mobx、react-redux 等一系列状态管理框架。 其中redux、mobx是无疑是最受欢迎的两个。但它们的应用场景则大不相同。Mobx 适合做一些简单的应用，原型实验，适合小的团队使用。Mobx 的优点是响应状态的变化。 redux适合复杂的应用，大团队，需求变化多。它的优点是响应动作和事件。redux不仅应用于react，也可以应用于angular，vue等框架，只是redux和react配合使用最为契合。 另外国内蚂蚁金服前端团队基于redux, react-router打造了另一个前端框架——dva。dva简单来讲是对redux方案的集成与拓展，它突破框架的本身，形成一套略为完整的前端架构，处理了很多包括项目构建，异步处理、统一请求、统一错误处理等一系列诸多问题。 如果你选择redux方案，那么建议直接使用dva。3，UI库和vue,angular相比，react的UI库无疑是最为丰富的，且十分优秀。目前react的UI库有将近二十多个，这里主要列举最为优秀的几个。 首先国外的有material-ui、react-toolbox。它们都基于谷歌的material设计理念，因此界面非常精美，尤其适用于web开发。 其次是国内蚂蚁金服开源的ant design，以及百分点公司开源的bfd-ui。这两个都是企业级的UI库，提供的组件极其丰富，此外逻辑交互也处理得非常好，基本不需要你操作过多的业务逻辑即可完成开发。 而在这众多的UI库中，表现最为出色的莫过于蚂蚁金服开源的ant design。 4, 一些工具Immutableimmutable-js是facebook推出的完全独立的一个js库，侧重函数式编程中不可变数据结构，使用Immutable可使你的react应用性能上会有很大的提升。 draft-js——基于react的编辑器语言draft-js 是由facebook开源的编辑器语言。它提供了众多API可用于定制化开发你想要的react编辑器。 css-modules ——css模块化解决方案css-modules不是为react而生的，它是css模块化的一种解决方案，但它和react配合使用非常的契合。css的发展，已从最原始的css,到后来的less/sass，再到postcss，以及css in js，再到css-modules。无一不是向着模块化进发，甚至于有没有可能发展到组件化style，还有待实践和考察。 React Devtools——react调试工具react-devtools是facebook推出的一款调试工具。可有助于提高你的react应用开发效率。 Babel——es6/7开发react应用，推荐使用babel搭建es6/7开发环境。这样你就可以尽情地使用高逼格兼高效率、高体验的es6/7语法了。无论是react，还是redux，还是Immutable等等，甚至是不相关的rx.js，都强调函数式编程。说句题外话，整个react体系，都在强调js，甚至连css(css-modules)、html(jsx)都融入了js处理，所以提高你的js驾驭能力可使你在前端路上不会迷失。 TypeScriptTypeScript是微软开源的JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持。而TypeScript也因此成为了angular的一个制胜关键点。那react能否使用呢？当然是可以的。蚂蚁金服所开源的React UI库ant design就是使用TypeScript来开发的。由此可知其强大。顺便提供几个TypeScript的学习教程: 官方文档、简易中文版、中文版教程 5，react项目构建前端构建工具有很多种，比如最为流行的webpack、百度开源的fis3、以及 gulp。而开发react应用，推荐使用强大的webpack做项目构建。这也是官方的推荐。 react的web技术栈的选择通过上面可以了解到，react的web技术栈非常的丰富，搭配不同的路由、状态管理器、UI库，构建工具等不同的组合，可整理出二十几种技术栈方案。 下面来说说根据不同应用场景，最为推荐的几种技术栈方案。 1，开发后台应用 react+react-router+mobx+webpack+bfd-ui/ant design （三星半）react+react-router+redux+webpack+bfd-ui （三星）react+react-router+redux+webpack+ant design （四星）react+dva+bfd-ui （四星半）react+dva+ant design （五星）2，开发前台web应用 react+dva+bfd-ui/ant design （四星）react+dva+material-ui/react-toolbox （四星半） 二，react生态之——移动端react不仅在web端占据主流的位置，同时在移动端表现尤为突出。这里不得不提到RN，也就是react-native。 react-native是目前最优秀的非原生开发移动框架，一处开发，多端使用。同时具有出色的性能，支持热更新等超强的优势，使得react-native顿时站在风口浪尖。 vue和angular在移动端同样有建树，分别是weex和ionic+cordova。然其综合性价比仍不如react-native。 而最近facebook推出React Fiber 架构,使用Fiber对react核心算法进行重写，届时RN的性能将会再次直线式的上升，向原生步步紧逼。 开发RN应用所用的技术栈与web端大致相同，同样需要结合redux,react-router, dva, mobx等周边生态来使用。 另外也有一些适合RN的移动端UI库。比如ant design的mobile版——ant-design-mobile，以及响应式的material-ui。 三，react生态之——服务器端react不仅涉足web端，移动端，同样在服务器端也有非常好的涉猎。react在服务器端的实践有两部分，一个是服务器端渲染，另一个就是强大的graphql。 react服务器端渲染react提供了两个API来实现服务器端渲染，分别是——renderToString 和 renderToStaticMarkup。 而对于react服务器端渲染实践最为出色的莫过于next.js。这是一个基于react可实现服务器和浏览器都能渲染的框架。 除了next.js，还有一个比较出色的案例 ——react-server。它同样实现 了React 框架在服务器和浏览器中进行快速渲染和无缝切换。 除了以上这两个服务器端渲染的框架外，还有一些比较好用的实现react服务器端渲染模块，比如如express-react-views，react-view等等。 GraphQL——超前，另类的APIgraphql是facebook开源的应用层查询语言。它很超前，时髦，可适用于包括nodejs，java,php等绝大都数后台语言。 它超前到什么程度？举个例子，我们只需要使用一个 GraphQL 的接口，即可满足一个简单博客网站的所有需求。有没有觉得很神奇？准确地说graphql是为接替RESTful而生的。 RESTful是当下非常流行的，主流的一套前后端API交互设计规范。几乎绝大都数互联网公司都在使用。那么为什么还需要graphql来接替RESTful呢？ 其实，现在谈graphql替代RESTful还为时尚早，因为graphql还有很多问题需要解决，而即使真到了那一天，RESTful也仍有一定的市场空间。 RESTful本身存在的一些缺点和不足，比如，当需求或数据发生变化时，需要建立新的接口来适应变化，而不断添加的接口，会造成服务器代码的不断增长，即使通过增加接口版本，也并不能够完全限制服务器代码的增长。另外不断地增加接口，意味着将带来更多的开发工作，而且每个接口基本都无法复用等一系列问题。 graphql就是为解决这些问题而生的。下面来看看一个简单的GraphQL请求: 12345678910111213141516&#123; latestPost &#123; _id, title, content, author &#123; name &#125;, comments &#123; content, author &#123; name &#125; &#125; &#125;&#125; 而请求的结果是这样: 1234567891011121314151617181920212223242526&#123; &quot;data&quot;: &#123; &quot;latestPost&quot;: &#123; &quot;_id&quot;: &quot;03390abb5570ce03ae524397d215713b&quot;, &quot;title&quot;: &quot;New Feature: Tracking Error Status with Kadira&quot;, &quot;content&quot;: &quot;Here is a common feedback we received from our users ...&quot;, &quot;author&quot;: &#123; &quot;name&quot;: &quot;Pahan Sarathchandra&quot; &#125;, &quot;comments&quot;: [ &#123; &quot;content&quot;: &quot;This is a very good blog post&quot;, &quot;author&quot;: &#123; &quot;name&quot;: &quot;Arunoda Susiripala&quot; &#125; &#125;, &#123; &quot;content&quot;: &quot;Keep up the good work&quot;, &quot;author&quot;: &#123; &quot;name&quot;: &quot;Kasun Indi&quot; &#125; &#125; ] &#125; &#125;&#125; 很明显，GraphQL是从客户端业务维度出发的，当客户端需要某些字段的数据时，只需要发出这些字段的GraphQL请求即可。按需索取，可复用，可定制化，灵活性很强。 这会不会就是未来前后端交互的一种趋势呢？我们拭目以待。 Relay 和 Apollo Client上面已经有讲到， relay是facebook出品的一个前端数据框架。 我们使用graphql，为什么需要用到 relay呢？ 首先，graphql是在后端实现的，准确地说是在后端搭起一个graphql服务器，它不会主动推送数据给客户端，也无法像RESTful那样由客户端发起一个ajax请求来请求后端的RESTful API。graphql需要在客户端有一样东西能与它进行交互，但不是ajax或者fetch，而是经过封装的如relay或apollo等能够与graphql服务器进行交互的前端数据框架。 relay就是这样应运而生。但实践中会发现使用relay来配合graphql使用通常会遇到很多坑，relay操作起来并没有想象中的简单，除了比较复杂以外，它同时存在很多局限性。 于是，不得不提到apollo。它是一个全功能的 GraphQL 客户端，用于 React 、Angular 等的交互，允许你轻松通过 GraphQL 获取数据并构建 UI 组件。 使用apollo+graphql，它并没有relay那样的繁琐，也没有relay那样的局限性。无疑和graphql是最配的。 关于graphql的体验，很多用过的人表示，爱不释手。 下面是一些关于graphql的比较好的文章和资料: graphql官方文档Apollo Client官方文档relay官方文档graphql学习资料收集Node.js 服务端实践之 GraphQL 初探深入理解 GraphQL 四，react生态之——VR领域目前，VR(虚拟现实)是科技界的新生事物，也是一大革命，在未来，VR将很大程度地改变人类的生活方式。 试想一下，VR将为你呈现一个虚拟现实世界，你将可以使用VR身临其境般地玩游戏，看新闻，购物，社交娱乐，看世界名景等等，这将是一个全新的世界。 那么，react难道有涉足VR领域吗？ 是的，没错。 react不仅走在web端、移动端以及服务器端的前沿，还很超前地在VR领域布了个局——react-vr。 react-vr——webvr框架 不得不说facebook是一家技术含量很高，着眼长远的科技巨头。 下面主要讲讲webVR。 webVR是VR技术在浏览器的实现。 目前VR的技术实现方案仍在起草阶段，但有些技术方案几乎是铁定的。比如作为如底层的OpenGL、WebGL、three.js。 而目前就有一些基于底层技术开发出来的webVR框架，比如——react-vr和aframe。 aframe是由mozilla于15年开源的，目前已更新到0.5.0版本。 react-vr 于2017年4月18日举行的facebook F8开发者大会上正式发布，并在github放出了第一个开源版本—— react-vr。并号称——使用react即可创造出惊人的360°景象和VR应用。 react始终是走在web巅峰的路上。 以下是参考资料： aframe官方文档react-vr官方文档three.js官方文档 五，react生态之——全平台的reactxpreactxp是微软Skype团队开源的一个基于react和react native开发的全平台框架，它不仅支持Android和iOS，还支持web和windows，目前还尚不支持mac。是眼下跨平台最广的一个框架，准确来说是一个js库。 reactxp的出现算是微软在wp跨平台计划失败后的又一次跨平台实践。是否也预示着前端终将会实现大一统呢？拭目以待。 reactxp目前还很嫩，还有很多问题需要解决，比如它的某些API只有ios能用，并不能做到全兼容，像浏览器一样存在兼容性问题，这只是其一。 reactxp真正要火起来还有很长的路要走，但不妨碍我们可以继续关注它。也许它能超越RN，成为最前沿的跨平台应用框架也说不定。 总结react早已不是一个单纯的库，结合它庞大的生态体系，它已然发展成为一个行业解决方案，它所渗透的领域非常广，也非常的前沿，很具有代表性。 通过本文，相信你对react的生态体系有了一个直观的了解。","tags":[{"name":"揭秘react生态体系","slug":"揭秘react生态体系","permalink":"http://tawen.github.io/tags/揭秘react生态体系/"}]},{"title":"SASS用法指南","date":"2018-01-17T06:02:05.000Z","path":"2018/01/17/blog20180117/","text":"一、什么是SASSSASS是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。本文总结了SASS的主要用法。我的目标是，有了这篇文章，日常的一般使用就不需要去看官方文档了。 二、安装和使用2.1 安装SASS是Ruby语言写的，但是两者的语法没有关系。不懂Ruby，照样使用。只是必须先安装Ruby，然后再安装SASS。假定你已经安装好了Ruby，接着在命令行输入下面的命令： 1gem install sass 然后，就可以使用了。 2.2 使用SASS文件就是普通的文本文件，里面可以直接使用CSS语法。文件后缀名是.scss，意思为Sassy CSS。下面的命令，可以在屏幕上显示.scss文件转化的css代码。（假设文件名为test。）1 sass test.scss 如果要将显示结果保存成文件，后面再跟一个.css文件名。1 sass test.scss test.css SASS提供四个编译风格的选项：1234 * nested：嵌套缩进的css代码，它是默认值。 * expanded：没有缩进的、扩展的css代码。 * compact：简洁格式的css代码。 * compressed：压缩后的css代码。 生产环境当中，一般使用最后一个选项。1 sass --style compressed test.sass test.css 你也可以让SASS监听某个文件或目录，一旦源文件有变动，就自动生成编译后的版本。1234 // watch a file sass --watch input.scss:output.css // watch a directory sass --watch app/sass:public/stylesheets SASS的官方网站，提供了一个在线转换器。你可以在那里，试运行下面的各种例子。 三、基本用法3.1 变量SASS允许使用变量，所有变量以$开头。1234$blue : #1875e7; div &#123; color : $blue; &#125; 如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。1234 $side : left; .rounded &#123; border-#&#123;$side&#125;-radius: 5px; &#125; 3.2 计算功能SASS允许在代码中使用算式：12345 body &#123; margin: (14px/2); top: 50px + 100px; right: $var * 10%; &#125; 3.3 嵌套SASS允许选择器嵌套。比如，下面的CSS代码：123div h1 &#123; color : red; &#125; 可以写成：12345 div &#123; hi &#123; color:red; &#125; &#125; 属性也可以嵌套，比如border-color属性，可以写成：12345 p &#123; border: &#123; color: red; &#125; &#125; 注意，border后面必须加上冒号。在嵌套的代码块内，可以使用&amp;引用父元素。比如a:hover伪类，可以写成： 123 a &#123; &amp;:hover &#123; color: #ffb3ff; &#125; &#125; 3.4 注释SASS共有两种注释风格。标准的CSS注释 / comment / ，会保留到编译后的文件。单行注释 // comment，只保留在SASS源文件中，编译后被省略。在/*后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。123/*! 重要注释！ */ 四、代码的重用4.1 继承SASS允许一个选择器，继承另一个选择器。比如，现有class1：123 .class1 &#123; border: 1px solid #ddd; &#125; class2要继承class1，就要使用@extend命令：1234 .class2 &#123; @extend .class1; font-size:120%; &#125; 4.2 MixinMixin有点像C语言的宏（macro），是可以重用的代码块。使用@mixin命令，定义一个代码块。1234 @mixin left &#123; float: left; margin-left: 10px; &#125; 使用@include命令，调用这个mixin。123 div &#123; @include left; &#125; mixin的强大之处，在于可以指定参数和缺省值。1234 @mixin left($value: 10px) &#123; float: left; margin-right: $value; &#125; 使用的时候，根据需要加入参数：123 div &#123; @include left(20px); &#125; 下面是一个mixin的实例，用来生成浏览器前缀。12345 @mixin rounded($vert, $horz, $radius: 10px) &#123; border-#&#123;$vert&#125;-#&#123;$horz&#125;-radius: $radius; -moz-border-radius-#&#123;$vert&#125;#&#123;$horz&#125;: $radius; -webkit-border-#&#123;$vert&#125;-#&#123;$horz&#125;-radius: $radius; &#125; 使用的时候，可以像下面这样调用：12 #navbar li &#123; @include rounded(top, left); &#125; #footer &#123; @include rounded(top, left, 5px); &#125; 4.3 颜色函数SASS提供了一些内置的颜色函数，以便生成系列颜色。1234 lighten(#cc3, 10%) // #d6d65c darken(#cc3, 10%) // #a3a329 grayscale(#cc3) // #808080 complement(#cc3) // #33c 4.4 插入文件@import命令，用来插入外部文件。1 @import &quot;path/filename.scss&quot;; 如果插入的是.css文件，则等同于css的import命令。123456 @import &quot;foo.css&quot;;``` ## 五、高级用法### 5.1 条件语句@if可以用来判断： p { @if 1 + 1 == 2 { border: 1px solid; } @if 5 &lt; 3 { border: 2px dotted; } }1配套的还有@else命令： @if lightness($color) &gt; 30% { background-color: #000; } @else { background-color: #fff; }12### 5.2 循环语句SASS支持for循环： @for $i from 1 to 10 { .border-#{$i} { border: #{$i}px solid blue; } }12也支持while循环： $i: 6; @while $i &gt; 0 { .item-#{$i} { width: 2em * $i; } $i: $i - 2; }1each命令，作用与for类似： @each $member in a, b, c, d { .#{$member} { background-image: url(“/image/#{$member}.jpg”); } }12### 5.3 自定义函数SASS允许用户编写自己的函数。 @function double($n) { @return $n * 2; } #sidebar { width: double(5px); }`","tags":[{"name":"SASS","slug":"SASS","permalink":"http://tawen.github.io/tags/SASS/"}]},{"title":"Will be married","date":"2018-01-15T06:02:05.000Z","path":"2018/01/15/blog20180115/","text":"30年的单身生活就要划算句号了，迎接我新的人生阶段。特此亲手做个视频当做自己送给另一半的礼物。让我们一起成长、一起经历、一起迎接手牵手新的人生阶段！ 时间：2018年2月20日（阴历初五）中午地点：霍山县新徽大酒店 效果预览： 您的浏览器不支持 video 标签。","tags":[{"name":"Will be married","slug":"Will-be-married","permalink":"http://tawen.github.io/tags/Will-be-married/"}]},{"title":"天津市津南区图书馆","date":"2018-01-12T07:21:05.000Z","path":"2018/01/12/blog20180112/","text":"技术站：vue、vue-router、vuex、webpack；基于微信扫一扫页面： 扫描预览：","tags":[{"name":"天津市津南区图书馆","slug":"天津市津南区图书馆","permalink":"http://tawen.github.io/tags/天津市津南区图书馆/"}]},{"title":"yarn与npm的命令行小结","date":"2017-12-29T01:44:05.000Z","path":"2017/12/29/blog20171229/","text":"一、首先需要了解的命令npm install === yarn —— install 安装是默认行为。 npm install taco --save === yarn add taco —— taco 包立即被保存到 package.json 中。 npm uninstall taco --save === yarn remove taco 在 npm 中，可以使用 npm config set save true 设置 — -save 为默认行为，但这对多数开发者而言并非显而易见的。在 yarn 中，在package.json 中添加（add）和移除（remove）等行为是默认的。 npm install taco –save-dev === yarn add taco –dev npm update –save === yarn upgradeupdate（更新） vs upgrade（升级）， 赞！upgrade 才是实际做的事！版本号提升时，发生的正是upgrade！ 注意： npm update –save 在版本 3.11 中似乎有点问题。 npm install taco@latest –save === yarn add taco npm install taco –global === yarn global add taco —— 一如既往，请谨慎使用 global 标记。 二、已知悉的命令包和 npm registry 上是一样的。大致而言，Yarn 只是一个新的安装工具，npm 结构和 registry 还是一样的。 npm init === yarn init npm link === yarn link npm outdated === yarn outdated npm publish === yarn publish npm run === yarn run npm cache clean === yarn cache clean npm login === yarn login (logout 同理) npm test === yarn test 三、Yarn 独有的命令我跳过了一些提醒我们不要使用的内容，如 yarn clean。 yarn licenses ls —— 允许你检查依赖的许可信息。 yarn licenses generate —— 自动创建依赖免责声明 license。 yarn why taco —— 检查为什么会安装 taco，详细列出依赖它的其他包（鸣谢 Olivier Combe）。 Emojis 速度 通过 yarn lockfile 自动实现 shrinkwrap 功能 以安全为中心的设计 四、Npm 独有的命令npm xmas === NO EQUIVALENT npm visnup === NO EQUIVALENT 总结在写这篇文章的时候发现， yarn的run 命令似乎出了点问题，应该会在0.15.2中修复。在这一点上， npm 好多了。以上就是这篇文章的全部内容了，希望本文的内容对大家的学习或者工作能带来一定的帮助，如果有疑问大家可以留言交流。","tags":[{"name":"yarn与npm的命令行小结","slug":"yarn与npm的命令行小结","permalink":"http://tawen.github.io/tags/yarn与npm的命令行小结/"}]},{"title":"第一行 Android 代码阅读笔记","date":"2017-12-28T01:44:05.000Z","path":"2017/12/28/blog20171228/","text":"第一行 Android 代码阅读笔记 四大组件Android系统四大组件分别是活动（Activity）、服务（Service）、广播接收器（BroadcastReceiver）和内容提供器（ContentProvider）。其中活动是所有 Android 应用程序的门面，凡是在应用中你看得到的东西，都是放在活动中的。而服务就比较低调了，你无法看到它，但它会一直在后台默默地运行，即使用户退出了应用，服务仍然是可以继续运行的。广播接收器可以允许你的应用接收来自各处的广播消息，比如电话、短信等，当然你的应用同样也可以向外发出广播消息。内容提供器则为应用程序之间共享数据提供了可 能，比如你想要读取系统电话簿中的联系人，就需要通过内容提供器来实现。ADT 全称 Android Development Tools 知道了 res 目录下每个文件夹的含义，我们再来看一下如何去使用这些资源吧。比如刚刚在 strings.xml 中找到的 Hello world!字符串，我们有两种方式可以引用它： 在代码中通过 R.string.hello_world 可以获得该字符串的引用； 在 XML 中通过@string/hello_world 可以获得该字符串的引用； 你可能会对@+id/button_1 这种语法感到陌生，但如果把加号去掉，变成@id/button_1，这你就会觉得有些熟悉了吧，这不就是在 XML 中引用资源的语法吗，只不过是把 string 替换成了 id。是的，如果你需要在 XML 中引用一个 id，就使用@id/id_name 这种语法，而如果你需要在 XML 中定义一个 id，则要使用@+id/id_name 这种语法。 equestWindowFeature(Window.FEATURE_NO_TITLE)的意思就是不在活动中显示标题栏，注意这句代码一定要在 setContentView()之前执行，不然会报错。 Intent 是 Android 程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据。Intent 一般可被用于启动活动、启动服务、以及发送广播等场景，由于服务、广播等概念你暂时还未涉及，那么本章我们的目光无疑就锁定在了启动活动上面。","tags":[{"name":"第一行 Android 代码","slug":"第一行-Android-代码","permalink":"http://tawen.github.io/tags/第一行-Android-代码/"}]},{"title":"Immutable 详解及 React 中实践","date":"2017-12-22T01:44:05.000Z","path":"2017/12/22/blog20171222/","text":"Shared mutable state is the root of all evil（共享的可变状态是万恶之源）– Pete Hunt有人说 Immutable 可以给 React 应用带来数十倍的提升，也有人说 Immutable 的引入是近期 JavaScript 中伟大的发明，因为同期 React 太火，它的光芒被掩盖了。这些至少说明 Immutable 是很有价值的，下面我们来一探究竟。 JavaScript 中的对象一般是可变的（Mutable），因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。如 foo={a: 1}; bar=foo; bar.a=2 你会发现此时 foo.a 也被改成了 2。虽然这样做可以节约内存，但当应用复杂后，这就造成了非常大的隐患，Mutable 带来的优点变得得不偿失。为了解决这个问题，一般的做法是使用 shallowCopy（浅拷贝）或 deepCopy（深拷贝）来避免被修改，但这样做造成了 CPU 和内存的浪费。 Immutable 可以很好地解决这些问题。 什么是 Immutable DataImmutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。请看下面动画： 目前流行的 Immutable 库有两个： immutable.jsFacebook 工程师 Lee Byron 花费 3 年时间打造，与 React 同期出现，但没有被默认放到 React 工具集里（React 提供了简化的 Helper）。它内部实现了一套完整的 Persistent Data Structure，还有很多易用的数据类型。像 Collection、List、Map、Set、Record、Seq。有非常全面的map、filter、groupBy、reducefind函数式操作方法。同时 API 也尽量与 Object 或 Array 类似。 其中有 3 种最重要的数据结构说明一下：（Java 程序员应该最熟悉了） Map：键值对集合，对应于 Object，ES6 也有专门的 Map 对象List：有序可重复的列表，对应于 ArraySet：无序且不可重复的列表 seamless-immutable与 Immutable.js 学院派的风格不同，seamless-immutable 并没有实现完整的 Persistent Data Structure，而是使用 Object.defineProperty（因此只能在 IE9 及以上使用）扩展了 JavaScript 的 Array 和 Object 对象来实现，只支持 Array 和 Object 两种数据类型，API 基于与 Array 和 Object 操持不变。代码库非常小，压缩后下载只有 2K。而 Immutable.js 压缩后下载有 16K。 下面上代码来感受一下两者的不同： 1234567891011121314151617181920// 原来的写法let foo = &#123;a: &#123;b: 1&#125;&#125;;let bar = foo;bar.a.b = 2;console.log(foo.a.b); // 打印 2console.log(foo === bar); // 打印 true// 使用 immutable.js 后import Immutable from &apos;immutable&apos;;foo = Immutable.fromJS(&#123;a: &#123;b: 1&#125;&#125;);bar = foo.setIn([&apos;a&apos;, &apos;b&apos;], 2); // 使用 setIn 赋值console.log(foo.getIn([&apos;a&apos;, &apos;b&apos;])); // 使用 getIn 取值，打印 1console.log(foo === bar); // 打印 false// 使用 seamless-immutable.js 后import SImmutable from &apos;seamless-immutable&apos;;foo = SImmutable(&#123;a: &#123;b: 1&#125;&#125;)bar = foo.merge(&#123;a: &#123; b: 2&#125;&#125;) // 使用 merge 赋值console.log(foo.a.b); // 像原生 Object 一样取值，打印 1console.log(foo === bar); // 打印 false Immutable 优点 Immutable 降低了 Mutable 带来的复杂度 可变（Mutable）数据耦合了 Time 和 Value 的概念，造成了数据很难被回溯。 比如下面一段代码：12345function touchAndLog(touchFn) &#123; let data = &#123; key: &apos;value&apos; &#125;; touchFn(data); console.log(data.key); // 猜猜会打印什么？&#125; 在不查看 touchFn 的代码的情况下，因为不确定它对 data 做了什么，你是不可能知道会打印什么（这不是废话吗）。但如果 data 是 Immutable 的呢，你可以很肯定的知道打印的是 value。 节省内存 Immutable.js 使用了 Structure Sharing 会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收。123456789import &#123; Map&#125; from &apos;immutable&apos;;let a = Map(&#123; select: &apos;users&apos;, filter: Map(&#123; name: &apos;Cam&apos; &#125;)&#125;)let b = a.set(&apos;select&apos;, &apos;people&apos;);a === b; // falsea.get(&apos;filter&apos;) === b.get(&apos;filter&apos;); // true 上面 a 和 b 共享了没有变化的 filter 节点。 Undo/Redo，Copy/Paste，甚至时间旅行这些功能做起来小菜一碟 因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能。 后面我会提供 Flux 做 Undo 的示例。 并发安全 传统的并发非常难做，因为要处理各种数据不一致问题，因此『聪明人』发明了各种锁来解决。但使用了 Immutable 之后，数据天生是不可变的，并发锁就不需要了。 然而现在并没什么卵用，因为 JavaScript 还是单线程运行的啊。但未来可能会加入，提前解决未来的问题不也挺好吗？ 拥抱函数式编程 Immutable 本身就是函数式编程中的概念，纯函数式编程比面向对象更适用于前端开发。因为只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。 像 ClojureScript，Elm 等函数式编程语言中的数据类型天生都是 Immutable 的，这也是为什么 ClojureScript 基于 React 的框架 — Om 性能比 React 还要好的原因。 Immutable 缺点 需要学习新的 API No Comments 增加了资源文件大小 No Comments 容易与原生对象混淆 这点是我们使用 Immutable.js 过程中遇到最大的问题。写代码要做思维上的转变。 虽然 Immutable.js 尽量尝试把 API 设计的原生对象类似，有的时候还是很难区别到底是 Immutable 对象还是原生对象，容易混淆操作。 Immutable 中的 Map 和 List 虽对应原生 Object 和 Array，但操作非常不同，比如你要用 map.get(‘key’) 而不是 map.key，array.get(0) 而不是 array[0]。另外 Immutable 每次修改都会返回新对象，也很容易忘记赋值。 当使用外部库的时候，一般需要使用原生对象，也很容易忘记转换。 下面给出一些办法来避免类似问题发生： 使用 Flow 或 TypeScript 这类有静态类型检查的工具约定变量命名规则：如所有 Immutable 类型对象以 $$ 开头。使用 Immutable.fromJS 而不是 Immutable.Map 或 Immutable.List 来创建对象，这样可以避免 Immutable 和原生对象间的混用。 更多认识Immutable.is 两个 immutable 对象可以使用 === 来比较，这样是直接比较内存地址，性能最好。但即使两个对象的值是一样的，也会返回 false：123let map1 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);let map2 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);map1 === map2; // false 为了直接比较对象的值，immutable.js 提供了 Immutable.is 来做『值比较』，结果如下：1Immutable.is(map1, map2); // true Immutable.is 比较的是两个对象的 hashCode 或 valueOf（对于 JavaScript 对象）。由于 immutable 内部使用了 Trie 数据结构来存储，只要两个对象的 hashCode 相等，值就是一样的。这样的算法避免了深度遍历比较，性能非常好。 后面会使用 Immutable.is 来减少 React 重复渲染，提高性能。 另外，还有 mori、cortex 等，因为类似就不再介绍。 与 Object.freeze、const 区别ES6 中新加入的 Object.freeze 和 const 都可以达到防止对象被篡改的功能，但它们是 shallowCopy 的。对象层级一深就要特殊处理了。 Cursor 的概念这个 Cursor 和数据库中的游标是完全不同的概念。 由于 Immutable 数据一般嵌套非常深，为了便于访问深层数据，Cursor 提供了可以直接访问这个深层数据的引用。12345678910111213import Immutable from &apos;immutable&apos;;import Cursor from &apos;immutable/contrib/cursor&apos;;let data = Immutable.fromJS(&#123; a: &#123; b: &#123; c: 1 &#125; &#125; &#125;);// 让 cursor 指向 &#123; c: 1 &#125;let cursor = Cursor.from(data, [&apos;a&apos;, &apos;b&apos;], newData =&gt; &#123; // 当 cursor 或其子 cursor 执行 update 时调用 console.log(newData);&#125;);cursor.get(&apos;c&apos;); // 1cursor = cursor.update(&apos;c&apos;, x =&gt; x + 1);cursor.get(&apos;c&apos;); // 2 实践与 React 搭配使用，Pure Render 熟悉 React 的都知道，React 做性能优化时有一个避免重复渲染的大招，就是使用 shouldComponentUpdate()，但它默认返回 true，即始终会执行 render() 方法，然后做 Virtual DOM 比较，并得出是否需要做真实 DOM 更新，这里往往会带来很多无必要的渲染并成为性能瓶颈。 当然我们也可以在 shouldComponentUpdate() 中使用使用 deepCopy 和 deepCompare 来避免无必要的 render()，但 deepCopy 和 deepCompare 一般都是非常耗性能的。 Immutable 则提供了简洁高效的判断数据是否变化的方法，只需 === 和 is 比较就能知道是否需要执行 render()，而这个操作几乎 0 成本，所以可以极大提高性能。修改后的 shouldComponentUpdate 是这样的： 12345import &#123; is &#125; from &apos;immutable&apos;;shouldComponentUpdate: (nextProps, nextState) =&gt; &#123; return !(this.props === nextProps || is(this.props, nextProps)) || !(this.state === nextState || is(this.state, nextState));&#125; 使用 Immutable 后，如下图，当红色节点的 state 变化后，不会再渲染树中的所有节点，而是只渲染图中绿色的部分： 你也可以借助 React.addons.PureRenderMixin 或支持 class 语法的 pure-render-decorator 来实现。 setState 的一个技巧 React 建议把 this.state 当作 Immutable 的，因此修改前需要做一个 deepCopy，显得麻烦：12345678910111213141516import &apos;_&apos; from &apos;lodash&apos;;const Component = React.createClass(&#123; getInitialState() &#123; return &#123; data: &#123; times: 0 &#125; &#125; &#125;, handleAdd() &#123; let data = _.cloneDeep(this.state.data); data.times = data.times + 1; this.setState(&#123; data: data &#125;); // 如果上面不做 cloneDeep，下面打印的结果会是已经加 1 后的值。 console.log(this.state.data.times); &#125;&#125; 使用 Immutable 后：12345678910getInitialState() &#123; return &#123; data: Map(&#123; times: 0 &#125;) &#125;&#125;,handleAdd() &#123; this.setState(&#123; data: this.state.data.update(&apos;times&apos;, v =&gt; v + 1) &#125;); // 这时的 times 并不会改变 console.log(this.state.data.get(&apos;times&apos;));&#125; 上面的 handleAdd 可以简写成：12345handleAdd() &#123; this.setState((&#123;data&#125;) =&gt; (&#123; data: data.update(&apos;times&apos;, v =&gt; v + 1) &#125;) &#125;);&#125; 与 Flux 搭配使用由于 Flux 并没有限定 Store 中数据的类型，使用 Immutable 非常简单。 现在是实现一个类似带有添加和撤销功能的 Store：123456789101112131415161718192021222324252627import &#123; Map, OrderedMap &#125; from &apos;immutable&apos;;let todos = OrderedMap();let history = []; // 普通数组，存放每次操作后产生的数据let TodoStore = createStore(&#123; getAll() &#123; return todos; &#125;&#125;);Dispatcher.register(action =&gt; &#123; if (action.actionType === &apos;create&apos;) &#123; let id = createGUID(); history.push(todos); // 记录当前操作前的数据，便于撤销 todos = todos.set(id, Map(&#123; id: id, complete: false, text: action.text.trim() &#125;)); TodoStore.emitChange(); &#125; else if (action.actionType === &apos;undo&apos;) &#123; // 这里是撤销功能实现， // 只需从 history 数组中取前一次 todos 即可 if (history.length &gt; 0) &#123; todos = history.pop(); &#125; TodoStore.emitChange(); &#125;&#125;); 与 Redux 搭配使用Redux 是目前流行的 Flux 衍生库。它简化了 Flux 中多个 Store 的概念，只有一个 Store，数据操作通过 Reducer 中实现；同时它提供更简洁和清晰的单向数据流（View -&gt; Action -&gt; Middleware -&gt; Reducer），也更易于开发同构应用。目前已经在我们项目中大规模使用。 由于 Redux 中内置的 combineReducers 和 reducer 中的 initialState 都为原生的 Object 对象，所以不能和 Immutable 原生搭配使用。 幸运的是，Redux 并不排斥使用 Immutable，可以自己重写 combineReducers 或使用 redux-immutablejs 来提供支持。 上面我们提到 Cursor 可以方便检索和 update 层级比较深的数据，但因为 Redux 中已经有了 select 来做检索，Action 来更新数据，因此 Cursor 在这里就没有用武之地了。 总结Immutable 可以给应用带来极大的性能提升，但是否使用还要看项目情况。由于侵入性较强，新项目引入比较容易，老项目迁移需要评估迁移。对于一些提供给外部使用的公共组件，最好不要把 Immutable 对象直接暴露在对外接口中。 如果 JS 原生 Immutable 类型会不会太美，被称为 React API 终结者的 Sebastian Markbåge 有一个这样的提案，能否通过现在还不确定。不过可以肯定的是 Immutable 会被越来越多的项目使用。 资源 Lee Byron - Immutable Data and ReactImmutable Data Structures and JavaScript","tags":[{"name":"Immutable","slug":"Immutable","permalink":"http://tawen.github.io/tags/Immutable/"}]},{"title":"Android 开发学习","date":"2017-12-18T03:09:05.000Z","path":"2017/12/18/blog20171218/","text":"Android开发环境就不记录了，由于有了android studio搭建起来也很容易，网上也有很多，这里就不说了。 创建Activity要点：1、一个Activity就是一个类，并且这个类继承Activity基类；2、需要复写onCreate方法（第一次调用Activity就会调用）；3、每个Activity都需要在AndroidMainFest(清单)文件中进行配置；4、为Activity添加必要组件;5、setContentView()使用;6、findViewById()使用;7、在布局文件中Android:”@+id/idName”和没有+号区别，还有在R.java中文件生成的引用名称的使用区别？（有待以后解答） 第一个原生应用的显示效果： intent（意图）包含的一组信息：1、Component name（下一个启动activity的名字)2、Action（个人理解对下个activity的指令（例如：ACTION_CALL））3、Data（数据）4、Category5、Extras(键值对)6、Flasgs Activity生命周期1、onCreate：Activity第一被创建被调用2、onStart：Activity能被看到被调用3、onResume：Activity能够获取用户焦点时被调用4、onPause：应用程序启用了另外一个acitity（来电话就会调用pause，当前数据保存）5、onStop：当前Activity不可见被调用；（对话框不会调用上一个activity的onStop）6、onDestory：finish(),系统资源不够用；7、onRestart：返回时替换onCreate被调用 Task栈的概念很好理解，已经理解！","tags":[{"name":"activity","slug":"activity","permalink":"http://tawen.github.io/tags/activity/"}]},{"title":"浏览器支持HTML5 video视频标签","date":"2017-12-05T03:09:05.000Z","path":"2017/12/05/blog20171205/","text":"好久没写博客了，今天给大家推荐一款录屏工具！ 使用的代码如下：123&lt;video width=&quot;352&quot; height=&quot;264&quot; controls autobuffer&gt; &lt;source src=&quot;../media/cat.mp4&quot; type=&apos;video/mp4; codecs=&quot;avc1.42E01E, mp4a.40.2&quot;&apos;&gt;&lt;/source&gt;&lt;/video&gt; 对于Opera浏览器，您可以参阅这篇上周才发表的文章“Everything you need to know about HTML5 video and audio” 对于IE浏览器，那还不知道要等到猴年马月才等到支持HTML5 video标签的时候。然而，广大劳动人民的智慧是无穷无尽的，广大开发人员的智慧也会无穷无尽的。国外领先的web开拓者们通过js，已经实现了可以让各个主流浏览器支持video标签的方法。 主流浏览器支持video标签方法很简单，只要调用一段js，就可以让主流浏览器实现video标签的视频播放。 此项目已经放到Google code上，您可以点击这里查看。 使用方法：要想让主流浏览器都支持HTML5标签，使用非常简单，只要链接一个js文件就可以了。所以，只要您的页面上（头部或底部）有这么段代码：1&lt;script src=&quot;http://html5media.googlecode.com/svn/trunk/src/html5media.min.js&quot;&gt;&lt;/script&gt; 就可以了。 对于HTML部分，使用类似下面：1&lt;video src=&quot;video.mp4&quot; width=&quot;320&quot; height=&quot;240&quot; controls autobuffer&gt;&lt;/video&gt; 是不是很简单啊！ 为了演示效果，我就直接把此js以及video标签签到这篇文章里，您将会在下面看到这段10秒钟的关于猫咪的视频，您可以切换IE或是Firefox或是chrome或是Safari观看（界面有差别的哦~~）。更新于2016-06-03由于下面2个资源大大拖慢了网页的加载速度，因此，今日起博客文章不直接呈现效果，大家可以点击下面的demo链接体验。12&lt;script src=&quot;http://html5media.googlecode.com/svn/trunk/src/html5media.min.js&quot;&gt;&lt;/script&gt;&lt;video src=&quot;http://www.zhangxinxu.com/study/media/cat.mp4&quot; width=&quot;352&quot; height=&quot;264&quot; controls autobuffer&gt;&lt;/video&gt; 当加载完毕，点击播放按钮，就可以看到视频播放了。或者您也可以狠狠地点击这里：HTML5 video多浏览器支持测试demo 三、一些说明关于实现实现的原理大致是使用了flash技术，使用flash播放器嵌入视频的方式，使得IE及Firefox支持video标签。这个播放器称为flowplayer，具体我也不是很了解。 关于视频格式目前，这种多浏览器支持方法所支持的视频格式有限，为mp4和ogv格式，否则视频可能不会播放。 可能遇到的问题您可能会遇到这样的问题：我明明链接的是mp4格式的文件啊，为什么在IE及Firefox下有问题。如果您遇到的问题是在这两个浏览器下视频不播放，或是播放时只有声音而没有图像，而在chrome浏览器或是Safari下良好，则您可能要仔细您mp4文件的编码格式了。 对于编码，我不在行，好像是视频要存储为h.264文件，不要问我是什么东西，我也不知道，这可能还要靠您自己解决了。 最后，百无聊赖，先上一张Safari浏览器下的截图，原因是，Safari下的播放器真是卡哇伊。","tags":[{"name":"video视频标签","slug":"video视频标签","permalink":"http://tawen.github.io/tags/video视频标签/"}]},{"title":"aaencode","date":"2017-12-01T03:09:05.000Z","path":"2017/12/01/blog20171201/","text":"可以执行，我当时吓尿了！ aaencode - Encode any JavaScript program to Japanese style emoticons (^_^) 添加一个转换网站 aaencode 效果：","tags":[{"name":"aaencode","slug":"aaencode","permalink":"http://tawen.github.io/tags/aaencode/"}]},{"title":"GifCam 更好用的 gif 动画录制/剪辑工具","date":"2017-11-29T03:09:05.000Z","path":"2017/11/29/blog20171129/","text":"好久没写博客了，今天给大家推荐一款录屏工具！ GifCam 是款集录制与剪辑为一体的屏幕 GIF 动画制作工具，录制后的动画可以逐帧编辑。 下载链接 界面效果： 使用截图效果：","tags":[{"name":"GifCam","slug":"GifCam","permalink":"http://tawen.github.io/tags/GifCam/"}]},{"title":"SQL的JOIN语法解析(inner join, left join, right join, full outer join的区别)","date":"2017-10-25T03:09:05.000Z","path":"2017/10/25/blog20171025/","text":"总的来说，四种JOIN的使用/区别可以描述为: left join 会从左表(shop)那里返回所有的记录，即使在右表(sale_detail)中没有匹配的行。 right outer join 右连接，返回右表中的所有记录，即使在左表中没有记录与它匹配 full outer join 全连接，返回左右表中的所有记录在表中存在至少一个匹配时，inner join 返回行。 关键字inner可省略。 具体可以看stackoverflow上，Difference between Inner Join &amp; Full join这个问题，说得蛮清楚的，我就搬运一下这个问题的答案好了。 Join一共有三种OUTER JOIN: LEFT OUTER JOIN RIGHT OUTER JOIN FULL OUTER JOIN 关键字OUTER是可选择的，取决于具体语言，在实现上它们都是遵循标准的，因此FULL JOIN和FULL OUTER JOIN是一样的。 接着将以简化的数据集来说明这些JOIN语句。考虑有如下两个数据集，注意到有些元素在A中有，在B中没有，反过来也是。 12345678Set &quot;A&quot; Set &quot;B&quot; AA BB-------- -------- Item 1 Item 3 Item 2 Item 4 Item 3 Item 5 Item 4 Item 6 LEFT OUTER JOIN现在执行如下SQL语句（左连接，LEFT OUTER JOIN）： 1SELECT * FROM A LEFT OUTER JOIN B ON AA = BB 将会得到如下的结果（空白的元素表示NULL）： 123456AA BB-------- -------- Item 1 Item 2 Item 3 Item 3 Item 4 Item 4 左连接（LEFT OUTER JOIN）会输出左边的表中的所有结果，如果右边的表中有相应项，则会输出，否则为NULL 因此，如果要找出在AA(左边的表)中有，而在BB(右边的表)中没有的数据项，可以使用如下的SQL语句：12SELECT * FROM A LEFT OUTER JOIN B ON AA = BBWHERE BB is NULL RIGHT OUTER JOIN如果使用右连接，结果将会输出BB中所有的数据项和AA中相应的匹配项（注意你现在是获取了右边的表中的所有数据项）:12345678SELECT * FROM A RIGHT OUTER JOIN B ON AA = BB AA BB-------- -------- Item 3 Item 3 Item 4 Item 4 Item 5 Item 6 FULL OUTER JOIN如果想要取得所有的元素项，则可以使用FULL JOIN:12345678910111213SELECT * FROM A FULL JOIN B ON AA = BB AA BB-------- -------- Item 1 &lt;-----+ Item 2 | Item 3 Item 3 | Item 4 Item 4 | Item 5 +--- empty holes are NULL&apos;s Item 6 | ^ | | | +---------------------+ 再次注意，缺失的数据项的值是NULL。 INNER JOININNER JOIN跟JOIN是一样的，一般INNER关键字可以省略。INNER JOIN将只会返回相匹配的元素项，即不会返回结果为NULL的数据项。123456SELECT * FROM A INNER JOIN B ON AA = BB AA BB-------- -------- Item 3 Item 3 Item 4 Item 4 CROSS JOIN最后还有一个CROSS JOIN，笛卡儿积，将会返回A中每个元素分别匹配B中所有元素的结果，即N*M组合。1234567891011121314151617181920SELECT * FROM A CROSS JOIN B AA BB-------- -------- Item 1 Item 3 ^ Item 1 Item 4 +--- A中第一个元素, 匹配B中所有元素 Item 1 Item 5 | Item 1 Item 6 v Item 2 Item 3 ^ Item 2 Item 4 +--- A中第二个元素, 匹配B中所有元素 Item 2 Item 5 | Item 2 Item 6 v Item 3 Item 3 ... and so on Item 3 Item 4 Item 3 Item 5 Item 3 Item 6 Item 4 Item 3 Item 4 Item 4 Item 4 Item 5 Item 4 Item 6 图解SQL的JOIN操作这边也有一张图清楚的说明了每个JOIN操作。建议把上面的内容浏览一边后，再好好看下这张图片，相信对JOIN的操作应该就完全明白了。","tags":[{"name":"inner join, left join, right join, full outer join","slug":"inner-join-left-join-right-join-full-outer-join","permalink":"http://tawen.github.io/tags/inner-join-left-join-right-join-full-outer-join/"}]},{"title":"英语中相似单词","date":"2017-10-10T01:26:05.000Z","path":"2017/10/10/blog20171010/","text":"akebake 烘烤食品cake 蛋糕lake 湖make 制作sake 目的stake 棍子shake 摇晃 amecame come的过去式lame 跛脚的name 名字dame 夫人same 相同的tame 驯服的 anebane 毒药cane 手杖dane 丹麦人fane 寺庙lane 小港mane 鬃毛pane 窗格 adefade 褪色made 做bade 命令jade 翡翠lade 装载wade 跋涉trade 交易 aveDavegave give的过去式pave 铺设save 保存bave 茧丝cave","tags":[{"name":"英语中相似单词","slug":"英语中相似单词","permalink":"http://tawen.github.io/tags/英语中相似单词/"}]},{"title":"英语中最最最常用的200个动词","date":"2017-09-29T03:03:05.000Z","path":"2017/09/29/blog20170929/","text":"以下200个动词是英语中最常用的动词，全部都是成人高考大纲词表中的成员，希望大家花时间把它们学会，很有用。 accept 接受 I accepted her birthday gift.act 表演；举止 Jackie Chen acts in the film.add 添加 Please add some water to the bottle.agree 同意 I agree with you.allow 允许 Mother allows me to go out.answer 回答 Can you answer my question?appear 出现；似乎 A problem appeared.arrive 到达 We arrived in the afternoon.ask 问 He asked a question.avoid 避免 Please avoid making mistakes.be 是；正在；被 We are students. She is sleeping. They were killed.become 变成，变得 It becomes warm.begin 开始 Class begins at 9.believe 相信 I believe you.break 打破 He broke the class.bring 带来 Please bring your book tomorrow.build 建造 We will build a house.burn 燃烧 The fire is burning.buy 买 What do you want to buy?call 打电话，叫，喊 I will call you in the morning.can 能 Can you swim?carry 搬，携带 Please carry the desk to the door.catch 抓 The boy caught a bird.change 变化 Everything changes.check 核对 Please check your email.choose 选择 Which book will you choose?clean 打扫 clean the roomclose 关闭 Close the door, please.come 来 Come in, please.cost 花费 It cost me 5 yuan.consider 考虑 I am considering a visit to you.contain 包含 It contains 5 pages.continue 继续 We will continue to work.control 控制 Can you control yourself?could 能 She could do that.cover 覆盖 The snow covered the flowers.cry 哭 Don’t cry!cut 切 He cut his finger while cooking.deal 处理；交易 I will deal with it.decide 决定 We decided to go.describe 描述 Can you describe your room?design 设计 We designed the cover of the book.develop 发展 China is developing very quickly.die 死 You will die here.discover 发现 He discovered the first man.discuss 讨论 We are discussing the plan.do 做 What do you do?draw 画；拉 She is drawing a picture. Draw the desk.dream 做梦 He is dreaming.drink 喝 What do you want to drink?drive 驾驶 Can you drive?drop 丢下，滴 Please drop it on the floor.eat 吃 How much do you eat?end 结束 The meeting ended.enjoy 享受，喜欢 He enjoys music.enter 进入 Please enter the room.expect 期望 I expect you to come.explain 解释 Can you explain it to me?fail 失败，不及格 He failed in the exam.fall 下降；跌倒 The raining is falling.feel 感觉 Do you feel happy?fight 打架；战斗 They are fighting for food.fill 填充，填满 Please fill the bottle with milk.find 找到 Find out the person.finish 完成 We have finished it.fly 飞 Birds can fly.follow 跟随，跟踪 Please follow me.forget 忘记 Don’t forget it.get 得到，到达 The workers get their money every week.give 给 Give it to me.go 去 go to workgrow 增长，种植，成长 The number is growing. Grow trees. You have grown up.guess 猜测 Guess my age.hang 挂，吊 Hang your clothes there.happen 发生 What happened?have 有，吃喝玩乐；一直，已经；使，让 Have a book. I have lived here since 1990. have your hair cuthear 听见 Can you hear me?help 帮助 help you with your Englishhit 打，撞 He hit his car into a tree.hold 抓住；容纳 hold the ball. The room can hold 500 people.hope 希望 I hope you can come.hurt 伤害，疼 You hurt me. My head hurts.improve 提高 improve our livesinclude 包含，包括 The book includes 10 parts.increase 增加 The number is increasing.join 加入 Please join us to go to the part.keep 保持，保存 Clothes keep us warm. I will keep the money for my son.kill 杀 kill the birdknow 知道 Do you know me?laugh 笑 He laughed at me.lay 放置；产卵 Please lay the book on the desk.lead 代领，领导 He is leading the team.learn 学习 learn Englishleave 离开 Close the door before you leave.let 让 Let me have a look.lie 说谎；躺，位于 He is lying. Being lies in the north of China.like 喜欢 Do you like it?listen 听 listen to musiclive 居住 live herelook 看 look at melose 输，失去 We will lose the game. I lost me key.love 爱 I love you.make 制作 make a cake for youmay 可能，可以 He may come tomorrow.mean 意思是；意味着 What do you mean?meet 见面 We meet everyday.might 也许 It might rain tomorrow.miss 思念；错过 I miss you very much. We missed the train.move 移动 Don’t move.must 必须；肯定 You must work hard.need 需要 We need you.occur 发生 What occurred to you?offer 提供 The company offered me a job.open 打开 Open the door.pass 通过 pass the exam.pay 付钱 I will pay for the food.perform 表演 They are performing in Beijing.pick 挑，捡 Pick up your bag.plan 计划 They plan to go.play 玩儿 play footballpoint 指（向） He pointed at me.prevent 预防 We were prevented from entering the site;prepare 准备 We are preparing for the exam.prefer 更喜欢 I prefer apples to oranges.produce 生产 They produce 1,000 cars last week.protect 保护 The glasses will protect your eyes.prove 证明 It proves to be right.provide 提供 Can you provide some jobs to us?pull 拉 Pull the door.push 推 push the doorput 放，放置 put it hereraise 提高；养（动物、家等）；抬高 raise your hands. Raise animals. Raise familyreach 到达 We reached in the morning.read 读 Can you read in English?realize 意识到；实现 We realized we were wrong. Realize your dream.receive 收到 I received a letter from her.reduce 减少，降低 We should reduce the price.remain 仍然 It remains to be seen. 有待观察。remember 记得 Do you remember me?remove 移除，除掉 Remove your enemies.report 报告 You report to me.require 要求 You are required to finish it.return 归还，回来 return the book to the library. He will return next week.rise 上升 The sun rises in the east.ride 骑，乘车 ride a bike/horsering 打电话；响铃，敲钟 I will ring you tomorrow. The bell rings.run 跑 run awaysave 挽救；保存 save my life; save watersay 说 What did you say?see 看到 Can you see me?seem 似乎 It seems you are wrong.sell 卖 She sells flowers.send 送，发送 send a letterserve 提供 serve foodset 设置 set the timeshake 摇，震 shake hands with meshoot 射击 He shoot at the bird.should 应该 You should go.show 给……看，表演 Show me the way.shut 关闭，关 shut the windowsing 唱歌 sing a song.sit 坐 Sit down, please.sleep 睡眠 I can’t sleep.smell 闻，闻起来 The food smells delicious.sound 听起来 It sounds good.speak 讲话，说 Can you speak Japanese?spend 花费 I spent 5 yuan on the book.split 分离spill 溢出spirit 精神 stand 站立 Stand up!start 开始 The film started.stay 待在……，住在 stay at homesteal 偷 The thief stole my bag.stop 停止 Stop talking.study 学习 study Englishsuggest 建议 What do you suggest?support 支持 I support you.swim 游泳 Can you swim?take 带走；花费 Take the book home.talk 交谈，说话 We are talking about him.teach 教 I teach English.tell 告诉，讲（故事） Tell me a story.thank 感谢 Thank you.think 想 I think you are right.throw 扔 Throw a stone at the dog.treat 治疗；对待 The doctor is treating him.try 尝试，努力 I’ll try my best to do it.turn 旋转 He turned around and talked to me.understand 理解，明白 Do you understand me?use 使用 Can you use a computer?visit 拜访，参观 I will visit you.wait 等 Please wait for me.walk 走路 We walk in the garden everyday.want 想 What do you want to buy?watch 观看，欣赏 They are watching the moon.wash 洗 Please wash your hands.wear 穿 What are you wearing?will 将会，将要 I will tell you.win 赢 They win the game.work 工作 I work in Beijing.worry 担心 I am worrying about you.would 将会 Would you like to go?write 写 Write a letter.","tags":[{"name":"常用的200个动词","slug":"常用的200个动词","permalink":"http://tawen.github.io/tags/常用的200个动词/"}]},{"title":"atom开发常用插件","date":"2017-09-28T03:03:05.000Z","path":"2017/09/28/blog20170928/","text":"packagesmarkdown atom 现在已经成为我的最佳 markdown 编辑器，有了下面的插件后，使用体验，简直太棒了。 markdown-preview-plus@2.2.2 markdown-assistant@0.1.0(Upload images from the clipboard automatically, win10 下失败，osx 完美成功，粘贴图片直接转成 md 文本，不要太棒，优雅的没朋友) qiniu-uploader@0.0.3 markdown-writer@2.3.2(在设置里面设置一下，就拥有了正常 md 编辑器的编辑 md 的各种快捷键 例如 cmd + b, cmd + shift + k 插入链接，而且更棒非常值得一试) markdown-toc@0.4.1 autocomplete atom-ternjs@0.13.2(js 最佳补全插件) simplyy-snippets@0.4.4(我写的 web 前端代码补全插件，详情见GitHub - SimplyY/simplyy-snippets: atom package for code complete) css-snippets@0.9.0 autocomplete-html-entities@0.1.0 tag@0.3.0 autocomplete-modules@1.4.1 emmet-atom indent guess-indent@0.1.0 resize-indent@0.2.1 code hint and linter linter@1.11.3 jshint@1.8.3 jsonlint@1.1.2 csslint@1.1.4 htmlhint@1.1.3 ui activate-power-mode@0.4.1(虽然很炫酷，但是我不用) file-icons@1.6.18(让你拥有高颜值的文件图标) file-type-icons pigments 代码颜色可视化 foldername-tabs@0.1.11 highlight-column@0.5.1 highlight-selected@0.11.2 indent-guide-improved@1.4.5 minimap@4.21.0 fold-comments@0.6.0 fold-functions@0.4.3 git project merge-conflicts@1.3.7(amazing ，再也不怕 git 的合并冲突了，分分钟解决 conflicts) git-projects@1.17.0 language language-SCSS@0.4.0 language-vue@0.9.0 react@0.14.1 other tools atom-beautify@0.28.26（格式化代码） line-count@0.5.0 change-case@0.6.0（将代码文本更改风格，比如 testCode =&gt; TEST_CODE） todo-show@1.4.0 open-html-in-browser@0.1.0 pretty-json@0.4.1 atom-html-preview open-in-browser autocomplete-paths Tree-view tree-view-copy-relative-path@1.0.0 copy-filename@1.0.1 tree-view-git-status@0.2.3 chary-tree-view@0.2.3(Tree-view responds to only double-click to avoid opening a large file accidentally.) amazing useful terminal-plus","tags":[{"name":"atom开发常用插件","slug":"atom开发常用插件","permalink":"http://tawen.github.io/tags/atom开发常用插件/"}]},{"title":"CMD常用命令大全","date":"2017-09-19T03:03:05.000Z","path":"2017/09/19/blog20170919/","text":"cd\\ 返回到根目录cd.. 返回到上一级目录 1、cd 显示当前目录名或改变当前目录。2、dir 显示目录中的文件和子目录列表。3、md/mkdir 创建目录。4、del 删除一或数个文件。5、chkdsk 检查磁盘并显示状态报告。6、cacls 显示或者修改文件的访问控制表(ACL)7、copy 将一份或多份文件复制到另一个位置。8、date 修改日期9、format 格式化磁盘10、type 显示文本文件的内容。11、move 移动文件并重命名文件和目录。12、expand 展开一个或多个压缩文件。13、ren 重命名文件。14、attrib 显示或更改文件属性。15、time 显示或设置系统时间。16、at at命令安排在特定日期和时间运行命令和程序。要使用 AT 命令，计划服务必须已在运行中。17、net [user],[time],[use] 多，自己去查18、netstat 显示协议统计和当前tcp/ip连接19、nbtstat 基于NBT（net bios over tcp/ip）的协议统计和当前tcp/ip连接20、route 操作和查看网络路由表21、ping 就不说了，大家都熟悉吧22、nslookup 域名查找23、edit 命令行下的文本编辑器24、netsh强大的命令行下修改tcp/ip配置的工具25、fdisk 相信现在用的人比较少了，不过在没有其他工具的情况，他还是有用的","tags":[{"name":"CMD常用命令大全","slug":"CMD常用命令大全","permalink":"http://tawen.github.io/tags/CMD常用命令大全/"}]},{"title":"web开发快速提高工作效率的网址及工具","date":"2017-07-23T08:03:05.000Z","path":"2017/07/23/blog20170723/","text":"工欲善其事必先利其器，在技术快速更新的时代，我们不要闭门造车，要借助的现有的资源提高我们的效率，以下是我整理出来比较实用的网址，会持续更新…… 工具网址 图片压缩[https://tinypng.com/ ]加私有前缀[ https://autoprefixer.github.io/ ]快速生成栅格化 [ http://grid.guide/ ]code pen [ https://codepen.io/ ]阿里巴巴矢量图标 [ http://www.iconfont.cn/ ]有字库 [https://www.youziku.com/ ]ico转换工具 [http://www.bitbug.net/ ]动效网站 loading加载动画[ https://loading.io/ ]按钮动画[ http://www.17sucai.com/pins/demoshow/25581]白鹭时代[https://www.egret.com ]canvas-echart图表[http://echarts.baidu.com/ ]jquery 插件 [http://www.unheap.com/ ]插件工具 谷歌浏览器的几款插件1、JSONview插件，将json数据美化；2、Wappalyzer插件，查看网站用了那些技术；3、Vue Devtools插件，可以查看vue整体的结构；设计网站 website [ http://reeoo.com/ ]seeseed [https://www.seeseed.com/ ]bwg [ https://bestwebsite.gallery/ ]天空之城 [ https://www.skypixel.com/ ]500px [https://500px.com/popular ]国外优秀的UI设计资源库 [http://www.w3cplus.com/source/ui-design.html ]20个免费下载PSD设计网站 [ http://www.w3cplus.com/source/20-great-websites-to-download-free-psd-files.html ]书籍 《JavaScript DOM编程艺术》《JavaScript权威指南》《javaScript DOM高级程序设计》《JavaScript设计模式》《锋利的jquery》其他 GitHub最全的前端资源汇总仓库（包括前端学习、开发资源、求职面试等）[https://github.com/helloqingfeng/Awsome-Front-End-learning-resource ]关于js的学习方法 [ https://www.sitepoint.com/projects-can-sometimes-be-the-worst-way-to-learn-javascript/ ]9 个常见错误阻碍你进步 [ https://juejin.im/post/59bb4a7c6fb9a00a53274cd7 ]如何优雅的编写 JavaScript 代码 [ https://zhuanlan.zhihu.com/p/28910636 ]","tags":[{"name":"web开发快速提高工作效率的网址及工具","slug":"web开发快速提高工作效率的网址及工具","permalink":"http://tawen.github.io/tags/web开发快速提高工作效率的网址及工具/"}]},{"title":"npm 设置淘宝镜像","date":"2017-06-30T01:03:05.000Z","path":"2017/06/30/blog20170630/","text":"设置淘宝镜像方法：在nodejs\\node_modules\\npm\\npmrc文件中添加 :1registry=https://registry.npm.taobao.org npm https协议不支持 期待http？err message：1npm ERR! Protocol &quot;https:&quot; not supported. Expected &quot;http:&quot; solution： 12npm config rm proxynpm config rm https-proxy","tags":[{"name":"npmrc文件中设置淘宝镜像","slug":"npmrc文件中设置淘宝镜像","permalink":"http://tawen.github.io/tags/npmrc文件中设置淘宝镜像/"}]},{"title":"2017年上半年工作总结和下半年工作规划","date":"2017-06-20T02:03:05.000Z","path":"2017/06/20/blog20170620/","text":"自2017年03月20日入职之日起，到公司也有三个月了。感谢领导的信任与支持能顺利转正。 2017年上半年工作总结图书馆云数据平台（pc端和手机端） 这个项目主要是在原有页面上和接口数据对接，控制数据输出的格式，长短以及展示方式； 读者满意度调查 在问卷调查编辑页面存在js逻辑的严重错误；梳理这部分js逻辑，在原有基础上重构逻辑； 中图协会 浏览器兼容性、以及js报错修正； 新版中图协会前端UI框架搭建； 中图协会项目帮助中心静态页面制作； 评估定级官网 这个项目是我来公司的新项目，前后有两个版本。第一个版本是静态数据展示项目，第二个版本是对第一个版本设计的改版，同事通知模块改成动态获取资源形式。 2017年上半年存在问题这段时间一直在解决公司项目中的前端问题（包括图书馆大数据平台项目、评估顶级官网、读者满意度调查、评估定级忘记密码模块静态页面制作、中图协会项目帮助中心静态页面制作）。相信将来的项目中前端问题都能迎刃而解。 功能需求：我们在做项目时候对项目的功能需求不够清晰明了就开始做设计与开发了； 时间规划：一直以来，所有项目在时间上都是越快越好。希望领导在时间方面给予技术部更多的时间来开发；很多时候流程走到技术部就没时间了，开发上就会一味要求速度，缺少了对细节功能是实现上的考虑。 用户体验：上半年做的几个项目都是在实现基础的功能，以及兼容性的考虑；很少对网站的用户交互体验方面做考虑。 2017年下半年工作规划下半年工作主体思路，提高用户体验以及自我提高。 用户体验：不是简单实现功能需求，在用户体验方面会做更多考虑。 对于新项目：在开始前做开始多做思考，细化功能需求；针对设计图做细致分析，实现方式以及实现难度做评估；对于已有项目：对原有项目做总体考虑，避免牙疼治牙，脚疼治脚。 自我提高：学习前端流行技术，更好的和各部门同事协作； 需公司给予的支持希望设计部门能在设计上做更充分的考虑，了解web设计规范。","tags":[{"name":"工作总结","slug":"工作总结","permalink":"http://tawen.github.io/tags/工作总结/"}]},{"title":"HTML5中Video不能跨域","date":"2017-06-13T02:03:05.000Z","path":"2017/06/13/blog20170613/","text":"大家都知道ajax有跨域问题，img、script、iframe、link标签都可以跨域，本以为video也可以跨域，然而… 解决video跨域方案：1、服务器端设置：Access-Control-Allow-Origin 2、客服端：使用iframe实现跨域","tags":[{"name":"html5 video","slug":"html5-video","permalink":"http://tawen.github.io/tags/html5-video/"}]},{"title":"一般过去时和一般将来时","date":"2017-05-27T02:03:05.000Z","path":"2017/05/27/blog20170527/","text":"基础句型 - 主系表 主谓宾 一般现在时 is/am are 动原、动s 助动词do、does（助动词出现，谓语用原型） 一般过去时 was were 动过、助动词did（助动词出现，谓语用原型） 一般将来时 will+be will+动原 一般将来时 be going to be be going to 动原 He is in the car.He is not in the car. She was in New York yesterday.She was not in New York yesterday. He does his homework every evening.He does not do his homework every evening.He will do his homework tomorrow. They went fishing last Saturday.They did not go fishing last Saturday. 一般过去时使用环境1、明确过去时间。just now、yesterday、last Sunday I went shopping last Sunday.I did not go shoppiing last Sunday. 2、语境暗示了过去When did you come back?Did you love me?Do you love me?I love you.I loved you. 一般将来时肯定句He visits us every day.He visited us yesterday.He will visit us tomorrow. 否定句He does not vistit us every day. He did no visit us yesterday. he will not visit us tomorrow. 疑问句Does he visit us every day?Did he visit us every day?Will he visit us every day? 特殊疑问句 提问主语，语序不变Who visits us every day?Who visited us yesterday?Who will visit us tomorrow? 特殊疑问句 提问非主语，特助主谓Who do we visit every day?Who did we visit yesterday?Who will we visit tomorrow? be going to beYou are going to know my storyYou will know my story You are not going to know my story. Are you going to know my story. Who will know my story?Who is going to know my story? What will you know?What are you going to know?","tags":[{"name":"英语语法","slug":"英语语法","permalink":"http://tawen.github.io/tags/英语语法/"}]},{"title":"三大结构复习","date":"2017-05-26T02:03:05.000Z","path":"2017/05/26/blog20170526/","text":"主谓宾主语：n、pron谓语：非be宾语：n、pron They learn English every day. 主系表主语：n、pron谓语：非be宾语：n、pron、adj、adv、介宾 He is in the car. There beThere are many students in the classroom. 定语 限定名词范围，定语追着名词跑，形副介宾来担当、形做定语名词前、副词介宾名词后。 a clean room the box on the table children there. I like clean rooms.The box on the table is red.Chirdren there don’t learn English 状语 何时何地怎么主谓 +方式 地点 时间 Tom is from England.Tom comes from England. I Learn English by ell-phone on the bus every day. 补语","tags":[{"name":"英语语法","slug":"英语语法","permalink":"http://tawen.github.io/tags/英语语法/"}]},{"title":"主谓（宾）结构","date":"2017-05-25T02:03:05.000Z","path":"2017/05/25/blog20170525/","text":"主系表 - 主语 谓语 表语 - I am n、pron、adj、adv、art介宾 - 三单 is n、pron、adj、adv、art介宾 - 非三单 are n、pron、adj、adv、art介宾 主谓宾 - 主语 谓语 宾 状 - 三单 动s n、pron 介宾、副词 - 非三单 动原 n、pron 介宾、副词 小贴士：动词词尾加s规则与名词变复数规则相同 Example： 肯定句： You like me. She likes you. 否定句： You do not like me. She does not like you. 一般疑问句： Do you like me? Does she like you? 特殊疑问句：问主语，语序不变：Who like me？Who likes you？ 问非主语,特助主谓： Who do you like me？Who does she like？","tags":[{"name":"英语语法","slug":"英语语法","permalink":"http://tawen.github.io/tags/英语语法/"}]},{"title":"There be 结构","date":"2017-05-24T02:03:05.000Z","path":"2017/05/24/blog20170524/","text":"There is/are + 名词 + 地点（存在某物在某地，名词是真正的主语） 存在一棵树There is a tree. There is some water under the tree. There is a cat under the tree. There are two dogs under the tree. There is a cat and two dogs under the tree. There are two dogs and a cat under the tree.","tags":[{"name":"英语语法","slug":"英语语法","permalink":"http://tawen.github.io/tags/英语语法/"}]},{"title":"人称代词的格","date":"2017-05-23T02:03:05.000Z","path":"2017/05/23/blog20170523/","text":"代词主格：做主语I am from China. You are from China. He is from China. Shi is from China. It is from China. We are from China. You are from China. They are from China. 代词宾格：动后、介后Tom loves me. Tom loves you. Tom loves him. Tom loves her. Tom loves it. Tom is with us. Tom is with you. Tom is with them. 形容词物主代词(代词形容格)：一直跟着名词跑Tom is my friend. Tom is your friend. Tom is his friend. Tom is her friend. Tom is its friend. Tom is our friend. Tom is your friend. Tom is their friend.","tags":[{"name":"英语语法","slug":"英语语法","permalink":"http://tawen.github.io/tags/英语语法/"}]},{"title":"主系表结构入门","date":"2017-05-22T02:03:05.000Z","path":"2017/05/22/blog20170522/","text":"代词当主语 主系表结构（主语、谓语、标语）。例句：小明是学生。 主语：名词、代词 谓语：be动词（is/am/are） 表语：名词、代词、形容词、副词、介短 - 主语 谓语 表语 单数 he、she、it is a/an+名词单数 单数 i am a/an+名词单数 单数 you are a/an+名词单数 复数 you/we/they are 名词复数 Example： I am a man. You are a woman. He is a teacher. She is a student. It is a baby. It is a dog. We are wen. You are Women. They are teachers. They are students. They are babies. They are dogs. 肯定句 主语 谓语 表语 三单 is 名n、代pron-宾格、形adj、副adv、介prep（介宾） i am 名n、代pron-宾格、形adj、副adv、介prep（介宾） 其他 are 名n、代pron-宾格、形adj、副adv、介prep（介宾） 辨认人称 - 第一人称 第二人称 第三人称 单数 I You he/she/it/a cat/water 复数 We You They/two cats 名词做表语I am a man. adj做表语The boy is tall.The girl is short. 副词做表语I am here.You are there. 介词做表语She is at home. 否定句、疑问句否定句She is not a student.They ate not students.The body is not tall.The girl is not short.I am not here.You are not there.She is not at home. 一般疑问句Is she a student?Are they students?Is the boy tall?Is the girl short?Am i here?Are you there?Is she at home? 特殊疑问句 提问主语：语序不变 1、谁高？2、谁在那里？3、谁在家？4、谁是Tom？ 提问非主语：特+一般疑问句 5、我是谁？6、你在哪里？ Who is/are tall？Who is/are there？Who is/are at home？Who is Tom？ Who am I？Where are you?","tags":[{"name":"英语语法","slug":"英语语法","permalink":"http://tawen.github.io/tags/英语语法/"}]},{"title":"国际音标","date":"2017-05-14T02:03:05.000Z","path":"2017/05/14/blog20170514/","text":"国际音标48个，辅音28，元音12个；20个辅音清浊对应发音完全一样，清音不震动声带，浊音正常说话的状态。 辅音清浊对应辅音[p]泼,[b]播（无尾音） 例子：pig、big、cap、cab[t]特,[d]得（无尾音,舌头在汉字的基础上向上调整，放在牙龈位置） 例子：tear、dear、foot、food[k]课,[g]哥（无尾音） 例子：coat、goat、back、bag[f]夫,[v]乌（无尾音，上齿压下唇） 例子：fast、vast、laugh、love[ʃ]师,[ʒ]日（无尾音，圆唇噘嘴） 例子：ship、fish、television、usual[θ]寺,[ð]自（无尾音，轻咬舌尖） 例子：theme、them、mouth、there[s]寺,[z]自（无尾音，舌端齿龈不接触） 例子：seal、zeal、bus、buzz[ts]刺,[dz]自（无尾音，舌端贴上齿龈） 例子：carts、cards、parts、pads[tʃ]吃,[dʒ]知（无尾音，舌端贴上齿龈） 例子：check、jack、H、age[tr]戳,[dr]桌（无尾音，舌端贴上齿龈） 例子：try、dry、trip、drip 另外8个辅音鼻音[m]（无尾音、闭嘴、鼻孔出气、吃饱饭） 例子：mother、mom[n]（无尾音、张嘴、舌端贴上齿龈（抬舌头）、鼻孔出气） 例子：nine、ten[ŋ]（无尾音、张嘴、像[k]） 例子：long think [l]（无尾音、张嘴、抬舌头、口腔出气） 例子：like、milk、ill [h]喝（无尾音） 例子：home、hand[r]肉（无尾音） 例子：rose、red[w] （无尾音，含吸管，再松开） 例子：watch、water[j]爷（无尾音） 例子：yes、yellow 元音单元音[æ]（左右下二指） 例子：bag、man[e]（左右下一指） 例子：beg、men [i]（左右下小指指尖） 例子：sit、ship[i:]（左右下火柴棍） 例子：seat、sheap [ʌ]（上下，啊卡住） 例子：cut、duck[ɑ:]（上下，啊） 例子：cart、dark [ɒ]（圆唇、哦卡住） 例子：dog、watch[ɔ:]（更圆唇、哦） 例子：door、war [ʊ]（乌卡住） 例子：foot、pull[U:]（乌） 例子：foot、pool [ə]（饿卡住） 例子：sister、China[ɜ:]（饿） 例子：worker、shirt 双元音[eɪ]（A） 例子：cake、late[aɪ]（I） 例子：ice、time[ɔɪ] 例子：boy、toy [eə] 例子：bear、pear[ɪə] 例子：dear、idea[ʊə] 例子：tour、sure [əʊ] 例子：rose、home[aʊ] 例子：house、cloud","tags":[{"name":"国际音标","slug":"国际音标","permalink":"http://tawen.github.io/tags/国际音标/"}]},{"title":"开始使用 Webpack","date":"2017-05-04T02:03:05.000Z","path":"2017/05/04/blog20170504/","text":"安装前提：已经安装了nodejs &amp; npm有了 npm 后安装非常的方便，不论是在windows还是mac下, 只需要一句1npm install webpack -g 就可以把 webpack 安装在全局环境下，然后就可以在terminal 或者是 cmd 里直接使用 webpack 了。一般在项目的目录下使用的时候会加上 –save-dev 这个参数1npm install webpack --save-dev 打包假设目录下有一个 app.js 文件123function helloworld () &#123; alert(&apos;hello world!&apos;);&#125; 在命令行中输入：1webpack ./app.js ./bundle.js 发现目录下已经生成了一个 bundle.js 文件，并且伴随着一个 webpack 任务的完成信息的输出 输出的信息： 这次打包的MD5(Hash) Webpack 的版本号(Version) 还有打包花费的时间(Time) 随后会看到一个列表： 打包后的文件名称 Asset 包大小 Size 代码块编号 Chunks 代码块名称 Chunk Names 打开bundle.js 会看到已经生成了的文件, 下面的代码为了方便阅读去掉了不必要的注释：123456789101112131415161718192021222324252627282930313233343536(function(modules) &#123; // webpackBootstrap // The module cache var installedModules = &#123;&#125;; // The require function function __webpack_require__(moduleId) &#123; // Check if module is in cache if(installedModules[moduleId]) return installedModules[moduleId].exports; // Create a new module (and put it into the cache) var module = installedModules[moduleId] = &#123; exports: &#123;&#125;, id: moduleId, loaded: false &#125;; // Execute the module function modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // Flag the module as loaded module.loaded = true; // Return the exports of the module return module.exports; &#125; // expose the modules object (__webpack_modules__) __webpack_require__.m = modules; // expose the module cache __webpack_require__.c = installedModules; // __webpack_public_path__ __webpack_require__.p = &quot;&quot;; // Load entry module and return exports return __webpack_require__(0);&#125;)([/* 0 */function(module, exports) &#123; function helloworld () &#123; alert(&apos;hello world!&apos;); &#125;&#125;]); 为了更了解webpack打包的工作原理以及打包后的代码在浏览器中的如何运行，阅读了一下生成后的代码整个代码是一个自运行函数，分两部分： 第一部分可以理解是webpack启动架，其中定义了一个空对象（installedModules）来存放 webpack modules，定义了webpack 运行环境下的require函数（’webpack_require‘），最后这一句：webpackrequire(0) 是把作为参数传入的实际代码通过require函数执行了一遍 第二部分是 app.js里的实际代码，前面的注释是webpack 给实际代码模块的 moduleId ，在app.js 的实际代码外面多了一个匿名函数，把参数module，export，webpack_require传了进来，方便实际 app.js里的代码使用。 模块化webpack 支持多种js模块方案的打包： ES6 modules Commonjs AMD 假设有两个js 文件,一个是 app.js, 另一个 util.js，utils里的内容如下： 1234567// CommonJs 规范的模块化// utils.jsmodule.exports = &#123; say: function (word) &#123; alert(word); &#125;&#125;; app.js 加入对util的引用 1234var util = require(./util.js);function helloworld () &#123; util.say(&apos;hello world!&apos;);&#125; 打包完的代码如下:1234567891011121314([/* 0 */function(module, exports, __webpack_require__) &#123; var util = __webpack_require__(1) function helloworld () &#123; util.say(&apos;hello world!&apos;); &#125;&#125;,/* 1 */function(module, exports) &#123; module.exports = &#123; say: function (word) &#123; alert(word); &#125; &#125;;&#125;]); 发现在bundle.js 里，app里引用的util.js的地址已经变为webpack的moduleId了,require也被替换为webpack的启动架中定义的webpack_require方法。每个模块都被编号，app.js 为 0, util.js 为 1。在代码中使用了require 方法的，外面匿名函数传入的参数也增加了webpack_require。","tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://tawen.github.io/tags/Webpack/"}]},{"title":"React利用prop-types第三方库对组件的props中的变量进行类型检测","date":"2017-05-01T02:03:05.000Z","path":"2017/05/01/blog20170501/","text":"引言——JavaScript就是一个熊孩子对于JSer们来说，js是自由的，但同时又有许多让人烦恼的地方。javascript很多时候就是这么一个熊孩子,他很多时候并不会像C和java这些“好孩子”那样循规蹈矩。因此给我们带来许多烦恼运行时候控制台报错：uncaught error，这尤其令人恼火的是系统告诉我们有错误但是又不告诉我们错误发生在哪里。试想一下，你到一个地方旅游迷了路，一个当地的熊孩子一直笑嘻嘻地跟在你后头告诉你：“你走错啦！”。但是不告诉你应该怎么走，你会不会很想揍他一顿？（╬￣皿￣） 运行时报了确定的错误，然而我们发现这TM完全是一条驴唇不对马嘴的错误报告。甚至于去stackoverflow上寻找答案，却发现提问的错误场景跟自己的根本是两码事。让我们回到1中场景，假如这个熊孩子很好心地告诉了你路线，结果你走到天黑发现被熊孩子狠狠得耍了，导致你不得不在大晚上露宿街头，你会不会比1中场景更想揍他一顿？（╬￣皿￣） 你主观地写错了了一个变量的类型，比如把字符串1写成数字1，但是系统“很好心”地不报错误提示。（我们都不需要特别的进行类型声明当然不会报告错误提示啦）而这却可能就是你接下来bug的源头。让我们回到1，2中场景，假如这个熊孩子知道你这个外地人绝逼是走错路了，但当你问路：“我走对路了吗？”时候，他笑靥如花满面春风得点点头，让你充满信心充满希望得一条路走到黑。我想你此时的心情不会比1和2中的要好（╬￣皿￣） 中情况有时候比较难以避免 中情况我们可以通过熟悉主要的6种uncaught error的情形加以判断。(在下一篇文章里我会讨论这个问题) 中的情况呢，完全可以用类型检测的方式加以避免，这也就是我这篇文章所讲到的内容 本节主要讨论的是与react配套的类型检测库——prop-types的运用 今天我在这篇文章里面介绍的内容，就是通过react的propTypes进行类型检测，。顾名思义prop-types就是对react组件中props对象中的变量进行类型检测的，因为props是react数据流的管道，我们通过prop-types就可以轻松监控react里大多数据的变量类型先介绍下propTypes的基本用法。 prop-types基础入门首先你需要通过在终端npm install prop-types安装一个叫prop-types的第三方包然后通过下面的写法对你的某一个组件的props中的变量进行类型检测：12345yourComponent.propTypes = &#123; 属性1：属性1的变量类型， 属性2：属性2的变量类型 //...&#125; propTypes的使用全解利用propTypes检测全部数据类型的变量12345678910111213141516171819202122 import React from &apos;react&apos; class Son extends React.Component&#123; render()&#123; return (&lt;div style =&#123;&#123;padding:30&#125;&#125;&gt; &#123;this.props.number&#125; &lt;br/&gt; &#123;this.props.array&#125; &lt;br/&gt; &#123;this.props.boolean.toString()&#125; &lt;/div&gt;) &#125;&#125;class Father extends React.Component&#123; render()&#123; return (&lt;Son number = &#123;&apos;1&apos;&#125; array = &#123;&apos;[1,2,3]&apos;&#125; boolean = &#123;&apos;true&apos;&#125; /&gt;) &#125;&#125; 比如这个例子，我们通过props从父组件向子组件传递属性，你原本试图通过number，array和boolean这三个属性分别向Son中传递一个数字，数组和一个布尔型数值，但由于你刚一下子追完了50多集《人民的名义》，导致你过度疲惫，把它们都写成了字符串，虽然渲染是正常的，但这可能会导致你接下来调用一些方法的时候发生错误，而系统并不提供任何提示。 让我们给它加上propTypes的类型检测： 123456789101112131415161718192021222324252627import React from &apos;react&apos;import PropTypes from &apos;prop-types&apos;;class Son extends React.Component&#123; render()&#123; return (&lt;div style =&#123;&#123;padding:30&#125;&#125;&gt; &#123;this.props.number&#125; &lt;br/&gt; &#123;this.props.array&#125; &lt;br/&gt; &#123;this.props.boolean.toString()&#125; &lt;/div&gt;) &#125;&#125;Son.propTypes = &#123; number:PropTypes.number, array:PropTypes.array, boolean:PropTypes.bool&#125;class Father extends React.Component&#123; render()&#123; return (&lt;Son number = &#123;&apos;1&apos;&#125; array = &#123;&apos;[1,2,3]&apos;&#125; boolean = &#123;&apos;true&apos;&#125; /&gt;) &#125;&#125; 然后我们就能看到报的错误了，而且这个时候，报的错误包括错误的props属性名称，错误的变量类型，属性所在的组件名称，预期的正确的变量类型，错误代码的位置以及其他更详细的信息。 这种“人为控制”的报错比一般的系统报错看起来应该要亲切自然得多吧…你大可以说：这个error是我“私人定制”的呦 （//▽//） propTypes 能用来检测全部数据类型的变量，包括基本类型的的string，boolean,number,以及引用类型的object,array,function,甚至还有ES6新增的symbol类型 123456789Son.propTypes = &#123; optionalArray: PropTypes.array,//检测数组类型 optionalBool: PropTypes.bool,//检测布尔类型 optionalFunc: PropTypes.func,//检测函数（Function类型） optionalNumber: PropTypes.number,//检测数字 optionalObject: PropTypes.object,//检测对象 optionalString: PropTypes.string,//检测字符串 optionalSymbol: PropTypes.symbol,//ES6新增的symbol类型&#125; 【注意】下面这些是从官方英文文档里引用过来的，你大概能够注意到，五种基本类型中的undefined和null并不在此列，propTypes类型检测的缺憾之一是，对于undefined和null的值，它无法捕捉错误 让我们把上述实例中的Father组件传递给Son组件修改一下,改成：123456789class Father extends React.Component&#123; render()&#123; return (&lt;Son number = &#123;null&#125; array = &#123;null&#125; boolean = &#123;null&#125; /&gt;) &#125;&#125; 结果是输出台不报任何错误，（当然你改成undefined也是同样效果）。 通过oneOfType实现多选择检测——可规定多个检测通过的数据类型上个例子中类型检测的要求是一个变量对应一个数据类型，也就是规定的变量类型只有一个。那么怎样能让它变得灵活一些，比如规定多个可选的数据类型都为检测通过呢？PropTypes里的oneOfType方法可以做到这一点，oneOfType方法接收参数的是一个数组，数组元素是你希望检测通过的数据类型。 1234567891011121314151617181920212223import React from &apos;react&apos;import PropTypes from &apos;prop-types&apos;;class Son extends React.Component&#123; render()&#123; return (&lt;div style =&#123;&#123;padding:30&#125;&#125;&gt; &#123;this.props.number&#125; &lt;/div&gt;) &#125;&#125;Son.propTypes = &#123; number:PropTypes.oneOfType( [PropTypes.string,PropTypes.number] )&#125;class Father extends React.Component&#123; render()&#123; //分别渲染数字的11和字符串的11 return (&lt;div&gt; &lt;Son number = &#123;&apos;字符串11&apos;&#125;/&gt; &lt;Son number = &#123;11&#125;/&gt; &lt;/div&gt;) &#125;&#125; 这时候，因为在类型检测中，number属性的规定类型包括字符串和数字两种，所以此时控制台无报错 当然，如果你改为number = {数组或其他类型的变量}，那么这时就会报错了 通过oneOf实现多选择检测——可规定多个检测通过的变量的值oneOfType是规定了多个可检测通过的数据类型，那么同样的道理，我们也可以规定多个可检测通过的变量的值，这就要用到PropTypes里的oneOf方法，和PropTypes方法一样oneOf方法接收参数的是一个数组，数组元素是你希望检测通过的变量的值，比如我们把上面类型检测的部分改成：12345Son.propTypes = &#123; number:PropTypes.oneOf( [12,13] )&#125; 那么运行时就会报这样一段错误： arrayOf,objectOf实现多重嵌套检测试想一下，如果我们检测的是基本类型的变量，那么这自然是很简单的，但当我们要检测的是一个引用类型的变量呢？当我们除了检测这个变量是否符合规定的引用类型外（Object/array），还想要进一步检测object中的属性变量或array中数组元素的数据类型时，单靠上面的方法已经不能满足要求了。这时候就要用到PropTypes的arrayOf，objectOf方法。 arrayOf接收一个参数，这个参数是规定的数组元素的数据类型。objectOf接收的参数则是属性的数据类型 我们对上述例子做些修改： 12345678910111213141516171819import React from &apos;react&apos;import PropTypes from &apos;prop-types&apos;;class Son extends React.Component&#123; render()&#123; return (&lt;div style =&#123;&#123;padding:30&#125;&#125;&gt; &#123;this.props.array&#125; &lt;/div&gt;) &#125;&#125;Son.propTypes = &#123; array:PropTypes.arrayOf(PropTypes.number)&#125;class Father extends React.Component&#123; render()&#123; return (&lt;div&gt; &lt;Son array = &#123;[1,2,3,4]&#125;/&gt; &lt;/div&gt;)&#125;&#125; 正常渲染，然后我们把改为&lt;Son array = {[‘1’,’2’,’3’,’4’]}/&gt;，报错 【注意】虽然报错但是这并不会影响程序的正常运行（譬如上面我们看到渲染仍然是正常的），因为本质上说类型检测报的是非致命性错误warning而不是致命性错误error（区别在于是否影响了正常运行）。对objectOf也是同样的做法 通过shape方法检测目标对象不同属性的不同数据类型如果你认真思考一下的话，你会发现3.4中的objectOf有一个缺陷，就是它内部的属性的数据类型被强行规定为一种，但通常一个对象里应该是有多种不同类型的属性了，那么这时候objectOf就不符合要求了，我们应该使用shape方法，其用法：12345PropTypes.shape(&#123; 属性1：类型1， 属性2：类型2， //...&#125;), 举个例子：123456789101112131415161718192021222324import React from &apos;react&apos;import PropTypes from &apos;prop-types&apos;;class Son extends React.Component&#123; render()&#123; return (&lt;div style =&#123;&#123;padding:30&#125;&#125;&gt; &#123;&apos;我的名字叫&apos; + this.props.object.name&#125; &lt;br/&gt; &#123;&apos;我的年龄是&apos; + this.props.object.age&#125; &lt;/div&gt;) &#125;&#125;Son.propTypes = &#123; object:PropTypes.shape(&#123; name:PropTypes.string, age:PropTypes.number &#125;)&#125;class Father extends React.Component&#123; render()&#123; return (&lt;div&gt; &lt;Son object = &#123;&#123;name:&apos;彭湖湾&apos;,age:20&#125;&#125;/&gt; &lt;/div&gt;) &#125;&#125; 结果无报错 1234//&lt;Son object = &#123;&#123;name:&apos;彭湖湾&apos;,age:20&#125;&#125;/&gt;//改成&lt;Son object = &#123;&#123;name:&apos;彭湖湾&apos;,age:&apos;20&apos;&#125;&#125;/&gt; 然后就能喜闻乐见得报错了 通过isRequired检测props中某个必要的属性（如果该属性不存在就报错）有时候，我们在对某个变量进行类型检测时，我们不仅要求它符合预期的类型，同时也要求它是必须写入的，这时候就要用到isRequired。 【分析】 123Son.propTypes = &#123; number:PropTypes.number&#125; 这段代码的作用是当你在props中写入number属性且number属性类型错误时给予报错提示，可如果你压根就没有写入number属性呢？没错，什么错误都不会报。这就是使用isRequired的必要性 【栗子】 12345678910111213141516171819import React from &apos;react&apos;import PropTypes from &apos;prop-types&apos;;class Son extends React.Component&#123; render()&#123; return (&lt;div style =&#123;&#123;padding:30&#125;&#125;&gt; &#123;this.props.number&#125; &lt;/div&gt;) &#125;&#125;Son.propTypes = &#123; number:PropTypes.number&#125;class Father extends React.Component&#123; render()&#123; return (&lt;div&gt; &lt;Son /&gt; &lt;/div&gt;) &#125;&#125; 控制台无任何输出 如果我们改成：123Son.propTypes = &#123; number:PropTypes.number.isRequired&#125; 再运行，我们就又可以喜闻乐见得看到错误了： 【注意】在这里给大家提个问题：我们上述的写法是number:PropTypes.number.isRequired，这要求number是数字类型，但如果你不想控制number的类型而仅仅是想控制它的必要性呢？难道写成number:isRequired或number:PropTypes.isRequired? 这个时候PropTypes.any就登场啦！它代表了该变量可取任何一种数据类型，所以你可以写成这样——number: PropTypes.any.isRequired 应对更复杂的类型检测——将PropTypes的属性值写成函数1234567Son.propTypes = &#123; prop:function(props,propName,componentName)&#123; if(/*判断条件*/)&#123; return new Error(/*错误的参数*/) &#125; &#125;&#125; 在属性prop的类型检测中，属性值是一个函数，在这里props是包含prop的props对象，propName是prop的属性名，componentName是props所在的组件名称，函数的返回值是一个Error对象 1234567891011121314151617181920212223import React from &apos;react&apos;import PropTypes from &apos;prop-types&apos;;class Son extends React.Component&#123; render()&#123; return (&lt;div style =&#123;&#123;padding:30&#125;&#125;&gt; &#123;this.props.email&#125; &lt;/div&gt;) &#125;&#125;Son.propTypes = &#123; email:function(props,propName,componentName)&#123; if(!/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(.[a-zA-Z0-9_-])+/.test(props[propName]))&#123; return new Error(&apos;组件&apos; + componentName+ &apos;里的属性&apos; + propName + &apos;不符合邮箱的格式&apos;); &#125; &#125;&#125;class Father extends React.Component&#123; render()&#123; return (&lt;div&gt; &lt;Son email = &#123;851393736&#125;/&gt; &lt;/div&gt;) &#125;&#125; 在这里我们利用正则表达式检测传递到Son组件的email属性是否符合邮箱格式，如果不符合就抛出错误，那么851393736显然不符合这一要求，所以我们就得到下面的demo:(其实加上qq.com就是我的邮箱啦 哈哈) ES7下类型检测的新写法：可能你觉得把propTypes写在类外看起来有些怪怪的，在ES7的静态类属性的支持下，你可以这样写：12345678class Son extends React.Component&#123;static propTypes = &#123; //..类型检测&#125;render()&#123; return (/* 渲染*/) &#125;&#125; 但注意，这在ES7下生效 props-types的独立与react.PropTypes的弃用在上面我是利用props-types这个独立的第三方库来进行类型检测的，但在不久前（react V15.5以前），它使用的是react内置的类型检测，而不是第三方库（也就是说我们现在的prop-types是当初以react内置的PropTypes对象为基础分离出来的） 翻译成中文就是： 所以说在你也可以这样进行类型检测，虽然并不推荐（为了保持向下兼容这在最新版本的react上仍然是可用的）123Son.propTypes = &#123; number:React.PropTypes.number&#125; 参考资料：react官方文档/高级指导/类型检测（docs/advanced guide/Typechecking with propTypes）https://facebook.github.io/react/docs/typechecking-with-proptypes.html","tags":[{"name":"prop-types","slug":"prop-types","permalink":"http://tawen.github.io/tags/prop-types/"}]},{"title":"强大的 Webpack","date":"2017-04-30T02:03:05.000Z","path":"2017/04/30/blog20170430/","text":"背景Webpack 已经随着 react 火了一段时间，不得不说前端的变化十分的快。每年都有新东西出来，Webpack 还没有玩热，又来了一个rollup，号称是下一代的打包工具。对前端来说，一涉及到性能，开发方式，打包就是一个回避不了的问题，在前端还没有这么百花齐放的过去也是这样。最早的时候用各种后台语言写的 combo 合并工具，后来是 ant，还有 Google closure compiler，再后来node 开始发展起来，随后伴随着node 的生态圈 Grunt Gulp 国内的 Fis 都开始流行起来。来到如今已经是一个百花齐放百家争鸣的好时代，任何优秀的工具都可以流行起来。早在前端 Bigpipe 技术被提出的时候，模块化开发的雏形就已经奠定，后来代码组织方式从早期的命名空间，到后来Commonjs规范，AMD 规范，以及国内的 CMD 规范都是为了解决代码如何模块化开发的问题。ES6规范的发布给了前端模块化开发先天的支持，意味着前端模块化开发可以通过各种辅助工具进入到下一个时代。 早在Webpack 刚刚发布我就尝试了一下，当时几乎没有中文资料，偶尔国内 React社区 能翻到一下开荒的文章，自己花费了一些时间跑起来，但是很快也就被自己抛到脑后还是继续使用gulp。现在回想起来很大原因还是开发方式的问题，当时还没有使用 Babel 和 ES6, 也没有在代码中时刻 import 的习惯。所以可见每个工具其实是和开发方式和代码组织密切分不开的，近来模块化大行其道，各种前端MVVM 框架层出不穷，Webpack 已经成为项目工程化的标配。最近也开始在项目中使用Vue + Vuex + ES6 + Webpack 真实感受到了webpack 的各种便利。 Webpack Introduction官方的介绍是 MODULE BUNDLER (模块打包器), 就是一个打包工具。从官方的定义来看似乎很纯粹，就是一个打包工具其他的事情Webpack不管，但实际上通过Webpack可以 模块打包webpack 会从入口开始去分析你的模块依赖从而把你的代码合并在一起生成一个文件，或是多个。 模块化开发webpack 视万物为模块，无论是 js 还是 css 还是 图片，字体，以及其他资源，Webpack 都可以使用的简单的一句import 或是require 就可以让你在项目中使用你的引入的资源 处理资源webpack 使用各种loader 来处理资源，常见的loader比如 style-loader, css-loader, less-loader, bable-loader, url-loader 框架相关的loader比如：jsx-loader, vue-loader 压缩，混淆 es6, js使用bable-loader 来转换 es6 的语法可以使用 eslint-loader 验证你的js，官方提供 UglifyJsPlugin 插件来压缩混淆js 处理css，less, sass, postcss可以通过 postcss-loader 来预处理css，比如加上css 属性的不同浏览器前缀 处理图片，字体可以通过 url-loader 来把不需要外链的资源统统转为base64编码可以使用第三方插件 ImageminPlugin 对所有图片进行压缩 自动合并共用代码webpack 的官方插件 CommonsChunkPlugin，你可以自由控制粒度 搭建开发服务器使用 webpack-dev-server或使用 koa/express + webpack-hot-middle + webpack-dev-middle 自动刷新浏览器liveloading小意思，webpack可以模块热更新，就是说局部更改代码比你刷新浏览器更快 最小化引入资源下一代 rollup 的打包工具最耀眼的功能就是支持 treeshaking 了，而 webpack 2.0 也支持 Webpack 还有很多有用的功能：解析资源别名使你不用在import 后面写一大长串路径。你担心调试的时候找不到哪行代码，可以使用devtool的 sourcemap。如果你不想你的css 打包到js 里你可以使用 ExtractTextPlugin 来抽取css。你也可以配合 http-proxy-middleware 来做远程接口转发，由于开发的时候静态资源服务器是node，所以有各式各样的 middleware 来满足你的各种需求。 Webpack 强大和灵活的地方是他的 plugin 和 loader，通过 loader 可以很轻易的对任何匹配的资源做操作，通过 plugin 则可以参与处理打包的阶段。再者他还提供了 middleware 的方式，可以配合 koa, express 一起使用。","tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://tawen.github.io/tags/Webpack/"}]},{"title":"浅谈CSRF攻击方式","date":"2017-04-10T08:55:05.000Z","path":"2017/04/10/blog20170410/","text":"CSRF是什么？CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 CSRF可以做什么？你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 CSRF漏洞现状CSRF这种攻击方式在2000年已经被国外的安全人员提出，但在国内，直到06年才开始被关注，08年，国内外的多个大型社区和交互网站分别爆出CSRF漏洞，如：NYTimes.com（纽约时报）、Metafilter（一个大型的BLOG网站），YouTube和百度HI……而现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”。 CSRF的原理下图简单阐述了CSRF攻击的思想： 从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤： 1.登录受信任网站A，并在本地生成Cookie。 2.在不登出A的情况下，访问危险网站B。 看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生： 1.你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。 2.你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……） 3.上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。 上面大概地讲了一下CSRF攻击的思想，下面我将用几个例子详细说说具体的CSRF攻击，这里我以一个银行转账的操作作为例子（仅仅是例子，真实的银行网站没这么傻:&gt;） 示例1： 银行网站A，它以GET请求来完成银行转账的操作，如：http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000 危险网站B，它里面有一段HTML的代码如下：1&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。在访问危险网站B的之前，你已经登录了银行网站A，而B中的以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取资源“http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000”，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作...... 示例2： 为了杜绝上面的问题，银行决定改用POST请求完成转账操作。 银行网站A的WEB表单如下： 12345 &lt;form action=&quot;Transfer.php&quot; method=&quot;POST&quot;&gt; &lt;p&gt;ToBankId: &lt;input type=&quot;text&quot; name=&quot;toBankId&quot; /&gt;&lt;/p&gt; &lt;p&gt;Money: &lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Transfer&quot; /&gt;&lt;/p&gt; &lt;/form&gt; 后台处理页面Transfer.php如下： 1234567 &lt;?php session_start(); if (isset($_REQUEST[&apos;toBankId&apos;] &amp;&amp; isset($_REQUEST[&apos;money&apos;])) &#123; buy_stocks($_REQUEST[&apos;toBankId&apos;], $_REQUEST[&apos;money&apos;]); &#125; ?&gt; 危险网站B，仍然只是包含那句HTML代码：1&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 和示例1中的操作一样，你首先登录了银行网站A，然后访问危险网站B，结果…..和示例1一样，你再次没了1000块～T_T，这次事故的原因是：银行后台使用了$_REQUEST去获取请求的数据，而$_REQUEST既可以获取GET请求的数据，也可以获取POST请求的数据，这就造成了在后台处理程序无法区分这到底是GET请求的数据还是POST请求的数据。在PHP中，可以使用$_GET和$_POST分别获取GET请求和POST请求的数据。在JAVA中，用于获取请求数据request一样存在不能区分GET请求数据和POST数据的问题。 示例3： 经过前面2个惨痛的教训，银行决定把获取请求数据的方法也改了，改用$_POST，只获取POST请求的数据，后台处理页面Transfer.php代码如下：1234567&lt;?php session_start(); if (isset($_POST[&apos;toBankId&apos;] &amp;&amp; isset($_POST[&apos;money&apos;])) &#123; buy_stocks($_POST[&apos;toBankId&apos;], $_POST[&apos;money&apos;]); &#125; ?&gt; 然而，危险网站B与时俱进，它改了一下代码： 1234567891011121314151617181920&lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot;&gt; function steal() &#123; iframe = document.frames[&quot;steal&quot;]; iframe.document.Submit(&quot;transfer&quot;); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;steal()&quot;&gt; &lt;iframe name=&quot;steal&quot; display=&quot;none&quot;&gt; &lt;form method=&quot;POST&quot; name=&quot;transfer&quot; action=&quot;http://www.myBank.com/Transfer.php&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;toBankId&quot; value=&quot;11&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;money&quot; value=&quot;1000&quot;&gt; &lt;/form&gt; &lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 如果用户仍是继续上面的操作，很不幸，结果将会是再次不见1000块……因为这里危险网站B暗地里发送了POST请求到银行! 总结一下上面3个例子，CSRF主要的攻击模式基本上是以上的3种，其中以第1,2种最为严重，因为触发条件很简单，一个就可以了，而第3种比较麻烦，需要使用JavaScript，所以使用的机会会比前面的少很多，但无论是哪种情况，只要触发了CSRF攻击，后果都有可能很严重。 理解上面的3种攻击模式，其实可以看出，CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！ 五.CSRF的防御 我总结了一下看到的资料，CSRF的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。 1.服务端进行CSRF防御 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。 (1).Cookie Hashing(所有表单都包含同一个伪随机值)： 这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了:&gt;12345&lt;?php //构造加密的Cookie信息 $value = “DefenseSCRF”; setcookie(”cookie”, $value, time()+3600); ?&gt; 在表单里增加Hash值，以认证这确实是用户发送的请求。 123456789 &lt;?php $hash = md5($_COOKIE[&apos;cookie&apos;]); ?&gt; &lt;form method=”POST” action=”transfer.php”&gt; &lt;input type=”text” name=”toBankId”&gt; &lt;input type=”text” name=”money”&gt; &lt;input type=”hidden” name=”hash” value=”&lt;?=$hash;?&gt;”&gt; &lt;input type=”submit” name=”submit” value=”Submit”&gt; &lt;/form&gt; 然后在服务器端进行Hash值验证 123456789101112&lt;?php if(isset($_POST[&apos;check&apos;])) &#123; $hash = md5($_COOKIE[&apos;cookie&apos;]); if($_POST[&apos;check&apos;] == $hash) &#123; doJob(); &#125; else &#123; //... &#125; &#125; else &#123; //... &#125;?&gt; 这个方法个人觉得已经可以杜绝99%的CSRF攻击了，那还有1%呢….由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，这就另外的1%。一般的攻击者看到有需要算Hash值，基本都会放弃了，某些除外，所以如果需要100%的杜绝，这个不是最好的方法。 (2).验证码 这个方案的思路是：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，厄….这个方案可以完全解决CSRF，但个人觉得在易用性方面似乎不是太好，还有听闻是验证码图片的使用涉及了一个被称为MHTML的Bug，可能在某些版本的微软IE中受影响。 (3).One-Time Tokens(不同的表单包含一个不同的伪随机值) 在实现One-Time Tokens时，需要注意一点：就是“并行会话的兼容”。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。 以下我的实现: 1).先是令牌生成函数(gen_token())：1234567&lt;?php function gen_token() &#123; //这里我是贪方便，实际上单使用Rand()得出的随机数作为令牌，也是不安全的。 //这个可以参考我写的Findbugs笔记中的《Random object created and used only once》 $token = md5(uniqid(rand(), true)); return $token; &#125; 2).然后是Session令牌生成函数(gen_stoken())： 123456789101112&lt;?php function gen_stoken() &#123; $pToken = &quot;&quot;; if($_SESSION[STOKEN_NAME] == $pToken)&#123; //没有值，赋新值 $_SESSION[STOKEN_NAME] = gen_token(); &#125; else&#123; //继续使用旧的值 &#125; &#125;?&gt; 3).WEB表单生成隐藏输入域的函数： 1234567&lt;?php function gen_input() &#123; gen_stoken(); echo “&lt;input type=\\”hidden\\” name=\\”&quot; . FTOKEN_NAME . “\\” value=\\”&quot; . $_SESSION[STOKEN_NAME] . “\\”&gt; “; &#125;?&gt; 4).WEB表单结构： 12345678910&lt;?php session_start(); include(”functions.php”);?&gt;&lt;form method=”POST” action=”transfer.php”&gt; &lt;input type=”text” name=”toBankId”&gt; &lt;input type=”text” name=”money”&gt; &lt;? gen_input(); ?&gt; &lt;input type=”submit” name=”submit” value=”Submit”&gt;&lt;/FORM&gt; 5).服务端核对令牌： 这个很简单，这里就不再啰嗦了。 上面这个其实不完全符合“并行会话的兼容”的规则，大家可以在此基础上修改。","tags":[{"name":"CSRF（Cross-site request forgery）","slug":"CSRF（Cross-site-request-forgery）","permalink":"http://tawen.github.io/tags/CSRF（Cross-site-request-forgery）/"}]},{"title":"tippyjs - 一个小巧的纯 JS 的 Tooltip 开源库","date":"2017-04-06T12:55:05.000Z","path":"2017/04/06/blog20170406/","text":"Description:Tippy.js is a small yet highly customizable JavaScript tooltip library that helps you add customizable, interactive, animated tooltips to any DOM elements. Key features: Supports all positions: top, right, bottom, left Custom trigger events: mouseenter, focus, click or manual. 4 built-in amazing animations: shift, perspective, fade or scale. Light &amp; dark themes. Allows to embed any html markup inside the tooltip. Useful callback functions. Install it via NPM:1$ npm install tippy Basic usage:Insert the JavaScript and CSS files as displayed below into your html document.12&lt;link rel=&quot;stylesheet&quot; href=&quot;css/tippy.css&quot;&gt;&lt;script src=&quot;js/tippy.js&quot;&gt;&lt;/script&gt; Add the ‘tippy’ class to your element and define the tooltip content using ‘title’ attribute like this:1&lt;span class=&quot;tippy&quot; title=&quot;I&apos;m a tooltip!&quot;&gt;Hover Me&lt;/span&gt; Initialize the tooltip library by creating a new Tippy object as this:1new Tippy(&apos;.tippy&apos;) Config the tooltip using the following options. Note that all the options as listed below are allowed to be passed via JavaScript:1234567891011121314new Tippy(&apos;.tippy&apos;, &#123; html: false, position: &apos;top&apos;, animation: &apos;shift&apos;, animateFill: true, arrow: false, delay: 0, trigger: &apos;mouseenter focus&apos;, duration: 400, interactive: false, theme: &apos;dark&apos;, offset: 0, hideOnClick: true&#125;) Or via HTML ‘data’ attributes:12345&lt;span class=&quot;tippy&quot; title=&quot;I&apos;m a tooltip!&quot; data-OPTION=&quot;VALUE&quot;&gt; Hover Me&lt;/span&gt; Callback functions available:12345678910111213141516171819new Tippy(&apos;.tippy&apos;, &#123; beforeShown: function() &#123; // When the tooltip has been triggered and has started to transition in &#125;, shown: function() &#123; // When the tooltip has fully transitioned in and is showing &#125;, beforeHidden: function() &#123; // When the tooltip has begun to transition out &#125;, hidden: function() &#123; // When the tooltip has fully transitioned out and is hidden &#125; &#125;)","tags":[{"name":"tippyjs","slug":"tippyjs","permalink":"http://tawen.github.io/tags/tippyjs/"}]},{"title":"Javascript的jsonp原理","date":"2017-03-30T04:55:05.000Z","path":"2017/03/30/blog20170330/","text":"首先JSON是一种基于文本的数据交换方式，或者叫做数据描述格式当一个网页在请求JavaScript文件时则不受是否跨域的影响，凡是拥有”src”这个属性的标签都拥有跨域的能力，比如&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt; 所以我们这里运用了script标签的跨域能力，让它用一个callback函数包裹着一段JSON格式的数据，当该数据返回到前端页面的时候，我们再执行这个函数就可以把数据读取出来 Javascript的jsonp原理前端代码12345678910111213141516171819202122//jsonp.html&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Wsscat&apos;s jsonp&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;jsonpServer(&apos;jsonp.php&apos;)&quot;&gt;JSONP&lt;/button&gt; &lt;/body&gt; &lt;script&gt; function jsonpServer(url) &#123; var script = document.createElement(&quot;script&quot;); script.setAttribute(&quot;type&quot;, &quot;text/javascript&quot;); script.setAttribute(&quot;src&quot;, url); document.body.appendChild(script); &#125; function JSON_CALLBACK(data) &#123; console.log(data); &#125; &lt;/script&gt;&lt;/html&gt; 后端代码1234567//jsonp.php&lt;?php$data = &apos;[&#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;wsscat&quot;&#125;,&#123;&quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;asw&quot;&#125;]&apos;;$data = &quot;JSON_CALLBACK(&quot; . $data . &quot;)&quot;;echo $data;?&gt; jQuery的jsonp方法 type：请求方式 GET/POST url:请求地址 async:布尔类型，默认为true 表示请求是否为异步，如果为false表示为同步。 dataType：返回的数据类型 jsonp：传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback：自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写”?”，jQuery会自动为你处理数据 success：调用成功执行的函数 error：异常处理函数 js代码12345678910$.ajax(&#123; url:&apos;index.php&apos;, type:&apos;get&apos;, dataType:&apos;jsonp&apos;, //jsonp:&apos;JSON_CALLBACK&apos;, jsonpCallback:&apos;JSON_CALLBACK&apos;, success:function(data)&#123; console.log(data) &#125;&#125;) php代码12345&lt;?php $data = &apos;[&#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;wsscat&quot;&#125;,&#123;&quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;asw&quot;&#125;]&apos;; $data = &quot;JSON_CALLBACK(&quot; . $data . &quot;)&quot;; echo $data;?&gt;","tags":[{"name":"Javascript的jsonp原理","slug":"Javascript的jsonp原理","permalink":"http://tawen.github.io/tags/Javascript的jsonp原理/"}]},{"title":"Vue-cli proxyTable 解决开发环境的跨域","date":"2017-03-29T04:55:05.000Z","path":"2017/03/29/blog20170329/","text":"和后端联调时总是会面对恼人的跨域问题，最近基于Vue开发项目时也遇到了这个问题，两边各自想了一堆办法，查了一堆资料，加了一堆参数，最后还得我把自己的localhost映射成上线时将要使用的域名。今天翻看代码时，突然发现vue-cli的config文件里有一个参数叫proxyTable，看这个名字就感觉能解决问题，于是我就去搜了一下，果然。在vuejs-templates，也就是vue-cli的使用的模板插件里，有关于API proxy的说明，使用的就是这个参数。https://vuejs-templates.github.io/webpack/proxy.html这个参数主要是一个地址映射表，你可以通过设置将复杂的url简化，例如我们要请求的地址是api.xxxxxxxx.com/list/1，可以按照如下设置：12345678proxyTable: &#123; &apos;/list&apos;: &#123; target: &apos;http://api.xxxxxxxx.com&apos;, pathRewrite: &#123; &apos;^/list&apos;: &apos;/list&apos; &#125; &#125;&#125; 这样我们在写url的时候，只用写成/list/1就可以代表api.xxxxxxxx.com/list/1.那么又是如何解决跨域问题的呢？其实在上面的’list’的参数里有一个changeOrigin参数，接收一个布尔值，如果设置为true,那么本地会虚拟一个服务端接收你的请求并代你发送该请求，这样就不会有跨域问题了，当然这只适用于开发环境。增加的代码如下所示：123456789proxyTable: &#123; &apos;/list&apos;: &#123; target: &apos;http://api.xxxxxxxx.com&apos;, changeOrigin: true, pathRewrite: &#123; &apos;^/list&apos;: &apos;/list&apos; &#125; &#125;&#125; vue-cli的这个设置来自于其使用的插件http-proxy-middlewaregithub：https://github.com/chimurai/http-proxy-middleware深入了解的话可以看该插件配置说明，似乎还支持websocket，很强大的插件。","tags":[{"name":"Vue-cli proxyTable","slug":"Vue-cli-proxyTable","permalink":"http://tawen.github.io/tags/Vue-cli-proxyTable/"}]},{"title":"Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？","date":"2017-03-22T11:55:05.000Z","path":"2017/03/22/blog20170322/","text":"假如说我页面上有一个按钮，点击之后请求后端接口，然后将后端返回的json做相关处理之后写入vuex的state。 现在有两种写法： 一种是：“请求后端接口”这个ajax代码应该是写在按钮的点击事件处理函数中，然后在这个处理函数里面提交mutations 还一种是：直接将“请求后端接口”这个ajax代码写在actions中，actions中提交mutations，按钮的点击事件处理函数中只写一个分发actions的按钮 请问哪种写法更加合适而且优雅？ 另外还有一个疑问就是“将后端返回的json做相关处理”这个代码又应该是先处理好，然后将处理好的数据传入mutations，还是直接在mutations里面处理？ 我个人觉得后者代码量更大，感觉有点麻烦，但是不知道会不会在解耦合，追踪数据变化方面更好？ 我会把所有和服务端的交互写在 Actions 中（除非你和服务端的交互不需要界面反馈，比如前端打点的统计这种）其他情况下理论上你的页面的状态应该是和服务端一一对应的。所以把对后端的请求都通过 Actions 来封装，你业务代码里逻辑就只有对Action 的调用操作，更形象的就是直接对数据操作。而再不用管数据的返回之类的，因为数据返回直接会改变state，而state 的改变直接会触发 View 的更新。我觉得这个才是 vuex 和 前端单向数据流方便，提高效率的地方。总体的设计原则是Actions 是异步，处理业务逻辑的，而 Mutation 只是简单对state 的状态进行改变。通过这样你所有的组件进行的操作都可以和你的state 的状态一一对应，代码清晰简单。 我肯定会处理好再传入mutations，我的mutation-types 都非常的清晰就是 UPDATE_[XXX] ，ADD_[XXX] 所以除去必要的逻辑，如果有计算逻辑，或是其他格式化的逻辑，我肯定是做完以后，才调用 commit 你可以把state 理解为前端的共用数据库， mutations 这些是增删改，getters 是查，所以mutations 里的逻辑应该是越少越好，记得官网也有建议","tags":[{"name":"Vue.js中ajax请求","slug":"Vue-js中ajax请求","permalink":"http://tawen.github.io/tags/Vue-js中ajax请求/"}]},{"title":"ANT DESIGN 一个设计 & 前端框架 - React 用户的福音","date":"2017-03-20T04:55:05.000Z","path":"2017/03/20/blog20170320/","text":"原文链接：http://ant.design/ANT DESIGN 是蚂蚁金服体验技术部出品的一个设计&amp;前端框架，基于 React 框架。目前官网介绍的包括 CSS 和 Components 两大部分。 CSS 部分涵盖了基本的 Layout，Iconfont，Button，Motion。 组件非常丰富，有 Checkbox，Radio， Switch，Slider，Datepicker，Select，InputNumber，Tabs，Steps，Collapse，Pagination，Modal，Message，Dropdown，Popover，Popconfirm，Tooltip，Progress，Table。 不多说了，自己看吧 https://github.com/ant-design/ant-design —— 由Kuma Li分享 介绍一套企业级的前端设计语言和基于 React 的实现。 特性企业级金融产品的交互语言和视觉体系。丰富实用的 React UI 组件。基于 React 的组件化开发模式。背靠 npm 生态圈。基于 webpack 的调试构建方案，支持 ES6。 示例var antd = require(‘antd’);var Datepicker = antd.Datepicker; React.render(, mountNode); 链接 首页 文档 组件 构建调试工具 开发计划 React 模块 React 代码规范 组件设计原则 谁在使用蚂蚁金服 如何贡献我们欢迎任何形式的贡献，有任何建议或意见您可以进行 Pull Request，或者给我们 提问。","tags":[{"name":"ANT DESIGN","slug":"ANT-DESIGN","permalink":"http://tawen.github.io/tags/ANT-DESIGN/"}]},{"title":"常见的几种数组排序算法JS实现","date":"2017-03-14T06:26:05.000Z","path":"2017/03/14/blog20170314/","text":"快速排序 从给定的数据中，随机抽出一项，这项的左边放所有比它小的，右边放比它大的，然后再分别这两边执行上述操作，采用的是递归的思想，总结出来就是 实现一层，分别给两边递归，设置好出口 1234567891011121314151617181920212223242526272829303132333435function fastSort(array,head,tail)&#123; //考虑到给每个分区操作的时候都是在原有的数组中进行操作的，所以这里head,tail来确定分片的位置 /*生成随机项*/ var randomnum = Math.floor(ranDom(head,tail)); var random = array[randomnum]; /*将小于random的项放置在其左边 策略就是通过一个临时的数组来储存分好区的结果，再到原数组中替换*/ var arrayTemp = []; var unshiftHead = 0; for(var i = head;i &lt;= tail;i++)&#123; if(array[i]&lt;random)&#123; arrayTemp.unshift(array[i]); unshiftHead++; &#125;else if(array[i]&gt;random)&#123; arrayTemp.push(array[i]); &#125; /*当它等于的时候放哪，这里我想选择放到队列的前面，也就是从unshift后的第一个位置放置*/ if(array[i]===random)&#123; arrayTemp.splice(unshiftHead,0,array[i]); &#125; &#125; /*将对应项覆盖原来的记录*/ for(var j = head , u=0;j &lt;= tail;j++,u++)&#123; array.splice(j,1,arrayTemp[u]); &#125; /*寻找中间项所在的index*/ var nowIndex = array.indexOf(random); /*设置出口，当要放进去的片段只有2项的时候就可以收工了*/ if(arrayTemp.length &lt;= 2)&#123; return; &#125; /*递归，同时应用其左右两个区域*/ fastSort(array,head,nowIndex); fastSort(array,nowIndex+1,tail); &#125; 插入排序 思想就是在已经排好序的数组中插入到相应的位置，以从小到大排序为例，扫描已经排好序的片段的每一项，如大于，则继续往后，直到他小于一项时，将其插入到这项的前面 12345678910111213141516171819function insertSort(array)&#123; /*start根据已排列好的项数决定*/ var start=1; /*按顺序，每一项检查已排列好的序列*/ for(var i=start; i&lt;array.length; start++,i++)&#123; /*跟已排好序的序列做对比，并插入到合适的位置*/ for(var j=0; j&lt;start; j++)&#123; /*小于或者等于时（我们是升序）插入到该项前面*/ if(array[i]&lt;=array[j])&#123; console.log(array[i]+&apos; &apos;+array[j]); array.splice(j,0,array[i]); /*删除原有项*/ array.splice(i+1,1); break; &#125; &#125; &#125;&#125; 冒泡排序 故名思意 ，就是一个个冒泡到最前端或者最后端，主要是通过两两依次比较，以升序为例，如果前一项比后一项大则交换顺序，一直比到最后一对 12345678910111213function bubbleSort(array)&#123; /*给每个未确定的位置做循环*/ for(var unfix=array.length-1; unfix&gt;0; unfix--)&#123; /*给进度做个记录，比到未确定位置*/ for(var i=0; i&lt;unfix;i++)&#123; if(array[i]&gt;array[i+1])&#123; var temp = array[i]; array.splice(i,1,array[i+1]); array.splice(i+1,1,temp); &#125; &#125; &#125; &#125; 选择排序 将当前未确定块的min或者max取出来插到最前面或者后面 123456789101112131415161718function selectSort(array)&#123; /*给每个插入后的未确定的范围循环，初始是从0开始*/ for(var unfixed=0; unfixed&lt;array.length; unfixed++)&#123; /*设置当前范围的最小值和其索引*/ var min = array[unfixed]; var minIndex = unfixed; /*在该范围内选出最小值*/ for(var j=unfixed+1; j&lt;array.length; j++)&#123; if(min&gt;array[j])&#123; min = array[j]; minIndex = j; &#125; &#125; /*将最小值插入到unfixed，并且把它所在的原有项替换成*/ array.splice(unfixed,0,min); array.splice(minIndex+1,1); &#125; &#125;","tags":[{"name":"前端优化","slug":"前端优化","permalink":"http://tawen.github.io/tags/前端优化/"}]},{"title":"雅虎前端优化35条规则翻译","date":"2017-03-13T02:23:05.000Z","path":"2017/03/13/blog20170313/","text":"原文： Best Practices for Speeding Up Your Web Site。 如何让web页面更快，雅虎团队实践总结了7类35条规则，下面一一列出。 1. Content1.1 Make Fewer HTTP RequestsMinimize HTTP Requests减少/最小化 http 请求数。 到终端用户的响应时间80%花在前端：大部分用于下载组件（js/css/image/flash等等）。减少组件数就是减少渲染页面所需的http请求数。这是更快页面的关键。 减少组件数的一个方法就是简化页面设计。保持富内容的页面且能减少http请求，有以下几个技术： Combined files。合并文件，如合并js，合并css都能减少请求数。如果页面间脚本和样式差异很大，合并会更具挑战性。 CSS Sprites。雪碧图可以合并多个背景图片，通过background-image 和 background-position 来显示不同部分。 Image maps。合并多个图片到一个图片，一般用于如导航条。由于定义坐标的枯燥和易错，一般不推荐。 Inline images。使用data:url scheme来內连图片。 减少请求数是为第一次访问页面的用户提高性能的最重要的指导。 1.2 Reduce DNS Lookups减少DNS查询。 就像电话簿，你在浏览器地址栏输入网址，通过DNS查询得到网站真实IP。 DNS查询被缓存来提高性能。这种缓存可能发生在特定的缓存服务器（ISP/local area network维护），或者用户的计算机。DNS信息留存在操作系统DNS缓存中（在windows中就是 DNS Client Serve ）。大多浏览器有自己的缓存，独立于操作系统缓存。只要浏览器在自己的缓存里有某条DNS记录，它就不会向操作系统发DNS解析请求。 IE默认缓存DNS记录30分钟，FireFox默认缓存1分钟。 当客户端的DNS缓存是空的，DNS查找次数等于页面中的唯一域名数。 减少DNS请求数可能会减少并行下载数。避免DNS查找减少响应时间，但减少并行下载数可能会增加响应时间。指导原则是组件可以分散在至少2个但不多于4个的不同域名。这是两者的妥协。 1.3 Avoid Redirects避免跳转。 跳转用301或302状态码来达成。一个301响应http头的例子： 123HTTP/1.1 301 Moved PermanentlyLocation: http://example.com/newuriContent-Type: text/html 最浪费的跳转之一发生在url尾部slash（/）缺失。比如http://astrology.yahoo.com/astrology会301跳转到http://astrology.yahoo.com/astrology/。这可以被Apache等服务器修复，用Alias，mod_rewrite等等。 1.4 Make Ajax Cacheable让Ajax可缓存。 使用ajax的好处是可以向用户提供很快的反馈，因为它是向后台异步请求数据。但是，这些异步请求不保证用户等待的时间——异步不意味着瞬时。 提高ajax性能的最重要的方法是让响应被缓存，即在Add an Expires or a Cache-Control Header中讨论的 Expires 。其它方法是： gzip组件 减少DNS查找 压缩JS 避免跳转 设置ETags 1.5 Post-load Components延迟加载组件。 再看看你的页面然后问问自己，“什么是页面初始化必须的？”。剩下的内容和组件可以延迟。 JavaScript是理想的（延迟）候选者，可以切分到onload事件之前和之后。比如拖放的js库可以延迟，因为拖动必须在页面初始化之后。其它可延迟的包括隐藏的内容，折叠起来的图片等等。 1.6 Preload Components预加载组件。 预加载看起来与延迟加载相反，但它的确有个不同的目标。通过预加载你可以利用浏览器的空闲时间来请求你将来会用到的组件。这样当用户访问下一个页面时，你会有更多的组件已经在缓存中，这样会极大加快页面加载。 有几种预加载类型： 无条件预加载：一旦onload触发，你立即获取另外的组件。比如谷歌会在主页这样加载搜索结果页面用到的雪碧图。 有条件预加载：基于用户动作，你推测用户下一步会去哪里并加载相应组件。 预期的预加载：在发布重新设计（的网站）前提前加载。在旧网页预加载新网页的部分组件，那么切换到新网页时就不会是没有任何缓存了。 1.7 Reduce the Number of DOM Elements减少dom数。 一个复杂的页面意味着更多的内容要下载，以及更慢的dom访问。比如在有500dom数量的页面添加事件处理就和有5000dom数量的不同。 如果你的页面dom元素很多，那么意味着你可能需要删除无用的内容和标签来优化。 1.8 Split Components Across Domains把组件分散到不同的域名。 把组件分散到不同的域名允许你最大化并行下载数。由于DNS查询的副作用，最佳的不同域名数是2-4。 1.9 Minimize the Number of iframes最小化iframe的数量。 iframe允许html文档被插入到父文档。iframe优点： 帮助解决缓慢的第三方内容的加载，如广告和徽章 安全沙盒 并行下载脚本 iframe缺点： 即使空的也消耗（资源和时间） 阻塞了页面的onload 非语义化（标签） 1.10 No 404s不要404。 http请求是昂贵的，所以发出http请求但获得没用的响应（如404）是完全不必要的，并且会降低用户体验。 一些网站会有特别的404页面提高用户体验，但这仍然会浪费服务器资源。特别坏的是当链接指向外部js但却得到404结果。这样首先会降低（占用）并行下载数，其次浏览器可能会把404响应体当作js来解析，试图从里面找出可用的东西。 2. Server2.1 Use a Content Delivery Network使用CDN。 用户接近你的服务器会减少响应时间。把你的内容发布到多个，地理上分散的服务器可以让页面加载更快。但怎么开始？ 首先不要试图把你的架构重新设计成分布式架构。因为可能引进更多复杂性和不可控。 记住80-90%的终端用户响应时间花费在下载页面中的所有组件：图片、样式、脚本、falsh等等。这是Performance Golden Rule。不要从困难的重新设计后台架构开始，最好首先分发你的静态内容。这不仅可以减少响应时间，用CDN还很容易来做。 CDN是一群不同地点的服务器，可以更高效地分发内容到用户。一些大公司有自己的CDN。 2.2 Add an Expires or a Cache-Control Header加Expires或者Cache-Control头部。 这条规则有两个方面： 对静态组件：通过设置Expires头部来实现“永不过期”策略。 对动态组件：用合适的Cache-Control头部来帮助浏览器进行有条件请求。 页面越来越丰富，意味着更多脚本，样式，图片等等。第一次访问的用户可能需要发出多个请求，但使用Expires可以让这些组件被缓存。这避免了访问子页面时没必要的http请求。Expires一般用在图片上，但应该用在所有的组件上。 浏览器（以及代理）使用缓存来减少http请求数，加快页面加载。服务器使用http响应的Expires头部来告诉客户端一个组件可以缓存多久。比如下面： 1Expires: Thu, 15 Apr 2010 20:00:00 GMT //2010-04-15之前都是稳定的 注意，如果你设置了Expires头部，当组件更新后，你必须更改文件名。 2.3 Gzip Components传输时用gzip等压缩组件。 http请求或响应的传输时间可以被前端工程师显著减少。终端用户的带宽，ISP，接近对等交换点等等没法被开发团队控制，但是，压缩可以通过减少http响应的大小减少响应时间。 从HTTP/1.1开始，客户端通过http请求中的Accept-Encoding头部来提示支持的压缩： 1Accept-Encoding: gzip, deflate 如果服务器看到这个头部，它可能会选用列表中的某个方法压缩响应。服务器通过Content-Encoding头部提示客户端： 1Content-Encoding: gzip gzip一般可减小响应的70%。尽可能去gzip更多（文本）类型的文件。html，脚本，样式，xml和json等等都应该被gzip，而图片，pdf等等不应该被gzip，因为它们本身已被压缩过，gzip它们只是浪费cpu，甚至增加文件大小。 2.4 Configure ETags实体标记（Entity tags，ETag）是服务器和浏览器之间判断浏览器缓存中某个组件是否匹配服务器端原组件的一种机制。实体就是组件：图片，脚本，样式等等。ETag被当作验证实体的比最后更改（last-modified）日期更高效的机制。服务器这样设置组件的ETag：1234HTTP/1.1 200 OKLast-Modified: Tue, 12 Dec 2006 03:03:59 GMTETag: &quot;10c24bc-4ab-457e1c1f&quot;Content-Length: 12195 之后，如果浏览器要验证组件，它用If-None-Match头部来传ETag给服务器。如果ETag匹配，服务器返回304： 12345GET /i/yahoo.gif HTTP/1.1Host: us.yimg.comIf-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMTIf-None-Match: &quot;10c24bc-4ab-457e1c1f&quot;HTTP/1.1 304 Not Modified ETag的问题是它们被构造来使它们对特定的运行这个网站的服务器唯一。浏览器从一个服务器获取组件，之后向另一个服务器验证，ETag将不匹配。然而服务器集群是处理请求的通用解决方案。 如果不能解决多服务器间的ETag匹配问题，那么删除ETag可能更好。 2.5 Flush the Buffer Early早一点刷新buffer（尽早给浏览器数据）。 当用户请求一个页面，服务器一般要花200-500ms来拼凑整个页面。这段时间，浏览器是空闲的（等数据返回）。在php，有个方法flush()允许你传输部分准备好的html响应给浏览器。这样的话浏览器就可以开始下载组件，而同时后台可以继续生成页面剩下的部分。这种好处更多是在忙碌的后台或轻前端网站可以看到。 一个比较好的flush的位置是在head之后，因为浏览器可以加载其中的样式和脚本文件，而后台继续生成页面剩余部分。12345&lt;!-- css, js --&gt;&lt;/head&gt;&lt;?php flush(); ?&gt;&lt;body&gt;&lt;!-- content --&gt; 2.6 Use GET for AJAX Requestsajax请求用get。 Yahoo! Mail团队发现当使用XMLHttpRequest，POST 被浏览器实现为两步：首先发送头部，然后发送数据。所以使用GET最好，仅用一个TCP包发送（除非cookie太多）。IE的url长度限制是2K。 POST但不提交任何数据根GET行为类似，但从语义上讲，获取数据应该用GET，提交数据到服务器用POST。 2.7 Avoid Empty Image src避免空src的图片。 空src属性的图片的行为可能跟你预期的不一样。它有两种形式：12html标签：&lt;img src=&quot;&quot;&gt;js：var img = new Image(); img.src = &quot;&quot;; 两种都会造成同一种后果：浏览器会向你的服务器发请求。 IE，向页面所在的目录发请求。 Safari和Chrome，请求实际的页面。 FireFox3及之前和Safari/Chrome一样，但从3.5开始修复问题，不再发请求。 Opera遇到空图片src不做任何事。 为什么这种行为很糟糕？ 由于发送大量的意料之外的流量，会削弱服务器，尤其那些每天pv上百万的页面。浪费服务器计算周期取生成不会被浏览的页面。可能会破坏用户数据。如果你在跟踪请求状态，通过cookie或其它，你可能会破坏数据。即使image的请求不会返回图片，但所有的头部数据都被浏览器读取了，包括cookie。即使剩下的响应体被丢弃，破坏可能已经发生。 这种行为的根源是uri解析发生在浏览器。RFC 3986 定义了这种行为，空字符串被当作相对路径，Firefox, Safari, 和 Chrome都正确解析，而IE错误。总之，浏览器解析空字符串为相对路径的行为被认为是符合预期的。 html5在4.8.2添加了对标签src属性的描述，指导浏览器不要发出额外的请求。 The src attribute must be present, and must contain a valid URL referencing a non-interactive, optionally animated, image resource that is neither paged nor scripted. If the base URI of the element is the same as the document’s address, then the src attribute’s value must not be the empty string. 幸运的是将来浏览器不会有这个问题了（在图片上）。不幸的是，&lt;script src=&quot;&quot;&gt;和&lt;link href=&quot;&quot;&gt;没有这样的规范。 3 Cookie3.1 Reduce Cookie Sizehttp cookie的使用有多种原因，比如授权和个性化。cookie的信息通过http头部在浏览器和服务器端交换。尽可能减小cookie的大小来降低响应时间。 消除不必要的cookie。 尽可能减小cookie的大小来降低响应时间。 注意设置cookie到合适的域名级别，则其它子域名不会被影响。 正确设置Expires日期。早一点的Expires日期或者没有会尽早删除cookie，优化响应时间。* 3.2 Use Cookie-free Domains for Components用没有cookie的域名提供组件。 当浏览器请求静态图片并把cookie一起发送到服务器时，cookie此时对服务器没什么用处。所以这些cookie只是增加了网络流量。所以你应该保证静态组件的请求是没有cookie的。可以创建一个子域名来托管所有静态组件。 比如，你域名是www.example.org，可以把静态组件托管在static.example.org。不过，你如果把cookie设置在顶级域名example.org下，这些cookie仍然会被传给static.example.org。这种情况下，启用一个全新的域名来托管静态组件。 另外一个用没有cookie的域名提供组件的好处是，某些代理可能会阻止缓存待cookie的静态组件请求。 4. CSS4.1 Put Stylesheets at the Top把样式放在顶部。 研究雅虎网页性能时发现把样式表移到&lt;head&gt;里会让页面更快。这是因为把样式表移到&lt;head&gt;里允许页面逐步渲染。 关注性能的前端工程师希望页面被逐步渲染，这时因为，我们希望浏览器尽早渲染获取到的任何内容。这对大页面和网速慢的用户很重要。给用户视觉反馈，比如进度条的重要性已经被大量研究和记录。在我们的情况中，HTML页面就是进度条。当浏览器逐步加载页面头部，导航条，logo等等，这些都是给等待页面的用户的视觉反馈。这优化了整体用户体验。 把样式表放在文档底部的问题是它阻止了许多浏览器的逐步渲染，包括IE。这些浏览器阻止渲染来避免在样式更改时需要重绘页面元素。所以用户会卡在白屏。 HTML规范清楚表明样式应该在&lt;head&gt;里。 4.2 Avoid CSS Expressions避免CSS表达式。 CSS表达式是强大的（可能也是危险的）设置动态CSS属性的方法。IE5开始支持，IE8开始不赞成使用。例如，背景颜色可以设置成每小时轮换： background-color: expression( (new Date()).getHours()%2 ? “#B8D4FF” : “#F08A00” );CSS表达式的问题是它们可能比大多数人预期的计算的更频繁。它们不仅在页面载入和调整大小时重新计算，也在滚动页面甚至是用户在页面上移动鼠标时计算。比如在页面上移动鼠标可能轻易计算超过10000次。 要避免CSS表达式计算太多次，可以在它第一次计算后替换成确切值，或者用事件处理函数而不是CSS表达式。 4.3 Choose &lt;link&gt; over @import选择&lt;link&gt;而不是@import。 之前的一个最佳原则是说CSS应该在顶部来允许逐步渲染。 在IE用@import和把CSS放到页面底部行为一致，所以最好别用。 4.4 Avoid Filters避免使用（IE）过滤器。 IE专有的AlphaImageLoader过滤器用于修复IE7以下版本的半透明真彩色PNG的问题。这个过滤器的问题是它阻止了渲染，并在图片下载时冻结了浏览器。另外它还引起内存消耗，并且它被应用到每个元素而不是每个图片，所以问题（的严重性）翻倍了。 最佳做法是放弃AlphaImageLoader，改用PNG8来优雅降级。 5. JavaScript5.1 Put Scripts at the Bottom把脚本放到底部。 脚本引起的问题是它们阻塞了并行下载。HTTP1.1规范建议浏览器每个域名下不要一次下载超过2个组件。如果你的图片分散在不同服务器，那么你能并行下载多个图片。但当脚本在下载，浏览器不会再下载其它组件，即使在不同域名下。 有些情况下把脚本移动到底部并不简单。比如，脚本中用了document.write来插入内容，它就不能被移动到底部。另外有可能有作用域问题。但大多数情况，有方法可以解决这些问题。 一个替代建议是使用异步脚本。defer属性表明脚本不包含document.write，是提示浏览器继续渲染的线索。不幸的是，Firefox不支持。如果脚本能异步，那么也就可以移动到底部。 5.2 Make JavaScript and CSS External使用外部JS和CSS。 这里的很多性能规则涉及外部组件怎么管理。但你首先要明白一个基本问题：JS和CSS是应该包含在外部文件还是內连在页面本身？ 真实世界中使用外部文件一般会加快页面，因为JS和CSS文件被浏览器缓存了。內连的JS和CSS怎在每次HTML文档下载时都被下载。內连减少了http请求，但增加了HTML文档大小。另一方面，如果JS和CSS被缓存了，那么HTML文档可以减小大小而不增加HTTP请求。 核心因素，就是JS和CSS被缓存相对于HTML文档被请求的频率。尽管这个因素很难被量化，但可以用不同的指标来计算。如果网站用户每个session有多个pv，许多页面重用相同的JS和CSS，那么有很大可能用外部JS和CSS更好。 许多网站用这些指标计算后在中间位置。对这些网站来说，最佳方案还是用外部JS和CSS文件。唯一例外是內连更被主页偏爱，如http://www.yahoo.com/。主页每个session可能只有少量的甚至一个pv，这时候內连可能更快。 对多个页面的首页来说，可以通过技术减少（其它页面的）http请求。在首页用內连，初始化后动态加载外部文件，接下来的页面如果用到这些文件，就可以使用缓存了。 5.3 Minify JavaScript and CSS压缩JS和CSS。 压缩就是删除代码中不必要的字符来减小文件大小，从而提高加载速度。当代码压缩时，注释删除，不需要的空格（空白，换行，tab）也被删除。 混淆是对代码可选的优化。它比压缩更复杂，并且可能产生bug。在对美国top10网站的调查，压缩可减小21%，而混淆可减小25%。 除了外部脚本和样式，內连的脚本和样式同样应该被压缩。 5.4 Remove Duplicate Scripts删除重复的脚本。 在页面中引入相同的脚本两次会伤害性能。可能超出你的预料，美国top10网站的2家有重复脚本引入。两个主要因素造成同一页面引入相同脚本：团队大小和脚本数量。当确实引入重复脚本，会发出不必要的http请求和浪费js执行时间。 发出不必要的http请求发生在IE而不是Firefox。在IE，如果外部脚本引入两次且没有缓存，它会发出2个请求。即使脚本被缓存，刷新时也会发出额外请求。 除了增加http请求，时间被浪费在执行脚本多次上。不管IE还是Firefox都会执行多次。 一种避免多次引入脚本的方法是在模板系统实现一个脚本管理模块。 5.5 Minimize DOM Access最小化DOM访问。 用JS访问DOM元素是缓慢的，所以为了响应更好的页面，你应该： 缓存访问过的元素的引用 在DOM树外更新节点，然后添加到DOM树 避免用JS实现固定布局 5.6 Develop Smart Event Handlers开发聪明的事件处理 有时候页面看起来不那么响应（响应速度慢），是因为绑定到不同元素的大量事件处理函数执行太多次。这是为什么使用事件委托是一种好方法。 另外，你不必等到onload事件来开始处理DOM树，DOMContentLoaded更快。大多时候你需要的只是想访问的元素已在DOM树中，所以你不必等到所有图片被下载。 6 Images6.1 Optimize Images优化图片 在设计师建好图片后，在上传图片到服务器前你仍可以做些事： 检查gif图片的调色板大小是否匹配图片颜色数。 可以把gif转成png看看有没有变小。除了动画，gif一般可以转成png8。 运行pngcrush或其它工具压缩png。 运行jpegtran或其它工具压缩jpeg。* 6.2 Optimize CSS Sprites优化CSS雪碧图 把图片横向合并而不是纵向，横向更小。 把颜色近似的图片合并到一张雪碧图，这样可以让颜色数更少，如果低于256就可以用png8. “Be obile-friendly”并且合并时图片间的间距不要太大。这对图片大小影响不是太大，但客户端解压时需要的内存更少。100×100是10000个像素，1000×1000是1000000个像素。 6.3 Don’t Scale Images in HTML不要在html中缩放图片 不要因为你可以设置图片的宽高就去用比你需要的大得多的图片。如果你需要1&lt;img width=&quot;100&quot; height=&quot;100&quot; src=&quot;mycat.jpg&quot; alt=&quot;My Cat&quot; /&gt; 那么，就用100x100px的图片，而不是500x500px的。 6.4 Make favicon.ico Small and Cacheablefavicon.ico小且缓存 favicon.ico是在你服务器根路径的图片。邪恶的是即使你不关心它，浏览器仍然会请求它。所以最好不要响应404。另外由于在同一服务器，每次请求favicon.ico时也会带上cookie。这个图片还会影响下载顺序，比如在IE，如果你在onload时下载额外的组件，fcvicon会在这些组件之前被下载。 怎么减轻favicon.ico的缺点？ 小，最好1K以下 设置Expires头部。也许可以安全地设置为几个月。 7 Mobile7.1 Keep Components under 25K保持组件小于25K 这个限制与iPhone不缓存大于25K的组件相关。注意，这是非压缩（uncompressed）的文件大小。在这里minification（压缩，不要与compress混淆）很重要，因为gzip无法满足（iPhone）。 7.2 Pack Components into a Multipart Document打包组件到一个多部父文档 打包组件到一个多部父文档类似于带附件的邮件。它帮助你在一个http请求中获取多个组件，但注意，iPhone不支持。","tags":[{"name":"前端优化","slug":"前端优化","permalink":"http://tawen.github.io/tags/前端优化/"}]},{"title":"Html5本地存储和本地数据库","date":"2017-03-08T02:23:05.000Z","path":"2017/03/08/blog20170308/","text":"一个网站如何能在客户的浏览器存储更多的数据呢？在Html4的时代在浏览器端存储点网站个性化的数据，尤其是用户浏览器的痕迹，用户的相关数据等一般只能存储在Cookie中，但是大多是浏览器对于Cookie的限制也就逼迫网站存储数据尽量精简，想存储复杂的、关系型的用户数据就根本不可能了。但是进入Html5时代，这一切都不叫事… 本地存储由来的背景 众所周知Html4时代Cookie的大小、格式、存储数据格式等限制，网站应用如果想在浏览器端存储用户的部分信息，那么只能借助于Cookie。但是Cookie的这些限制，也就导致了Cookie只能存储一些ID之类的标识符等简单的数据，复杂的数据就更别扯了。 下面是Cookie的限制： 1, 大多数浏览器支持最大为 4096 字节的 Cookie。 2, 浏览器还限制站点可以在用户计算机上存储的 Cookie 的数量。大多数浏览器只允许每个站点存储 20 个 Cookie；如果试图存储更多 Cookie，则最旧的 Cookie 便会被丢弃。 3, 有些浏览器还会对它们将接受的来自所有站点的 Cookie 总数作出绝对限制，通常为 300 个。 4, Cookie默认情况都会随着Http请求发送到后台服务器，但并不是所有请求都需要Cookie的，比如：js、css、图片等请求则不需要cookie。 Html5的设计者们，一开始就为Html5能成为富客户端做好了准备。为了破解Cookie的一系列限制，Html5通过JS的新的API就能直接存储大量的数据到客户端浏览器，而且支持复杂的本地数据库，让JS简直就是逆天了。Html5支持两种的WebStorage，一种是永久性的本地存储（localStorage），另外一种是会话级别的本地存储（sessionStorage）。 会话级别的本地存储：sessionStorage在Html5中增加了一个Js对象：sessionStorage；通过此对象可以直接操作存储在浏览器中的会话级别的WebStorage。存储在sessionStorage中的数据首先是Key-Value形式的，另外就是它跟浏览器当前会话相关，当会话结束后，数据会自动清除，跟未设置过期时间的Cookie类似。 sessionStorage提供了四个方法来辅助我们进行对本地存储做相关操作。（1）setItem(key,value)：添加本地存储数据。两个参数，非常简单就不说了。 （2）getItem(key):通过key获取相应的Value。（3）removeItem(key):通过key删除本地数据。 （4）clear():清空数据。12345678910&lt;script type=&quot;text/javascript&quot;&gt; //添加key-value 数据到 sessionStorage sessionStorage.setItem(&quot;demokey&quot;, &quot;http://blog.itjeek.com&quot;); //通过key来获取value var dt = sessionStorage.getItem(&quot;demokey&quot;); alert(dt); //清空所有的key-value数据。 //sessionStorage.clear(); alert(sessionStorage.length);&lt;/script&gt; 对于JS的学习和调试必须得有Chrome的调试工具辅助才能事半功倍。当然Chrome也是我最喜爱的Web开发辅助工具，非常简单F12快捷键就立即打开工具了，包括IE也是这个快捷键。通过下图就可以查看当前浏览器中的sessionStorage数据。 永久本地存储：localStorage在最新的JS的API中增加了localStorage对象，以便于用户存储永久存储的Web端的数据。而且数据不会随着Http请求发送到后台服务器，而且存储数据的大小机会不用考虑，因为在HTML5的标准中要求浏览器至少要支持到4MB.所以，这完全是颠覆了Cookie的限制，为Web应用在本地存储复杂的用户痕迹数据提供非常方便的技术支持。那接下里分别介绍一下localStorage的常用的方法，当然基本上跟sessionStorage是一致的。 localStorage提供了四个方法来辅助我们进行对本地存储做相关操作。 （1）setItem(key,value)：添加本地存储数据。两个参数，非常简单就不说了。 （2）getItem(key):通过key获取相应的Value。（3）removeItem(key):通过key删除本地数据。 （4）clear():清空数据。12345678910&lt;script type=&quot;text/javascript&quot;&gt; //添加key-value 数据到 sessionStorage localStorage.setItem(&quot;demokey&quot;, &quot;http://blog.itjeek.com&quot;); //通过key来获取value var dt = localStorage.getItem(&quot;demokey&quot;); alert(dt); //清空所有的key-value数据。 //localStorage.clear(); alert(localStorage.length);&lt;/script&gt; 逆天了本地数据库虽然Html5已经提供了功能强大的localStorage和sessionStorage，但是他们两个都只能提供存储简单数据结构的数据，对于复杂的Web应用的数据却无能为力。逆天的是Html5提供了一个浏览器端的数据库支持，允许我们直接通JS的API在浏览器端创建一个本地的数据库，而且支持标准的SQL的CRUD操作，让离线的Web应用更加方便的存储结构化的数据。接下里介绍一下本地数据的相关API和用法。 操作本地数据库的最基本的步骤是： 第一步：openDatabase方法：创建一个访问数据库的对象。第二步：使用第一步创建的数据库访问对象来执行transaction方法，通过此方法可以设置一个开启事务成功的事件响应方法，在事件响应方法中可以执行SQL.第三步：通过executeSql方法执行查询，当然查询可以是：CRUD。接下来分别介绍一下相关的方法的参数和用法。 （1）openDatabase方法：12//Demo：获取或者创建一个数据库，如果数据库不存在那么创建之var dataBase = openDatabase(&quot;student&quot;, &quot;1.0&quot;, &quot;学生表&quot;, 1024 * 1024, function () &#123; &#125;); openDatabase方法打开一个已经存在的数据库，如果数据库不存在，它还可以创建数据库。几个参数意义分别是： 1，数据库名称。 2，数据库的版本号，目前来说传个1.0就可以了，当然可以不填； 3，对数据库的描述。 4，设置分配的数据库的大小（单位是kb）。 5，回调函数(可省略)。初次调用时创建数据库，以后就是建立连接了。 （2）db.transaction方法可以设置一个回调函数，此函数可以接受一个参数就是我们开启的事务的对象。然后通过此对象可以进行执行Sql脚本，跟下面的步骤可以结合起来。 （3）通过executeSql方法执行查询。1ts.executeSql(sqlQuery,[value1,value2..],dataHandler,errorHandler) 参数说明： qlQuery：需要具体执行的sql语句，可以是create、select、update、delete； value1,value2..]：sql语句中所有使用到的参数的数组，在executeSql方法中，将s&gt;语句中所要使用的参数先用“?”代替，然后依次将这些参数组成数组放在第二个参数中 ataHandler：执行成功是调用的回调函数，通过该函数可以获得查询结果集； 4,errorHandler：执行失败时调用的回调函数；下面是一个综合的例子，可以看一下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;head&gt; &lt;script src=&quot;Scripts/jquery-1.5.1.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; function initDatabase() &#123; var db = getCurrentDb();//初始化数据库 if(!db) &#123;alert(&quot;您的浏览器不支持HTML5本地数据库&quot;);return;&#125; db.transaction(function (trans) &#123;//启动一个事务，并设置回调函数 //执行创建表的Sql脚本 trans.executeSql(&quot;create table if not exists Demo(uName text null,title text null,words text null)&quot;, [], function (trans, result) &#123; &#125;, function (trans, message) &#123;//消息的回调函数alert(message);&#125;); &#125;, function (trans, result) &#123; &#125;, function (trans, message) &#123; &#125;); &#125; $(function () &#123;//页面加载完成后绑定页面按钮的点击事件 initDatabase(); $(&quot;#btnSave&quot;).click(function () &#123; var txtName = $(&quot;#txtName&quot;).val(); var txtTitle = $(&quot;#txtTitle&quot;).val(); var txtWords = $(&quot;#txtWords&quot;).val(); var db = getCurrentDb(); //执行sql脚本，插入数据 db.transaction(function (trans) &#123; trans.executeSql(&quot;insert into Demo(uName,title,words) values(?,?,?) &quot;, [txtName, txtTitle, txtWords], function (ts, data) &#123; &#125;, function (ts, message) &#123; alert(message); &#125;); &#125;); showAllTheData(); &#125;); &#125;); function getCurrentDb() &#123; //打开数据库，或者直接连接数据库参数：数据库名称，版本，概述，大小 //如果数据库不存在那么创建之 var db = openDatabase(&quot;myDb&quot;, &quot;1.0&quot;, &quot;it&apos;s to save demo data!&quot;, 1024 * 1024); ; return db; &#125; //显示所有数据库中的数据到页面上去 function showAllTheData() &#123; $(&quot;#tblData&quot;).empty(); var db = getCurrentDb(); db.transaction(function (trans) &#123; trans.executeSql(&quot;select * from Demo &quot;, [], function (ts, data) &#123; if (data) &#123; for (var i = 0; i &lt; data.rows.length; i++) &#123; appendDataToTable(data.rows.item(i));//获取某行数据的json对象 &#125; &#125; &#125;, function (ts, message) &#123;alert(message);var tst = message;&#125;); &#125;); &#125; function appendDataToTable(data) &#123;//将数据展示到表格里面 //uName,title,words var txtName = data.uName; var txtTitle = data.title; var words = data.words; var strHtml = &quot;&quot;; strHtml += &quot;&lt;tr&gt;&quot;; strHtml += &quot;&lt;td&gt;&quot;+txtName+&quot;&lt;/td&gt;&quot;; strHtml += &quot;&lt;td&gt;&quot; + txtTitle + &quot;&lt;/td&gt;&quot;; strHtml += &quot;&lt;td&gt;&quot; + words + &quot;&lt;/td&gt;&quot;; strHtml += &quot;&lt;/tr&gt;&quot;; $(&quot;#tblData&quot;).append(strHtml); &#125; &lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;txtName&quot; id=&quot;txtName&quot; required/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;标题：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;txtTitle&quot; id=&quot;txtTitle&quot; required/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;留言：&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;txtWords&quot; id=&quot;txtWords&quot; required/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type=&quot;button&quot; value=&quot;保存&quot; id=&quot;btnSave&quot;/&gt; &lt;hr/&gt; &lt;input type=&quot;button&quot; value=&quot;展示所哟数据&quot; onclick=&quot;showAllTheData();&quot;/&gt; &lt;table id=&quot;tblData&quot;&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt;","tags":[{"name":"WebStorage","slug":"WebStorage","permalink":"http://tawen.github.io/tags/WebStorage/"},{"name":"localStorage","slug":"localStorage","permalink":"http://tawen.github.io/tags/localStorage/"}]},{"title":"Ajax页面缓存问题分析与解决办法","date":"2017-03-08T02:23:05.000Z","path":"2017/03/08/blog20170309/","text":"Ajax页面缓存是ajax处理数据时对一些重复相同数据进行一个缓存操作，这样从另一个层面对于我们来讲是非常的不错了，但有时我们并不希望它缓存要如何处理呢？下面我们一起来看看关于页面缓存问题分析与解决，希望例子对各位会带来帮助。 一、什么是Ajax缓存原理？Ajax在发送的数据成功后，会把请求的URL和返回的响应结果保存在缓存内，当下一次调用Ajax发送相同的请求时，它会直接从缓存中把数据取出来，这是为了提高页面的响应速度和用户体验。当前这要求两次请求URL完全相同，包括参数。这个时候，浏览器就不会与服务器交互。 二、Ajax缓存的好处这种设计使客户端对一些静态页面内容的请求，比如图片，css文件，js脚本等，变得更加快捷，提高了页面的响应速度，也节省了网络通信资源。 三、Ajax缓存的不足Ajax缓存虽然有上述的好处，但是如果通过Ajax对一些后台数据进行更改的时候，虽然数据在后台已经发生改变，但是页面缓存中并没有改变，对于相同的URL，Ajax提交过去以后，浏览器还只是简单的从缓存中拿数据，这种情况当然就不行了。 四、解决Ajax缓存问题的方法解决这个问题最有效的办法是禁止页面缓存，有以下几种处理方法： 1、在ajax发送请求前加上 xmlHttpRequest.setRequestHeader(“Cache-Control”,”no-cache”); 2、在服务端加 header(“Cache-Control: no-cache, must-revalidate”); 3、在ajax发送请求前加上 xmlHttpRequest.setRequestHeader(“If-Modified-Since”,”0″); 4、在 Ajax 的 URL 参数后加上 “?fresh=” + Math.random(); //当然这里参数 fresh 可以任意取了 5、第五种方法和第四种类似，在 URL 参数后加上 “?timestamp=” + new Date().getTime(); 6、用POST替代GET：不推荐 7、jQuery提供一个防止ajax使用缓存的方法：12345&lt;script type=&quot;text/javascript&quot; language=&quot;javascript&quot;&gt; $.ajaxSetup (&#123; cache: false //close AJAX cache &#125;); &lt;/script&gt; 8、修改load 加载的url地址，如在url 多加个时间参数就可以：123456789function loadEventInfoPage(eventId)&#123; $.ajaxSetup (&#123; cache: true // AJAX cache 下面加上时间后load的页面中的js、css图片等都会重新加载， //加上这句action会重新加载，但是js、css、图片等会走缓存 &#125;); $(&quot;#showEventInfo&quot;).load(ctx + &quot;/custEvents/viewEvent.action&quot;, &#123;&quot;complaint.Id&quot;:eventId, &quot;tt&quot;:(new Date()).getTime()&#125;,function()&#123;&#125;) &#125; 9、设置html的缓存123&lt;META HTTP-EQUIV=&quot;Pragma&quot; CONTENT=&quot;no-cache&quot;&gt; &lt;META HTTP-EQUIV=&quot;Cache-Control&quot; CONTENT=&quot;no-cache&quot;&gt; &lt;META HTTP-EQUIV=&quot;Expires&quot; CONTENT=&quot;0&quot;&gt;","tags":[{"name":"ajax cache","slug":"ajax-cache","permalink":"http://tawen.github.io/tags/ajax-cache/"}]},{"title":"Sublime Text 3下Emmet使用技巧","date":"2017-02-28T02:23:05.000Z","path":"2017/02/28/blog20170228/","text":"快速编写HTML代码初始化文档HTML文档需要包含一些固定的标签，比如&lt;html&gt;、&lt;head&gt;、&lt;body&gt;等，现在你只需要1秒钟就可以输入这些标签。比如输入“!”或“html:5”，然后按Tab键或ctrl+e：html:5 或!：用于HTML5文档类型html:xt：用于XHTML过渡文档类型html:4s：用于HTML4严格文档类型 轻松添加类、id、文本和属性 连续输入元素名称和ID，Emmet会自动为你补全，比如输入p#foo： 连续输入类和id，比如p.bar#foo，会自动生成： 下面来看看如何定义HTML元素的内容和属性。你可以通过输入h1{foo}和a[href=#]，就可以自动生成如下代码： 嵌套现在你只需要1行代码就可以实现标签的嵌套&gt;：子元素符号，表示嵌套的元素+：同级标签符号^：可以使该符号前的标签提升一行 分组可以通过嵌套和括号来快速生成一些代码块，比如输入(.foo&gt;h1)+(.bar&gt;h2)，ctrl+e会自动生成： 隐式标签声明一个带类的标签，只需输入div.item，就会生成&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;。在过去版本中，可以省略掉div，即输入.item即可生成 &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; 。现在如果只输入.item，则Emmet会根据父标签进行判定。比如在 &lt;ul&gt; 中输入.item，就会生成 &lt;li class=&quot;item&quot;&gt;&lt;/li&gt; 。下面是所有的隐式标签名称： li：用于ul和ol中 tr：用于table、tbody、thead和tfoot中 td：用于tr中 option：用于select和optgroup中* 定义多个元素要定义多个元素，可以使用符号。比如，ul&gt;li3可以生成如下代码： 定义多个带属性的元素如输入 ul&gt;li.item$3，将会生成如下代码Emmet中如果需要指定反向编号，可以使用”$@-“符号如果要从指定的数字开始编号，可以使用ul&gt;li.item$@35 CSS缩写值1、比如要定义元素的宽度，只需输入w100，即可生成2、除了px，也可以生成其他单位，比如输入h10p+m5e单位别名列表：p 表示%e 表示 emx 表示 ex 附加属性1、缩写，比如 @f，可以生成：一些其他的属性，比如background-image、border-radius、font、@font-face,text-outline、text-shadow等额外的选项，可以通过“+”符号来生成；2、输入@f+，将生成： 模糊匹配如果有些缩写你拿不准，Emmet会根据你的输入内容匹配最接近的语法，比如输入ov:h、ov-h、ovh和oh，生成的代码是相同的： 供应商前缀1、如果输入非W3C标准的CSS属性，Emmet会自动加上供应商前缀，比如输入trs，则会生成：2、可以在任意属性前加上“-”符号，也可以为该属性加上前缀。比如输入-super-foo：3、如果不希望加上所有前缀，可以使用缩写来指定，比如-wm-trf表示只加上-webkit和-moz前缀：前缀缩写如下：w 表示 -webkit-m 表示 -moz-s 表示 -ms-o 表示 -o- 渐变输入lg(left, #fff 50%, #000)，会生成如下代码：","tags":[{"name":"sublime","slug":"sublime","permalink":"http://tawen.github.io/tags/sublime/"},{"name":"Emmet","slug":"Emmet","permalink":"http://tawen.github.io/tags/Emmet/"}]},{"title":"你所不知道的setTimeout","date":"2017-02-22T09:23:05.000Z","path":"2017/02/22/blog20170222/","text":"setTimeout()基础setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。1var timerId = setTimeout(func|code, delay) 上面代码中，setTimeout函数接受两个参数，第一个参数func|code是将要推迟执行的函数名或者一段代码，第二个参数delay是推迟执行的毫秒数。123console.log(1);setTimeout(&apos;console.log(2)&apos;,1000);console.log(3); 上面代码的输出结果就是1，3，2，因为setTimeout指定第二行语句推迟1000毫秒再执行(如果这在Sublime下运用插件以nodejs环境来执行，许解释器不同，会报错)。 要注意的是，推迟执行的代码必须以字符串的形式，放入setTimeout，因为引擎内部使用eval函数，将字符串转为代码。如果推迟执行的是函数，则可以直接将函数名，放入setTimeout。一方面eval函数有安全顾虑，另一方面为了便于JavaScript引擎优化代码，setTimeout方法一般总是采用函数名的形式，就像下面这样。123456function func()&#123; console.log(2);&#125;setTimeout(func,1000);// 或者setTimeout(function ()&#123;console.log(2)&#125;,1000); setTimeout传参数除了前两个参数，setTimeout还允许添加更多的参数。它们将被传入推迟执行的函数（回调函数）。123setTimeout(function(a,b)&#123; console.log(a+b);&#125;,1000,1,1); IE 9.0及以下版本，只允许setTimeout有两个参数，不支持更多的参数;可以在匿名函数中，让回调函数带参数运行，再把匿名函数输入setTimeout；例如:123setTimeout(function() &#123; myFunc(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);&#125;, 1000); 当然也可以使用bind或apply方法来解决。例如使用bind方法，把多余的参数绑定在回调函数上面，生成一个新的函数输入setTimeout。1setTimeout( function(arg1)&#123;&#125;.bind(undefined, 10), 1000 ); 上面代码中，bind方法第一个参数是undefined，表示将原函数的this绑定全局作用域，第二个参数是要传入原函数的参数。它运行后会返回一个新函数，该函数不带参数。 setTimeout注意点 setTimeout()中回调函数中的this 如果被setTimeout推迟执行的回调函数是某个对象的方法，那么该方法中的this关键字将指向全局环境，而不是定义时所在的那个对象。12345678var x = 1;var o = &#123; x: 2, y: function()&#123; console.log(this.x); &#125;&#125;;setTimeout(o.y,1000);// 1 上面代码输出的是1，而不是2，这表示o.y的this所指向的已经不是o，而是全局环境了。再看一个不容易发现错误的例子。12345678function User(login) &#123; this.login = login; this.sayHi = function() &#123; console.log(this.login); &#125;&#125;var user = new User(&apos;John&apos;);setTimeout(user.sayHi, 1000); 上面代码只会显示undefined，因为等到user.sayHi执行时，它是在全局对象中执行，所以this.login取不到值。为了防止出现这个问题，一种解决方法是将user.sayHi放在匿名函数中执行。123setTimeout(function() &#123; user.sayHi();&#125;, 1000); 上面代码中，sayHi是在user作用域内执行，而不是在全局作用域内执行，所以能够显示正确的值。另一种解决方法是，使用bind方法，将绑定sayHi绑定在user上面。12 setTimeout(user.sayHi.bind(user), 1000); HTML 5标准规定，setTimeout的最短时间间隔是4毫秒。为了节电，对于那些不处于当前窗口的页面，浏览器会将时间间隔扩大到1000毫秒。另外，如果笔记本电脑处于电池供电状态，Chrome和IE 9以上的版本，会将时间间隔切换到系统定时器，大约是15.6毫秒。 setTimeout执行回调间隔时间长度 如果你在一段代码中发现下面内容:1234var startTime = new Date();setTimeout(function () &#123; console.log(new Date() - startTime);&#125;, 100) 请问最后打印的是多少?其正确答案是，取决于后面同步执行的js需要占用多少时间。即为：MAX(同步执行的时间, 100)；缘何如此，就得看下setTimeout运行机制了。 setTimeout运行setTimeout和setInterval的运行机制是，将指定的代码移出本次执行，等到下一轮Event Loop时，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮Event Loop时重新判断。这意味着，setTimeout指定的代码，必须等到本次执行的所有代码都执行完，才会执行。 每一轮Event Loop时，都会将“任务队列”中需要执行的任务，一次执行完。setTimeout和setInterval都是把任务添加到“任务队列”的尾部。因此，它们实际上要等到当前脚本的所有同步任务执行完，然后再等到本次Event Loop的“任务队列”的所有任务执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout和setInterval指定的任务，一定会按照预定时间执行。12setTimeout(someTask,100);veryLongTask(); 上面代码的setTimeout，指定100毫秒以后运行一个任务。但是，如果后面立即运行的任务（当前脚本的同步任务））非常耗时，过了100毫秒还无法结束，那么被推迟运行的someTask就只有等着，等到前面的veryLongTask运行结束，才轮到它执行。 setTimeout(func,0)在使用backbone框架写代码的时候，因为些需求因素，新手总会在render时操纵下dom，却发现改变dom元素状态，代码没有问题，界面却没有变更。而使用setTimeout(func,time)却能解决这个问题，即便time=0;探究一番，真相只有一个： setTimeout(func,0)含义 运行下面代，func1和func2谁会先执行？很明显func2先执行；1234setTimeout(function () &#123; func1();&#125;, 0)func2(); setTimeout的作用是将代码推迟到指定时间执行，如果指定时间为0，即setTimeout(f,0)，那么会立刻执行吗？ 答案是不会。因为setTimeout运行机制说过，必须要等到当前脚本的同步任务和“任务队列”中已有的事件，全部处理完以后，才会执行setTimeout指定的任务。也就是说，setTimeout的真正作用是，在“任务队列”的现有事件的后面再添加一个事件，规定在指定时间执行某段代码。setTimeout添加的事件，会在下一次Event Loop执行。 setTimeout(f,0)将第二个参数设为0，作用是让f在现有的任务（脚本的同步任务和“任务队列”中已有的事件）一结束就立刻执行。也就是说，setTimeout(f,0)的作用是，尽可能早地执行指定的任务。123setTimeout(function ()&#123; console.log(&quot;你好！&quot;);&#125;, 0); 上面代码的含义是，尽可能早地显示“你好！”。 setTimeout(f,0)指定的任务，最早也要到下一次Event Loop才会执行。请看下面的例子。123456789101112131415161718192021222324setTimeout(function() &#123; console.log(&quot;Timeout&quot;);&#125;, 0);function a(x) &#123; console.log(&quot;a() 开始运行&quot;); b(x); console.log(&quot;a() 结束运行&quot;);&#125;function b(y) &#123; console.log(&quot;b() 开始运行&quot;); console.log(&quot;传入的值为&quot; + y); console.log(&quot;b() 结束运行&quot;);&#125;console.log(&quot;当前任务开始&quot;);a(42);console.log(&quot;当前任务结束&quot;);// 当前任务开始// a() 开始运行// b() 开始运行// 传入的值为42// b() 结束运行// a() 结束运行// 当前任务结束// Timeout 上面代码说明，setTimeout(f,0)必须要等到当前脚本的所有同步任务结束后才会执行。0毫秒实际上达不到的。根据HTML5标准，setTimeOut推迟执行的时间，最少是4毫秒。如果小于这个值，会被自动增加到4。这是为了防止多个setTimeout(f,0)语句连续执行，造成性能问题。另一方面，浏览器内部使用32位带符号的整数，来储存推迟执行的时间。这意味着setTimeout最多只能推迟执行2147483647毫秒（24.8天），超过这个时间会发生溢出，导致回调函数将在当前任务队列结束后立即执行，即等同于setTimeout(f,0)的效果。 setTimeout(f,0)应用调整事件的发生顺序setTimeout(f,0)有几个非常重要的用途。它的一大应用是，可以调整事件的发生顺序。比如，网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，我们先让父元素的事件回调函数先发生，就要用到setTimeout(f, 0)。123456789var input = document.getElementsByTagName(&apos;input[type=button]&apos;)[0];input.onclick = function A() &#123; setTimeout(function B() &#123; input.value +=&apos; input&apos;; &#125;, 0)&#125;;document.body.onclick = function C() &#123; input.value += &apos; body&apos;&#125;; 上面代码在点击按钮后，先触发回调函数A，然后触发函数C。在函数A中，setTimeout将函数B推迟到下一轮Loop执行，这样就起到了，先触发父元素的回调函数C的目的了。用户自定义的回调函数，通常在浏览器的默认动作之前触发。比如，用户在输入框输入文本，keypress事件会在浏览器接收文本之前触发。因此，下面的回调函数是达不到目的的。123document.getElementById(&apos;input-box&apos;).onkeypress = function(event) &#123; this.value = this.value.toUpperCase();&#125; 上面代码想在用户输入文本后，立即将字符转为大写。但是实际上，它只能将上一个字符转为大写，因为浏览器此时还没接收到文本，所以this.value取不到最新输入的那个字符。只有用setTimeout改写，上面的代码才能发挥作用。123456document.getElementById(&apos;my-ok&apos;).onkeypress = function() &#123; var self = this; setTimeout(function() &#123; self.value = self.value.toUpperCase(); &#125;, 0);&#125; 上面代码将代码放入setTimeout之中，就能使得它在浏览器接收到文本之后触发;原来如此：这也就解释了缘何在使用backbone调用render之时，操纵dom是无效的了，因为当时连dom元素都还没获取到(为何没报错？这牵扯到另一个话题),自然等页面渲染完毕了也没见想要的结果了。 分割耗时任何众所周知javascript是单线程的，特点就是容易出现阻塞。如果一段程序处理时间很长，很容易导致整个页面hold住。什么交互都处理不了怎么办？ 简化复杂度？复杂逻辑后端处理？html5的多线程？…… 上面都是ok的做法，但是setTimeout也是处理这种问题的一把好手。setTimeout一个很关键的用法就是分片，如果一段程序过大，我们可以拆分成若干细小的块。由于setTimeout(f,0)实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到setTimeout(f,0)里面执行(分片塞入队列)，这样即使在复杂程序没有处理完时，我们操作页面，也是能得到即时响应的。其实就是将交互插入到了复杂程序中执行。1234567891011121314var div = document.getElementsByTagName(&apos;div&apos;)[0];// 写法一for(var i=0xA00000;i&lt;0xFFFFFF;i++) &#123; div.style.backgroundColor = &apos;#&apos;+i.toString(16);&#125;// 写法二var timer;var i=0x100000;function func() &#123; timer = setTimeout(func, 0); div.style.backgroundColor = &apos;#&apos;+i.toString(16); if (i++ == 0xFFFFFF) clearInterval(timer);&#125;timer = setTimeout(func, 0); 上面代码有两种写法，都是改变一个网页元素的背景色。写法一会造成浏览器“堵塞”，而写法二就能就不会，这就是setTimeout(f,0)的好处。即：可利用setTimeout实现一种伪多线程的概念。另一个使用这种技巧的例子是，代码高亮的处理。如果代码块很大，就会分成一个个小块，写成诸如setTimeout(highlightNext, 50)的样子，进行分块处理。 clearTimeout()setTimeout和setInterval函数，都返回一个表示计数器编号的整数值，将该整数传入clearTimeout和clearInterval函数，就可以取消对应的定时器。1234var id1 = setTimeout(f,1000);var id2 = setInterval(f,1000);clearTimeout(id1);clearInterval(id2); setTimeout和setInterval返回的整数值是连续的(一定环境下，比如浏览器控制台，或者js执行环境等)，也就是说，第二个setTimeout方法返回的整数值，将比第一个的整数值大1。利用这一点，可以写一个函数，取消当前所有的setTimeout。123456789101112(function() &#123; var gid = setInterval(clearAllTimeouts, 0); function clearAllTimeouts() &#123; var id = setTimeout(function() &#123;&#125;, 0); while (id &gt; 0) &#123; if (id !== gid) &#123; clearTimeout(id); &#125; id--; &#125; &#125;&#125;)(); 运行上面代码后，实际上再设置任何setTimeout都无效了。下面是一个clearTimeout实际应用的例子。有些网站会实时将用户在文本框的输入，通过Ajax方法传回服务器，jQuery的写法如下。1$(&apos;textarea&apos;).on(&apos;keydown&apos;, ajaxAction); 这样写有一个很大的缺点，就是如果用户连续击键，就会连续触发keydown事件，造成大量的Ajax通信。这是不必要的，而且很可能会发生性能问题。正确的做法应该是，设置一个门槛值，表示两次Ajax通信的最小间隔时间。如果在设定的时间内，发生新的keydown事件，则不触发Ajax通信，并且重新开始计时。如果过了指定时间，没有发生新的keydown事件，将进行Ajax通信将数据发送出去。 这种做法叫做debounce（防抖动）方法，用来返回一个新函数。只有当两次触发之间的时间间隔大于事先设定的值，这个新函数才会运行实际的任务。假定两次Ajax通信的间隔不小于2500毫秒，上面的代码可以改写成下面这样。12 $(&apos;textarea&apos;).on(&apos;keydown&apos;, debounce(ajaxAction, 2500)) 利用setTimeout和clearTimeout，可以实现debounce方法。该方法用于防止某个函数在短时间内被密集调用，具体来说，debounce方法返回一个新版的该函数，这个新版函数调用后，只有在指定时间内没有新的调用，才会执行，否则就重新计时。1234567891011121314function debounce(fn, delay)&#123; var timer = null; // 声明计时器 return function()&#123; var context = this; var args = arguments; clearTimeout(timer); timer = setTimeout(function()&#123; fn.apply(context, args); &#125;, delay); &#125;;&#125;// 用法示例var todoChanges = debounce(batchLog, 1000);Object.observe(models.todo, todoChanges); 现实中，最好不要设置太多个setTimeout和setInterval，它们耗费CPU。比较理想的做法是，将要推迟执行的代码都放在一个函数里，然后只对这个函数使用setTimeout或setInterval。 如何使用setTimeout对setTimeout自然不止于这些，但已足见其强大。那么问题来了，需要在项目中大量使用么？视个人和项目而定吧；如不能熟练掌握，不建议多用。毕竟在某些情景之下，setTimeout作为一个hack的方式而存在的（打乱模块的生命周期，并且在问题出现时很难调试，你懂的），譬如：当一个实例还没有初始化的前，我们就使用这个实例，错误的解决办法是使用实例时加个setTimeout，确保实例使用前已初始化。但只要足够熟悉它，以及使用的场景(包括模块生命周期)，使用它也就无可厚非了。比如underscore中不少方法也是基于这setTimeout方法写的；比如非常强大的.defer： 延迟调用function直到当前调用栈清空为止，类似使用延时为0的setTimeout方法。对于执行开销大的计算和无阻塞UI线程的HTML渲染时候非常有用。 如果传递arguments参数，当函数function执行时， arguments 会作为参数传入。也比如前文提到的防抖动方法debounce.debounce(function, wait, [immediate]) ;在underscore中其实现方法如下：123456789101112131415161718192021222324252627_.debounce = function(func, wait, immediate) &#123; var timeout, args, context, timestamp, result; var later = function() &#123; var last = _.now() - timestamp; if (last &lt; wait &amp;&amp; last &gt;= 0) &#123; timeout = setTimeout(later, wait - last); &#125; else &#123; timeout = null; if (!immediate) &#123; result = func.apply(context, args); if (!timeout) context = args = null; &#125; &#125; &#125;; return function() &#123; context = this; args = arguments; timestamp = _.now(); var callNow = immediate &amp;&amp; !timeout; if (!timeout) timeout = setTimeout(later, wait); if (callNow) &#123; result = func.apply(context, args); context = args = null; &#125; return result; &#125;;&#125;;","tags":[{"name":"setTimeout","slug":"setTimeout","permalink":"http://tawen.github.io/tags/setTimeout/"}]},{"title":"jQuery Validate验证框架详解","date":"2017-02-21T09:23:05.000Z","path":"2017/02/21/blog20170221/","text":"导入js库12&lt;script type=&quot;text/javascript&quot; src=&quot;/validate/jquery-1.6.2.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/validate/jquery.validate.min.js&quot;&gt;&lt;/script&gt; 默认校验规则1234567891011121314151617required:true 必输字段remote:&quot;remote-valid.jsp&quot; 使用ajax方法调用remote-valid.jsp验证输入值email:true 必须输入正确格式的电子邮件url:true 必须输入正确格式的网址date:true 必须输入正确格式的日期，日期校验ie6出错，慎用dateISO:true 必须输入正确格式的日期(ISO)，例如：2009-06-23，1998/01/22 只验证格式，不验证有效性number:true 必须输入合法的数字(负数，小数)digits:true 必须输入整数creditcard:true 必须输入合法的信用卡号equalTo:&quot;#password&quot; 输入值必须和#password相同accept: 输入拥有合法后缀名的字符串（上传文件的后缀）maxlength:5 输入长度最多是5的字符串(汉字算一个字符)minlength:10 输入长度最小是10的字符串(汉字算一个字符)rangelength:[5,10] 输入长度必须介于 5 和 10 之间的字符串&quot;)(汉字算一个字符)range:[5,10] 输入值必须介于 5 和 10 之间max:5 输入值不能大于5min:10 输入值不能小于10 默认的提示123456789101112131415161718192021messages: &#123;required: &quot;This field is required.&quot;,remote: &quot;Please fix this field.&quot;,email: &quot;Please enter a valid email address.&quot;,url: &quot;Please enter a valid URL.&quot;,date: &quot;Please enter a valid date.&quot;,dateISO: &quot;Please enter a valid date (ISO).&quot;,dateDE: &quot;Bitte geben Sie ein g眉ltiges Datum ein.&quot;,number: &quot;Please enter a valid number.&quot;,numberDE: &quot;Bitte geben Sie eine Nummer ein.&quot;,digits: &quot;Please enter only digits&quot;,creditcard: &quot;Please enter a valid credit card number.&quot;,equalTo: &quot;Please enter the same value again.&quot;,accept: &quot;Please enter a value with a valid extension.&quot;,maxlength: $.validator.format(&quot;Please enter no more than &#123;0&#125; characters.&quot;),minlength: $.validator.format(&quot;Please enter at least &#123;0&#125; characters.&quot;),rangelength: $.validator.format(&quot;Please enter a value between &#123;0&#125; and &#123;1&#125; characters long.&quot;),range: $.validator.format(&quot;Please enter a value between &#123;0&#125; and &#123;1&#125;.&quot;),max: $.validator.format(&quot;Please enter a value less than or equal to &#123;0&#125;.&quot;),min: $.validator.format(&quot;Please enter a value greater than or equal to &#123;0&#125;.&quot;)&#125;, 如需要修改，可在js代码中加入：12345678910111213141516171819$.extend($.validator.messages, &#123; required: &quot;必选字段&quot;, remote: &quot;请修正该字段&quot;, email: &quot;请输入正确格式的电子邮件&quot;, url: &quot;请输入合法的网址&quot;, date: &quot;请输入合法的日期&quot;, dateISO: &quot;请输入合法的日期 (ISO).&quot;, number: &quot;请输入合法的数字&quot;, digits: &quot;只能输入整数&quot;, creditcard: &quot;请输入合法的信用卡号&quot;, equalTo: &quot;请再次输入相同的值&quot;, accept: &quot;请输入拥有合法后缀名的字符串&quot;, maxlength: $.validator.format(&quot;请输入一个长度最多是 &#123;0&#125; 的字符串&quot;), minlength: $.validator.format(&quot;请输入一个长度最少是 &#123;0&#125; 的字符串&quot;), rangelength: $.validator.format(&quot;请输入一个长度介于 &#123;0&#125; 和 &#123;1&#125; 之间的字符串&quot;), range: $.validator.format(&quot;请输入一个介于 &#123;0&#125; 和 &#123;1&#125; 之间的值&quot;), max: $.validator.format(&quot;请输入一个最大为 &#123;0&#125; 的值&quot;), min: $.validator.format(&quot;请输入一个最小为 &#123;0&#125; 的值&quot;)&#125;); 推荐做法，将此文件放入messages_cn.js中，在页面中引入1&lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%=path %&gt;/validate/messages_cn.js&quot;&gt;&lt;/script&gt; 使用方式1、metadata用法，将校验规则写到控件中12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt; &lt;title&gt;jQuery Validate验证框架详解-metadata用法&lt;/title&gt; &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt; &lt;meta http-equiv=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&gt; &lt;meta http-equiv=&quot;description&quot; content=&quot;This is my page&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%=request.getContextPath()%&gt;/validate/jquery-1.6.2.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%=request.getContextPath()%&gt;/validate/jquery.validate.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%=request.getContextPath()%&gt;/validate/jquery.metadata.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%=request.getContextPath()%&gt;/validate/messages_zh.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;#myform&quot;).validate(); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form id=&quot;myform&quot; method=&quot;post&quot; action=&quot;&quot;&gt; &lt;p&gt; &lt;label for=&quot;myname&quot;&gt;用户名：&lt;/label&gt; &lt;!-- id和name最好同时写上 --&gt; &lt;input id=&quot;myname&quot; name=&quot;myname&quot; class=&quot;required&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;email&quot;&gt;E-Mail：&lt;/label&gt; &lt;input id=&quot;email&quot; name=&quot;email&quot; class=&quot;required email&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;password&quot;&gt;登陆密码：&lt;/label&gt; &lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot; class=&quot;&#123;required:true,minlength:5&#125;&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;confirm_password&quot;&gt;确认密码：&lt;/label&gt; &lt;input id=&quot;confirm_password&quot; name=&quot;confirm_password&quot; type=&quot;password&quot; class=&quot;&#123;required:true,minlength:5,equalTo:&apos;#password&apos;&#125;&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;confirm_password&quot;&gt;性别：&lt;/label&gt; &lt;!-- 表示必须选中一个 --&gt; &lt;input type=&quot;radio&quot; id=&quot;gender_male&quot; value=&quot;m&quot; name=&quot;gender&quot; class=&quot;&#123;required:true&#125;&quot; /&gt; &lt;input type=&quot;radio&quot; id=&quot;gender_female&quot; value=&quot;f&quot; name=&quot;gender&quot;/&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;confirm_password&quot;&gt;爱好：&lt;/label&gt; &lt;!-- checkbox的minlength表示必须选中的最小个数,maxlength表示最大的选中个数,rangelength:[2,3]表示选中个数区间 --&gt; &lt;input type=&quot;checkbox&quot; id=&quot;spam_email&quot; value=&quot;email&quot; name=&quot;spam[]&quot; class=&quot;&#123;required:true, minlength:2&#125;&quot; /&gt; &lt;input type=&quot;checkbox&quot; id=&quot;spam_phone&quot; value=&quot;phone&quot; name=&quot;spam[]&quot; /&gt; &lt;input type=&quot;checkbox&quot; id=&quot;spam_mail&quot; value=&quot;mail&quot; name=&quot;spam[]&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;confirm_password&quot;&gt;城市：&lt;/label&gt; &lt;select id=&quot;jungle&quot; name=&quot;jungle&quot; title=&quot;Please select something!&quot; class=&quot;&#123;required:true&#125;&quot;&gt; &lt;option value=&quot;&quot;&gt;&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;厦门&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;泉州&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;Oi&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt; &lt;input class=&quot;submit&quot; type=&quot;submit&quot; value=&quot;立即注册&quot; /&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 使用class=”{}”的方式，必须引入包：jquery.metadata.js；可以使用如下的方法，修改提示内容：class=”{required:true,minlength:5,messages:{required:’请输入内容’}}”；在使用equalTo关键字时，后面的内容必须加上引号，如下代码：class=”{required:true,minlength:5,equalTo:’#password’}”。 2、将校验规则写到js代码中12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt; &lt;title&gt;jQuery Validate验证框架详解&lt;/title&gt; &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt; &lt;meta http-equiv=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&gt; &lt;meta http-equiv=&quot;description&quot; content=&quot;This is my page&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%=request.getContextPath()%&gt;/validate/jquery-1.6.2.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%=request.getContextPath()%&gt;/validate/jquery.validate.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; var validate = $(&quot;#myform&quot;).validate(&#123; debug: true, //调试模式取消submit的默认提交功能 //errorClass: &quot;label.error&quot;, //默认为错误的样式类为：error focusInvalid: false, //当为false时，验证无效时，没有焦点响应 onkeyup: false, submitHandler: function(form)&#123; //表单提交句柄,为一回调函数，带一个参数：form alert(&quot;提交表单&quot;); form.submit(); //提交表单 &#125;, rules:&#123; myname:&#123; required:true &#125;, email:&#123; required:true, email:true &#125;, password:&#123; required:true, rangelength:[3,10] &#125;, confirm_password:&#123; equalTo:&quot;#password&quot; &#125; &#125;, messages:&#123; myname:&#123; required:&quot;必填&quot; &#125;, email:&#123; required:&quot;必填&quot;, email:&quot;E-Mail格式不正确&quot; &#125;, password:&#123; required: &quot;不能为空&quot;, rangelength: $.format(&quot;密码最小长度:&#123;0&#125;, 最大长度:&#123;1&#125;。&quot;) &#125;, confirm_password:&#123; equalTo:&quot;两次密码输入不一致&quot; &#125; &#125; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form id=&quot;myform&quot; method=&quot;post&quot; action=&quot;&quot;&gt; &lt;p&gt; &lt;label for=&quot;myname&quot;&gt;用户名：&lt;/label&gt; &lt;!-- id和name最好同时写上 --&gt; &lt;input id=&quot;myname&quot; name=&quot;myname&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;email&quot;&gt;E-Mail：&lt;/label&gt; &lt;input id=&quot;email&quot; name=&quot;email&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;password&quot;&gt;登陆密码：&lt;/label&gt; &lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;confirm_password&quot;&gt;确认密码：&lt;/label&gt; &lt;input id=&quot;confirm_password&quot; name=&quot;confirm_password&quot; type=&quot;password&quot; /&gt; &lt;/p&gt; &lt;p&gt; &lt;input class=&quot;submit&quot; type=&quot;submit&quot; value=&quot;立即注册&quot; /&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 常用方法及注意问题1、用其他方式替代默认的submit12345678$(function()&#123; $(&quot;#signupForm&quot;).validate(&#123; submitHandler:function(form)&#123; alert(&quot;submit!&quot;); form.submit(); &#125; &#125;);&#125;); 可以设置validate的默认值，写法如下：123$.validator.setDefaults(&#123;submitHandler: function(form) &#123; alert(&quot;submit!&quot;); form.submit(); &#125;&#125;); 如果想提交表单，需要使用form.submit()，而不要使用$(form).submit() 2、debug，只验证不提交表单如果这个参数为true，那么表单不会提交，只进行检查，调试时十分方便12345$(function()&#123; $(&quot;#signupForm&quot;).validate(&#123; debug:true &#125;);&#125;); 如果一个页面中有多个表单都想设置成为debug，用123$.validator.setDefaults(&#123;debug: true&#125;) 3、ignore：忽略某些元素不验证1ignore: &quot;.ignore&quot; 4、更改错误信息显示的位置1errorPlacement：Callback Default: 把错误信息放在验证的元素后面指明错误放置的位置，默认情况是：1234```errorPlacement: function(error, element) &#123; error.appendTo(element.parent()); &#125; //示例12345678910111213141516171819202122232425262728293031323334&lt;tr&gt; &lt;td class=&quot;label&quot;&gt;&lt;label id=&quot;lfirstname&quot; for=&quot;firstname&quot;&gt;First Name&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;field&quot;&gt;&lt;input id=&quot;firstname&quot; name=&quot;firstname&quot; type=&quot;text&quot; value=&quot;&quot; maxlength=&quot;100&quot; /&gt;&lt;/td&gt; &lt;td class=&quot;status&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td style=&quot;padding-right: 5px;&quot;&gt; &lt;input id=&quot;dateformat_eu&quot; name=&quot;dateformat&quot; type=&quot;radio&quot; value=&quot;0&quot; /&gt; &lt;label id=&quot;ldateformat_eu&quot; for=&quot;dateformat_eu&quot;&gt;14/02/07&lt;/label&gt; &lt;/td&gt; &lt;td style=&quot;padding-left: 5px;&quot;&gt; &lt;input id=&quot;dateformat_am&quot; name=&quot;dateformat&quot; type=&quot;radio&quot; value=&quot;1&quot; /&gt; &lt;label id=&quot;ldateformat_am&quot; for=&quot;dateformat_am&quot;&gt;02/14/07&lt;/label&gt; &lt;/td&gt; &lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td class=&quot;label&quot;&gt;&amp;nbsp;&lt;/td&gt; &lt;td class=&quot;field&quot; colspan=&quot;2&quot;&gt; &lt;div id=&quot;termswrap&quot;&gt; &lt;input id=&quot;terms&quot; type=&quot;checkbox&quot; name=&quot;terms&quot; /&gt; &lt;label id=&quot;lterms&quot; for=&quot;terms&quot;&gt;I have read and accept the Terms of Use.&lt;/label&gt; &lt;/div&gt; &lt;/td&gt;&lt;/tr&gt;errorPlacement: function(error, element) &#123; if (element.is(&quot;:radio&quot;)) error.appendTo(element.parent().next().next()); else if (element.is(&quot;:checkbox&quot;)) error.appendTo(element.next()); else error.appendTo(element.parent().next());&#125; 代码的作用是：一般情况下把错误信息显示在class12```errorClass：String Default: &quot;error&quot; 指定错误提示的css类名，可以自定义错误提示的样式1errorElement：String Default: &quot;label&quot; 用什么标签标记错误，默认的是label你可以改成em1errorContainer：Selector 显示或者隐藏验证信息，可以自动实现有错误信息出现时把容器属性变为显示，无错误时隐藏，用处不大123errorContainer: &quot;#messageBox1, #messageBox2&quot;errorLabelContainer：Selector 把错误信息统一放在一个容器里面。1wrapper：String 用什么标签再把上边的errorELement包起来 一般这三个属性同时使用，实现在一个容器内显示所有错误提示的功能，并且没有信息时自动隐藏123errorContainer: &quot;div.error&quot;,errorLabelContainer: $(&quot;#signupForm div.error&quot;),wrapper: &quot;li&quot; 5、更改错误信息显示的样式设置错误提示的样式，可以增加图标显示，在该系统中已经建立了一个validation.css专门用于维护校验文件的样式1234567891011input.error &#123; border: 1px solid red; &#125;label.error &#123; background:url(&quot;./demo/images/unchecked.gif&quot;) no-repeat 0px 0px; padding-left: 16px; padding-bottom: 2px; font-weight: bold; color: #EA5200;&#125;label.checked &#123; background:url(&quot;./demo/images/checked.gif&quot;) no-repeat 0px 0px;&#125; 6、每个字段验证通过执行函数1success：String,Callback 要验证的元素通过验证后的动作，如果跟一个字符串，会当做一个css类，也可跟一个函数12345success: function(label) &#123; // set &amp;nbsp; as text for IE label.html(&quot;&amp;nbsp;&quot;).addClass(&quot;checked&quot;); //label.addClass(&quot;valid&quot;).text(&quot;Ok!&quot;)&#125; 添加”valid”到验证元素, 在CSS中定义的样式&#123;&#125;```12345678910111213141516171819success: &quot;valid&quot;7、验证的触发方式修改下面的虽然是boolean型的，但建议除非要改为false,否则别乱添加。a.onsubmit：Boolean Default: true 提交时验证. 设置唯false就用其他方法去验证b.onfocusout：Boolean Default: true 失去焦点是验证(不包括checkboxes/radio buttons)c.onkeyup：Boolean Default: true 在keyup时验证.d.onclick：Boolean Default: true 在checkboxes 和 radio 点击时验证e.focusInvalid：Boolean Default: true 提交表单后，未通过验证的表单(第一个或提交之前获得焦点的未通过验证的表单)会获得焦点f.focusCleanup：Boolean Default: false 如果是true那么当未通过验证的元素获得焦点时，移除错误提示。避免和focusInvalid一起用8、异步验证remote：URL使用ajax方式进行验证，默认会提交当前验证的值到远程地址，如果需要提交其他的值，可以使用data选项 //示例一：remote: “check-email.php”//示例二：remote: { url: “check-email.php”, //后台处理程序 type: “post”, //数据发送方式 dataType: “json”, //接受数据格式 data: { //要传递的数据 username: function() { return $(“#username”).val(); } }}123456远程地址只能输出&quot;true&quot;或&quot;false&quot;，不能有其它输出。9、添加自定义校验addMethod：name, method, message自定义验证方法 // 中文字两个字节jQuery.validator.addMethod( “byteRangeLength”, function(value, element, param) { var length = value.length; for(var i = 0; i &lt; value.length; i++){ if(value.charCodeAt(i) &gt; 127){ length++; } } return this.optional(element) || (length &gt;= param[0] &amp;&amp; length &lt;= param[1]); }, $.validator.format(“请确保输入的值在{0}-{1}个字节之间(一个中文字算2个字节)”)); // 邮政编码验证jQuery.validator.addMethod(“isZipCode”, function(value, element) { var tel = /^[0-9]{6}$/; return this.optional(element) || (tel.test(value));}, “请正确填写您的邮政编码”);12345671.要在additional-methods.js文件中添加或者在jquery.validate.js添加建议一般写在additional-methods.js文件中2.在messages_cn.js文件添加：isZipCode: &quot;只能包括中文字、英文字母、数字和下划线&quot;,调用前要添加对additional-methods.js文件的引用。10、radio和checkbox、select的验证 //1.radio的required表示必须选中一个 //2.checkbox的required表示必须选中 //checkbox的minlength表示必须选中的最小个数,maxlength表示最大的选中个数,rangelength:[2,3]表示选中个数区间 //3.select的required表示选中的value不能为空 Buga Baga Oi //select的minlength表示选中的最小个数（可多选的select）,maxlength表示最大的选中个 数,rangelength:[2,3]表示选中个数区间 Banana Apple Peach Turtle`","tags":[{"name":"jQuery.Validate.js","slug":"jQuery-Validate-js","permalink":"http://tawen.github.io/tags/jQuery-Validate-js/"}]},{"title":"ES6系列（一）迭代器、for-of循环和生成器 Generators","date":"2017-02-17T02:23:05.000Z","path":"2017/02/17/blog20170217/","text":"for-of循环for循环的疑问起初我们如何遍历数组中的元素呢？20年前JavaScript刚萌生时，你可能这样实现数组遍历：1234var myArray = [&apos;2&apos;,&apos;3&apos;,&apos;aaa&apos;];for (var index = 0; index &lt; myArray.length; index++) &#123; console.log(myArray[index]);&#125; 自ES5正式发布后，你可以使用内建的forEach方法来遍历数组： 123myArray.forEach(function (value) &#123; console.log(value);&#125;); 使用forEach的这段代码看起来更加简洁，但这种方法也有一个小缺陷：你不能使用break语句中断循环，也不能使用return语句返回到外层函数。是不是呢？你们可以进行相关的验证，同时呢它在浏览器兼容与支持方面并不理想，所以我们会想起for循环来。当然，如果只用for循环的语法来遍历数组元素也很不错，就如上面的第一个例子。那么，你一定想尝试一下for-in循环：123for (var index in myArray) &#123; // 千万别这样做 console.log(myArray[index]);&#125; 这绝对是一个糟糕的选择，为什么呢？ 在这段代码中，赋给index的值不是实际的数字，而是字符串“0”、“1”、“2”，而你呢？此时很可能在无意之间需要进行相关计算，但这是这不是数值的计算了，而是字符串算数计算，例如：“2” + 1 == “21”，这给编码过程带来极大的不便。 作用于数组的for-in循环体除了遍历数组元素外，还会遍历自定义属性。举个例子，如果你的数组中有一个可枚举属性myArray.name，循环将额外执行一次，遍历到名为“name”的索引。就连数组原型链上的属性都能被访问到。 最让人震惊的是，在某些情况下，这段代码可能按照随机顺序遍历数组元素。 简而言之，for-in是为普通对象设计的，你可以遍历得到字符串类型的键，因此不适用于数组遍历。 其实啰里啰唆说了这么多你就记住一句话：for-in是用于遍历对象的，普通for循环和forEach是遍历普通数组的。 如果有天你想要遍历对象又要得到它的键值，这里举例说明： 123456789101112131415var obj = &#123; &apos;name&apos;: &apos;言墨儿&apos;, &apos;age&apos;: 21&#125;;console.log(Object.keys(obj)) // 返回的是一个数组// 不推荐for-infor (var val in Object.keys(obj)) &#123; console.log(val); // 获得键值key-字符串 console.log(Object.keys(obj)[val]); // name、age-(获得键值key对应的数据)&#125;// 推荐for循环for (var i = 0; i &lt; Object.keys(obj).length; i++) &#123; console.log(i); // 获得键值key-数字 console.log(Object.keys(obj)[i]); // name、age-(获得键值key对应的数据)&#125; 强大的for-of循环为了解决这些问题所以新的循环方式在ES6中出现了，当然ES6不会破坏你已经写好的JS代码。目前，成千上万的Web网站依赖for-in循环，其中一些网站甚至将其用于数组遍历。而如果想通过修正for-in循环增加数组遍历支持会让这一切变得更加混乱，因此，标准委员会在ES6中增加了一种新的循环语法来解决目前的问题。就像这样： 12345// for-of循环支持数组遍历和大多数类数组对象var myArray = [&apos;2&apos;,&apos;3&apos;,&apos;aaa&apos;]for (var value of myArray) &#123; console.log(value); // 2，3，aaa&#125; 是的，与之前的内建方法相比，这种循环方式看起来是否有些眼熟？那好，我们将要探究一下for-of循环的外表下隐藏着哪些强大的功能。现在，你只需记住： 这是最简洁、最直接的遍历数组元素的语法 这个方法避开了for-in循环的所有缺陷 与forEach()不同的是，它可以正确响应break、continue和return语句 表面看来for-in循环用来遍历对象属性，for-of循环用来遍历数据—例如数组中的值。但是，for-of不仅如此！for-of循环也可以遍历其它的集合，for-of循环不仅支持数组，还支持大多数类数组对象，例如DOM NodeList对象。同时，for-of循环也支持字符串遍历，它将字符串视为一系列的Unicode字符来进行遍历： 123for (var chr of &quot;yanmoer&quot;) &#123; console.log (chr); // y,a,n,m,o,e,r&#125; 它同样支持Map和Set对象遍历。很多人也许没听说过Map和Set对象。他们是ES6中新增的类型。不知道也没有关系，我将在后面简单讲解这两个新的类型，如果你还有兴趣，你可以点击我存放的连接。如果你曾在其它语言中使用过Map和Set对象，你会发现ES6中的并无太大出入。其实讲简单点就是Set对象可以自动排除重复项：12345678// 基于单词数组创建一个set对象var words = [&apos;yanmoer&apos;,&apos;qinni&apos;,&apos;yanmoer&apos;]var uniqueWords = new Set(words); // 如果成为Set对象，输出结果会去掉重复项console.log(uniqueWords); // Set &#123;&quot;yanmoer&quot;, &quot;qinni&quot;&#125;// 生成Set对象后，你可以轻松遍历它所包含的内容：for (var word of uniqueWords) &#123; console.log(word); // yanmoer,qinni&#125; Set对象还有一些方法，这里不一一列举了，详情请见官网api：Set对象Map对象则稍有不同：内含的数据由键值对组成，所以你需要使用解构（destructuring）来将键值对拆解为两个独立的变量，例子说明：1234var phoneBookMap = [[&apos;name&apos;,&apos;yanmo&apos;],[&apos;age&apos;,&apos;22&apos;]]; // Map对象就是这样的for (var [key, value] of phoneBookMap) &#123; // [key, value]就是解构 console.log(key + &quot; : &quot; + value); //&apos;name&apos; : &apos;yanmo&apos;,&apos;age&apos; : &apos;22&apos;&#125; 其实Map对象就是简单的键/值映射。其中键和值可以是任意值(对象或者原始值)。关于Map对象的方法，也是详情请见官网api：Map对象解构也是ES6的新特性，简单说来解构赋值就是允许你使用类似数组或对象字面量的语法将数组和对象的属性赋给各种变量，我将在后续的文章中进行讲解。看来我应该记录这些优秀的问题，未来再进行相关新内容的一一剖析。 现在，你只需记住：未来的JS可以使用一些新型的集合类，甚至会有更多的类型陆续诞生，而for-of就是为遍历所有这些集合特别设计的循环语句。 for-of循环不支持普通对象，你应当用用for-in循环（这也是它的本职工作）或内建的Object.keys()方法：123456789// 向控制台输出对象的可枚举属性var someObject = &#123; classA: &apos;textColor&apos;, classB: &apos;textSize&apos;, isA: false &#125;for (var key of Object.keys(someObject)) &#123; console.log(key + &quot;: &quot; + someObject[key]); // classA: &apos;textColor&apos;,classB: &apos;textSize&apos;,isA: false&#125; 深入理解前言结合我的实践和运用，ES6及以后ES的后继者都会坚持这样一个规律：凡是新加入的特性，势必已在其它语言中得到强有力的实用性证明。 举个例子，新加入的for-of循环像极了C++、Java、C#以及Python中的循环语句。与它们一样，这里的for-of循环支持语言和标准库中提供的几种不同的数据结构。它同样也是这门语言中的一个扩展点（关于扩展点，建议参考 1. 浅析扩展点 2. What are extensions and extension points?,连接给你们了有兴趣了可以研究，没兴趣了也没关系，继续）。 正如其它语言中的for/foreach语句一样，for-of循环语句通过方法调用来遍历各种集合。数组、Maps对象、Sets对象以及其它在我们讨论的对象有一个共同点，它们都有一个迭代器方法。 你可以给任意类型的对象添加迭代器方法。 当你为对象添加myObject.toString()方法后，就可以将对象转化为字符串，同样地，当你向任意对象添加myObjectSymbol.iterator方法，就可以遍历这个对象了。你们一定很疑问那个[Symbol.iterator]语法是什么情况，这段代码到底做了什么呢？这里通过Symbol处理了一下方法的名称，ES标准委员会可以把这个方法命名为.iterator()方法，但是如果你的代码中的对象可能也有一些.iterator()方法，这不是最好的解决方法。于是在ES6标准中使用symbol来作为方法名，而不是使用字符串。同时，Symbols也是ES6中的新类型。 现在，你需要记住，基于新标准，你可以定义一个全新的symbol，就像Symbol.iterator，如此一来可以保证不与任何已有代码产生冲突。这样做的代价是，这段代码的语法看起来会略显生硬，但是这微乎其微代价却可以为你带来如此多的新特性和新功能，并且你所做的这一切可以完美地向后兼容。 所有拥有Symbol.iterator的对象被称为可迭代的。对于ES来说可迭代对象的概念几乎贯穿于整门语言之中，不仅是for-of循环，还有Map和Set构造函数、解构赋值，以及新的展开操作符。 迭代器对象现在，你将无须亲自从零开始实现一个对象迭代器，我会在以后的文章详细讲解，在这里我们只简单了解一下迭代器：for-of循环首先调用集合的Symbol.iterator方法，紧接着返回一个新的迭代器对象。迭代器对象可以是任意具有.next()方法的对象；for-of循环将重复调用这个方法，每次循环调用一次。举个例子，这段代码是我能想出来的最简单的迭代器,这里我们不添加for-of循环进行控制台的输出： 1234567891011// 对象迭代var zeroesForeverIterator = &#123; [Symbol.iterator]: function () &#123; // 简而言之只是一个方法 return this; &#125;, next: function () &#123; // next return &#123;done: false, value: 0&#125;; &#125;&#125;;console.log(zeroesForeverIterator.next()); // Object &#123;done: false, value: 0&#125;console.log(zeroesForeverIterator[Symbol.iterator]()); // 获得是zeroesForeverIterator我们自定义的对象 如果我们加上for-of循环：12345console.log(zeroesForeverIterator.next()); // Object &#123;done: false, value: 0&#125;console.log(zeroesForeverIterator[Symbol.iterator]()); // Object &#123;&#125;for (var value of zeroesForeverIterator) &#123; console.log(value); // 0&#125; 相信大家也在网上其他地方看过，每当解释这里都是乱说一通，到最后谁也不明白，经过我的叙述我想到这里大家也都了解了有些眉目，其实只要你细心，我们会发现如果我们加上for-of循环，for-of循环每一次调用.next()方法，它都返回相同的结果，其实返回给for-of循环的结果有两种可能： 1、我们尚未完成迭代 2、下一个值为0。这意味着for (var value of zeroesForeverIterator) {}将会是一个无限循环。当然，一般来说迭代器不会如此简单。 这个迭代器的设计，以及它的.done和.value属性，从表面上看与其它语言中的迭代器不太一样。在Java中，迭代器有分离的.hasNext()和.next()方法。在Python中，他们只有一个.next() 方法，当没有更多值时抛出StopIteration异常。 但是所有这三种设计从根本上讲都返回了相同的信息。 迭代器对象也可以实现可选的.return()和.throw(exc)方法。如果for-of循环过早退出会调用.return()方法，异常、break语句或return语句均可触发过早退出。如果迭代器需要执行一些清洁或释放资源的操作，可以在.return()方法中实现。大多数迭代器方法无须实现这一方法。.throw(exc)方法的使用场景就更特殊了：for-of循环永远不会调用它。但是我们还是会在以后更详细地讲解它的作用。 现在我们已了解所有细节，可以写一个简单的for-of循环然后按照下面的方法调用重写被迭代的对象。首先是for-of循环： 123for (var val of obj) &#123; // 一些语句&#125; 然后是一个使用以下方法和少许临时变量实现的与之前大致相当的示例： 1234567var $iterator = ITERABLE[Symbol.iterator]();var $result = $iterator.next();while (!$result.done) &#123; val = $result.value; 一些语句 $result = $iterator.next();&#125; 这段代码没有展示.return()方法是如何处理的，我们可以添加这部分代码，但我认为这对于我们正在讲解的内容来说过于复杂了。for-of循环用起来很简单，但是其背后有着非常复杂的机制。 生成器ES6生成器（Generators）简介 什么是生成器？不懂得人一定会疑问，首先我们从一个示例开始：1234567891011121314function* quips(name) &#123; yield &quot;你好 &quot; + name + &quot;!&quot;; yield &quot;希望你能喜欢这篇详细介绍ES6的文章&quot;; if (name.startsWith(&quot;X&quot;)) &#123; yield &quot;你的名字&quot; + name + &quot;真他妈吊&quot;; &#125; yield &quot;我们下次再见！&quot;;&#125;var iter = quips(&quot;读者&quot;);console.log(iter) // [object Generator]console.log(iter.next()) // Object &#123; value: &quot;你好 jorendorff!&quot;, done: false &#125;console.log(iter.next())// Object &#123; value: &quot;希望你能喜欢这篇介绍ES6的译文&quot;, done: false &#125;console.log(iter.next()) // Object &#123; value: &quot;我们下次再见！&quot;, done: false &#125;console.log(iter.next()) / Object &#123; value: undefined, done: true &#125; 这段代码看起来很像一个函数，我们称之为生成器函数，它与普通函数有很多共同点，但是二者有如下区别： 1、普通函数使用function声明，而生成器函数使用function 声明，function 只是一种写法罢了。 2、在生成器函数内部，有一种类似return的语法：关键字yield。二者的区别是，普通函数只可以return一次，而生成器函数可以yield多次（当然也可以只yield一次）。在生成器的执行过程中，遇到yield表达式立即暂停，后续可使用例如.next()恢复执行状态。 这就是普通函数和生成器函数之间最大的区别，普通函数不能自暂停，生成器函数可以。生成器做了什么？当你在我上面的例子中调用quips()生成器函数时发生了什么，那么生成器他就做了什么，写的这么详细，我想大家应该能看懂。 ES6生成器（Generators）案例详解说明 我们大概已经习惯了普通函数的使用方式，当你调用它们时，它们立即开始运行，直到遇到return或抛出异常时才退出执行，作为JS程序员你一定深谙此道。 生成器调用看起来非常类似：quips(“jorendorff”)。但是，当你调用一个生成器时，它并非立即执行，而是返回一个已暂停的生成器对象（上述实例代码中的iter）。你可将这个生成器对象视为一次函数调用，只不过立即冻结了，即在你调用生成器，并且还没有使用过.next()方法前，它就好像恰好在生成器函数的最顶端的第一行代码之前冻结了，暂停在那里。 每当你调用生成器对象的.next()方法时，函数调用将其自身解冻并一直运行到下一个yield表达式，再次暂停。这也是在上述代码中我们每次都调用iter.next()的原因，我们获得了quips()函数体中yield表达式生成的不同的字符串值。 当我们调用最后一个iter.next()时，我们最终抵达生成器函数的末尾，所以返回结果中done的值为true。抵达函数的末尾意味着没有返回值，所以返回结果中value的值为undefined。(注：你可以借此判断是不是抵达生成器函数的末尾) 现在你也可以尝试在循环中加入一个yield，看看会发生什么？ ES6生成器（Generators）深入 如果用专业术语描述，每当生成器执行yields语句，生成器的堆栈结构（本地变量、参数、临时值、生成器内部当前的执行位置）被移出堆栈。然而，生成器对象保留了对这个堆栈结构的引用（备份），所以稍后调用.next()可以重新激活堆栈结构并且继续执行。 值得特别一提的是，生成器不是线程，在支持线程的语言中，多段代码可以同时运行，通通常导致竞态条件和非确定性，不过同时也带来不错的性能。生成器则完全不同。当生成器运行时，它和调用者处于同一线程中，拥有确定的连续执行顺序，永不并发，(即类似同步执行)。与系统线程不同的是，生成器只有在其函数体内标记为yield的点才会暂停。 现在，我们了解了生成器的原理，领略过生成器的运行、暂停恢复运行的不同状态。那么，这些奇怪的功能究竟有何用处？ 生成器是迭代器！生成器与迭代器上面我大概讲了ES6的迭代器的概念和小例子，它是ES6中独立的内建类，同时也是语言的一个扩展点，通过实现Symbol.iterator和.next()两个方法你就可以创建自定义迭代器。 注：记住Symbol.iterator和.next()两个方法就可以创建自定义迭代器 生成器代替迭代器 实现一个接口不是一桩小事，我们一起实现一个迭代器。举个例子，我们创建一个简单的名为range迭代器，它可以简单地将两个数字之间的所有数相加。在这里我们使用ES6的类的解决方案（如果不清楚语法细节，无须担心，我也将在以后的文章中为你讲解）： 123456789101112131415161718192021222324252627// 实现一个迭代器:简单地将两个数字之间的所有数相加// 使用ES6的类的解决方案class RangeIterator &#123; constructor(start, stop) &#123; this.value = start; this.stop = stop; &#125; [Symbol.iterator]() &#123; return this; &#125; next() &#123; var value = this.value; if (value &lt; this.stop) &#123; this.value++; return &#123;done: false, value: value&#125;; &#125; else &#123; return &#123;done: true, value: undefined&#125;; &#125; &#125;&#125;// 返回一个新的迭代器，可以从start到stop计数。function range(start, stop) &#123; return new RangeIterator(start, stop);&#125;for (var value of range(0, 3)) &#123; console.log(&quot;ES6的类&quot; + value); // ES6的类0,ES6的类1,ES6的类2&#125; 这里的实现类似Java或Swift中的迭代器，不是很糟糕，但也不是完全没有问题。我们很难说清这段代码中是否有bug，这段代码看起来完全不像我们试图模仿的传统for (;;)循环，迭代器协议迫使我们拆解掉循环部分。此时此刻你对迭代器可能尚无感觉，他们用起来很好，但看起来有些难以实现和理解。 你大概不会为了使迭代器更易于构建从而建议我们为JS语言引入一个离奇古怪又野蛮的新型控制流结构，但是既然我们有生成器，并且包含Symbol.iterator和.next()两个方法就可以创建自定义迭代器，那么我们是否可以在这里应用生成器来解决问题呢？一起尝试一下： 1234567891011// 生成器解决：var oldValue = 0for (var value of range1(0, 3)) &#123; console.log(&quot;生成器&quot; + value); // 生成器0,生成器1,生成器2 console.log(oldValue + value); // 0,1,3 oldValue = value;&#125;function* range1(start, stop) &#123; for (var i = start; i &lt; stop; i++) yield i;&#125; 以上简便代码实现的生成器完全可以替代之前引入了一整个RangeIterator类的代码的实现。可行的原因是：生成器是迭代器。因为所有的生成器都有内建.next()和Symbol.iterator方法的实现。所以你只须编写循环部分的行为。而不再需要写Symbol.iterator和.next()两个方法来创建自定义迭代器。 生成器的最大效力 我们都非常讨厌被迫用古怪语态写一封很长的邮件，不借助生成器实现迭代器的过程与之类似，令人痛苦不堪。当你的语言不再简练，说出的话就会变得难以理解。上面RangeIterator类的实现代码很长并且非常奇怪，因为你需要在不借助循环语法的前提下为它添加循环功能的描述。所以生成器是最好的解决方案！ 我们如何发挥作为迭代器的生成器所产生的最大效力？ 使任意对象可迭代（上面关于迭代器的例子，为对象添加Symbol.iterator和.next()方法）。编写生成器函数遍历这个对象，运行时yield每一个值。然后将这个生成器函数作为这个对象的[Symbol.iterator]方法。 简化数组构建函数。假设你有一个函数，每次调用的时候返回一个数组结果。就像这样：12345678910111213141516171819202122// 拆分一维数组icons变为二维// 普通实现function splitIntoRows(icons, rowLength) &#123; var rows = []; for (var i = 0; i &lt; icons.length; i += rowLength) &#123; rows.push(icons.slice(i, i + rowLength)); &#125; return rows;&#125;var icons = [1,2,3,4,5,6,7,8,9,0]console.log(JSON.stringify(splitIntoRows(icons, 2))); // [[1,2],[3,4],[5,6],[7,8],[9,0]]// 生成器创建function* splitInto(icons, rowLength) &#123; for (var i = 0; i &lt; icons.length; i += rowLength) &#123; yield icons.slice(i, i + rowLength); &#125;&#125;var str = [1,2,3,4,5,6,7,8,9,0]for (var value of splitInto(str, 2)) &#123; console.log(&quot;生成器创建数组&quot; + value); // 生成器创建数组1,2 生成器创建数组3,4...生成器创建数组9,0&#125;console.log(splitInto(str, 2).next()); // Object &#123;value: Array[2], done: false&#125; 行为上唯一的不同是，传统写法立即计算所有结果并返回一个数组类型的结果，使用生成器则返回一个迭代器，每次根据需要逐一地计算结果。 你一定会疑问，这可以用来做什么？ 获取异常尺寸的结果。你无法构建一个无限大的数组，但是你可以返回一个可以生成一个永无止境的序列的生成器，每次调用可以从中取任意数量的值。 重构复杂循环。你是否写过又丑又大的函数？你是否愿意将其拆分为两个更简单的部分？现在，你的重构工具箱里有了新的利刃——生成器。当你面对一个复杂的循环时，你可以拆分出生成数据的代码，将其转换为独立的生成器函数，然后使用for (var data of myNewGenerator(args))遍历我们所需的数据。 构建与迭代相关的工具。ES6不提供用来过滤、映射以及针对任意可迭代数据集进行特殊操作的扩展库。借助生成器，我们只须写几行代码就可以实现类似的工具。 举个例子，假设你需要一个等效于Array.prototype.filter（filter()方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。），并且支持DOM NodeLists的方法，可以这样写123456789101112131415161718192021222324252627// 过滤数组中每一项对象的id属性是数字// 定义数组var arr = [ &#123; id: 15 &#125;, &#123; id: -1 &#125;, &#123; id: 0 &#125;, &#123; id: 3 &#125;, &#123; id: 12.2 &#125;, &#123; &#125;, &#123; id: null &#125;, &#123; id: NaN &#125;, &#123; id: &apos;undefined&apos; &#125;];var invalidEntries = 0; // 用来记录无效条目数function isNumber(obj) &#123; // 判断是不是数字 return obj!== undefined &amp;&amp; typeof(obj) === &apos;number&apos; &amp;&amp; !isNaN(obj);&#125;function filterByID(item) &#123; // 过滤id，是数字的返回true，否则返回false if (isNumber(item.id)) &#123; return true; &#125; invalidEntries++; return false;&#125;var arrByID = arr.filter(filterByID);console.log(&apos;过滤后的数组\\n&apos;, arrByID); // 过滤后的数组---[&#123; id: 15 &#125;, &#123; id: -1 &#125;, &#123; id: 0 &#125;, &#123; id: 3 &#125;, &#123; id: 12.2 &#125;]console.log(&apos;无效条目数 = &apos;, invalidEntries); // 无效条目数 = 4 借助生成器可以非常轻松地实现自定义迭代器，记住，迭代器贯穿ES6的始终，它是数据和循环的新标准。 生成器和异步代码及同步 异步API通常需要一个回调函数，这意味着你需要为每一次任务执行编写额外的异步函数。异步API拥有错误处理规则，不支持异常处理。不同的API有不同的规则，大多数的错误规则是默认的；在有些API里，甚至连成功提示都是默认的。生成器为你提供了避免异步代码问题的新思路。 实验性的Q.async()尝试结合promises使用生成器产生异步代码的等效同步代码。(async 函数就是 Generator 函数的语法糖,async 函数很多人认为它是异步操作的终极解决方案。)举个例子：1234567891011121314151617181920212223242526// 制造一些噪音的同步代码。function makeNoise() &#123; shake(); rattle(); roll();&#125;// 制造一些噪音的异步代码。// 返回一个Promise对象// 当我们制造完噪音的时候会变为resolvedfunction makeNoise_async() &#123; // 注意目前浏览器都只支持ES5，所以该代码会在浏览器上报错 return Q.async(function* () &#123; yield shake_async(); yield rattle_async(); yield roll_async(); &#125;);&#125;// Q.async()尝试结合promisesvar eventualAdd = Q.async(function* (oneP, twoP) &#123; var one = yield oneP; var two = yield twoP; return one + two;&#125;);eventualAdd(eventualOne, eventualTwo).then(function (three) &#123; three === 3;&#125;); 二者主要的区别是，异步版本必须在每次调用异步函数的地方添加yield关键字。要玩Q.async()请记得引入，并且在支持ES6转换为ES5的编辑器中编程。这里附上相关链接:Q.async()和q.js，以及async 函数的含义和用法 在Q.async版本中添加一个类似if语句的判断或try/catch块，如同向同步版本中添加类似功能一样简单。与其它异步代码编写方法相比，这种方法更自然，不像是学一门新语言一样辛苦。 生成器为我们提供了一个新的异步编程模型思路，这种方法更适合人类的大脑。此外，更好的语法或许会有帮助，ES7中有一个有关异步函数的提案，它基于promises和生成器构建，并从C#相似的特性中汲取了大量灵感。 如何应用这些疯狂的新特性？ 在服务器端，现在你可以在io.js中使用ES6（在Node中你需要使用–harmony这个命令行选项）。在浏览器端，到目前为止只有Firefox 27+和Chrome 39+支持了ES6生成器。如果要在web端使用生成器，你需要使用Babel或Traceur来将你的ES6代码转译为Web友好的ES5。 起初，JS中的生成器由Brendan Eich实现，他的设计参考了Python生成器，而此外Python生成器则受到Icon的启发。他们早在2006年就在Firefox 2.0中移植了相关代码。但是，标准化的道路崎岖不平，相关语法和行为都在原先的基础上有所改动。Firefox和Chrome中的ES6生成器都是由编译器hacker Andy Wingo实现的。 结语 生成器还有更多未提及的特性，例如：.throw()和.return()方法、可选参数.next()、yield*表达式语法。由于行文过长，估计各位观众老爷们已然疲乏，剩下的干货择机为大家献上。 由于我们接连搬了ES6的两座大山：迭代器和生成器，以及for-of,下次再给大家分享更好的ES6特性。","tags":[{"name":"迭代器","slug":"迭代器","permalink":"http://tawen.github.io/tags/迭代器/"},{"name":"for-of循环","slug":"for-of循环","permalink":"http://tawen.github.io/tags/for-of循环/"},{"name":"Generators","slug":"Generators","permalink":"http://tawen.github.io/tags/Generators/"}]},{"title":"Javascript深浅拷贝","date":"2017-02-13T02:23:05.000Z","path":"2017/02/13/blog20170213/","text":"Javascript有五种基本数据类型（也就是简单数据类型），它们分别是：Undefined，Null，Boolean，Number和String。还含有一种复杂数据类型，就是对象 注意Undefined和Null的区别，Undefined类型只有一个值，就是undefined，Null类型也只有一个值，也就是nullUndefined其实就是已声明未赋值的变量输出的结果null其实就是一个不存在的对象的结果1234var c;console.log(c)//undefinedconsole.log(document.getElementById(&apos;wsscat&apos;))//没有id为wsscat的节点,输出null 简单的数据类型和复杂的数据类型有以下重要的区别 对于简单数据类型它们值在占据了内存中固定大小的空间，并被保存在栈内存中。当一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本，还有就是不能给基本数据类型的值添加属性1234var a = 1;var b = a;a.attr = &apos;wsscat&apos;;console.log(a.attr)//undefined 上面代码中a就是简单数据类型（Number），b就是a的副本，它们两者都占有不同位置但相等的内存空间 对于复杂的数据类型复杂的数据类型即引用类型，它的值是对象，保存在堆内存中，包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针。从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。12345678var obj = &#123; name:&apos;wsscat&apos;, age:0 &#125; var obj2 = obj; obj2[&apos;c&apos;] = 5; console.log(obj);//Object &#123;name: &quot;wsscat&quot;, age: 0, c: 5&#125; console.log(obj2);////Object &#123;name: &quot;wsscat&quot;, age: 0, c: 5&#125; 我们可以看到obj赋值给obj2后，当我们更改其中一个对象的属性值，两个对象都发生了改变，究其原因局势因为obj和obj2这两个变量都指向同一个指针，赋值只是复制了指针，所以当我们改变其中一个的值就会影响另外一个变量的值 浅拷贝其实这段代码就是浅拷贝，有时候我们只是想备份数组，但是只是简单让它赋给一个变量，改变其中一个，另外一个就紧跟着改变，但很多时候这不是我们想要的 var obj = { name:’wsscat’, age:0 } var obj2 = obj; obj2[‘c’] = 5; console.log(obj);//Object {name: “wsscat”, age: 0, c: 5} console.log(obj2);////Object {name: “wsscat”, age: 0, c: 5} 深拷贝数组对于数组我们可以使用slice()和concat()方法来解决上面的问题 slice 12345var arr = [&apos;wsscat&apos;, &apos;autumns&apos;, &apos;winds&apos;]; var arrCopy = arr.slice(0); arrCopy[0] = &apos;tacssw&apos; console.log(arr)//[&apos;wsscat&apos;, &apos;autumns&apos;, &apos;winds&apos;] console.log(arrCopy)//[&apos;tacssw&apos;, &apos;autumns&apos;, &apos;winds&apos;] concat 12345var arr = [&apos;wsscat&apos;, &apos;autumns&apos;, &apos;winds&apos;]; var arrCopy = arr.concat(); arrCopy[0] = &apos;tacssw&apos; console.log(arr)//[&apos;wsscat&apos;, &apos;autumns&apos;, &apos;winds&apos;] console.log(arrCopy)//[&apos;tacssw&apos;, &apos;autumns&apos;, &apos;winds&apos;] 对象对象我们可以定义一个新的对象并遍历新的属性上去实现深拷贝123456789101112var obj = &#123; name:&apos;wsscat&apos;, age:0 &#125; var obj2 = new Object(); obj2.name = obj.name; obj2.age = obj.age obj.name = &apos;autumns&apos;; console.log(obj);//Object &#123;name: &quot;autumns&quot;, age: 0&#125; console.log(obj2);//Object &#123;name: &quot;wsscat&quot;, age: 0&#125; 当然我们可以封装好一个方法来处理对象的深拷贝，代码如下12345678910111213141516171819var obj = &#123; name: &apos;wsscat&apos;, age: 0 &#125; var deepCopy = function(source) &#123; var result = &#123;&#125;; for(var key in source) &#123; if(typeof source[key] === &apos;object&apos;) &#123; result[key] = deepCopy(source[key]) &#125; else &#123; result[key] = source[key] &#125; &#125; return result; &#125; var obj3 = deepCopy(obj) obj.name = &apos;autumns&apos;; console.log(obj);//Object &#123;name: &quot;autumns&quot;, age: 0&#125; console.log(obj3);//Object &#123;name: &quot;wsscat&quot;, age: 0&#125;","tags":[{"name":"Javascript深浅拷贝","slug":"Javascript深浅拷贝","permalink":"http://tawen.github.io/tags/Javascript深浅拷贝/"}]},{"title":"dropload【移动端下拉刷新、上拉加载更多插件】","date":"2017-02-09T02:23:05.000Z","path":"2017/02/09/blog20170208/","text":"移动端下拉刷新、上拉加载更多插件 下载地址：https://github.com/tawen/dropload 依赖 (dependence)Zepto 或者 jQuery 1.7以上版本，推荐jQuery 2.x版本（二者不要同时引用）Zepto or jQuery 1.7+，recommend to use jQuery 2.x（not use them at the same time） 使用方法 (usage)引用css和js(basic)12&lt;link rel=&quot;stylesheet&quot; href=&quot;../dist/dropload.css&quot;&gt;&lt;script src=&quot;../dist/dropload.min.js&quot;&gt;&lt;/script&gt; 1234567891011121314151617181920$(&apos;.element&apos;).dropload(&#123; scrollArea : window, loadDownFn : function(me)&#123; $.ajax(&#123; type: &apos;GET&apos;, url: &apos;json/more.json&apos;, dataType: &apos;json&apos;, success: function(data)&#123; alert(data); // 每次数据加载完，必须重置 me.resetload(); &#125;, error: function(xhr, type)&#123; alert(&apos;Ajax error!&apos;); // 即使加载出错，也得重置 me.resetload(); &#125; &#125;); &#125;&#125;); 参数列表 (options)API已知问题由于部分Android中UC和QQ浏览器头部有地址栏，并且一开始滑动页面隐藏地址栏时，无法触发scroll和resize，所以会导致部分情况无法使用。解决方案1：增加distance距离，例如DEMO2中distance:50；解决方案2：加meta使之全屏显示 12&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt;&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt;","tags":[{"name":"dropload","slug":"dropload","permalink":"http://tawen.github.io/tags/dropload/"}]},{"title":"jQuery源码分析--queue()队列方法","date":"2017-02-07T02:23:05.000Z","path":"2017/02/07/blog20170207/","text":"queue源码简化123456789101112jQuery.extend(&#123; queue push() dequeue shift() _queueHooks&#125;);jQuery.fn.extend(&#123; queue dequeue delay clearQueue promise&#125;); 基本用法 队列中存储的都是函数工具方法：123456789101112131415function aaa()&#123; alert(1);&#125;function bbb()&#123; alert(2);&#125;//$.queue( document , &apos;q1&apos; , aaa ); //$.queue( document , &apos;q1&apos; , bbb );//$.queue( document , &apos;q1&apos; , [aaa,bbb] ); //console.log( $.queue( document , &apos;q1&apos; ) );//$.dequeue( document,&apos;q1&apos; ); //aaa()//$.dequeue( document,&apos;q1&apos; ); //bbb() 实例方法:123456789101112131415function aaa()&#123; alert(1);&#125;function bbb()&#123; alert(2);&#125;$(document).queue(&apos;q1&apos;,aaa);$(document).queue(&apos;q1&apos;,bbb);//console.log( $(document).queue(&apos;q1&apos;) );$(document).dequeue(&apos;q1&apos;);$(document).dequeue(&apos;q1&apos;); 1234567891011121314151617181920212223242526272829303132333435$(this).animate(&#123;width : 300&#125;,2000).queue(function(next)&#123; $(this).css(&apos;height&apos;,300); next(); &#125;).animate(&#123;left : 300&#125;,2000);/*$(this).animate(&#123;width : 300&#125;,2000,function()&#123; //$(this).css(&apos;height&apos;,300); var This = this; var timer = setInterval(function()&#123; This.style.height = This.offsetHeight + 1 + &apos;px&apos;; if( This.offsetHeight == 200 )&#123; clearInterval(timer); &#125; &#125;,30); &#125;).animate(&#123;left : 300&#125;,2000);*/ this).animate(&#123;width : 300&#125;,2000).queue(function(next)&#123; var This = this; var timer = setInterval(function()&#123; This.style.height = This.offsetHeight + 1 + &apos;px&apos;; if( This.offsetHeight == 200 )&#123; next(); clearInterval(timer); &#125; &#125;,30); &#125;).animate(&#123;left : 300&#125;,2000); delay 延迟队列执行","tags":[{"name":"queue()","slug":"queue","permalink":"http://tawen.github.io/tags/queue/"}]},{"title":"CSS 专业技巧收集","date":"2017-02-06T02:05:05.000Z","path":"2017/02/06/blog20170206/","text":"一些CSS技巧的收集，能够帮助你提升专业水平。 使用 :not() 为导航添加/取消边框很多人会这样给导航添加边框，然后给最后一个取消掉： 123456789/* add border */.nav li &#123; border-right: 1px solid #666;&#125;/* remove border */.nav li:last-child &#123; border-right: none;&#125; 其实，用CSS的 :not() 可以简化为下面的代码：123.nav li:not(:last-child) &#123; border-right: 1px solid #666;&#125; 当然，你也可以使用 .nav li + li 甚至 .nav li:first-child ~ li，但是使用 :not() 可以使意图更加明确。 给 body 添加 line-height 属性你不需要为 ``` 分别添加 line-height 属性，相反的，只需要添加到 body 上即可：1234```body &#123; line-height: 1;&#125; 这样，文本元素就可以很容易的从 body 继承该属性。 垂直居中这并不是什么魔法，你可以垂直居中任何元素：123456789101112html, body &#123; height: 100%; margin: 0;&#125;body &#123; -webkit-align-items: center; -ms-flex-align: center; align-items: center; display: -webkit-flex; display: flex;&#125; 还需要其他的？水平居中、垂直居中，在任何时间、任何地方？可以看看CSS-Tricks的这篇文章。注意：flexbox 在 IE11 下存在一些bug。 使用逗号分割列表使列表看起来像是用逗号分割的：123ul &gt; li:not(:last-child)::after &#123; content: &quot;,&quot;;&#125; 通过 :not() 伪类去掉最后一个元素后面的逗号。 使用负的 nth-child 选取元素使用负的 nth-child 在 1 到 n 之间选择元素：123456789101112li &#123; display: none;&#125;/* 选择第1到3个元素并显示它们 */li:nth-child(-n+3) &#123; display: block;&#125;当然，如果你了解 :not() 的话，还可以这么做：li:not(:nth-child(-n+3)) &#123; display: none;&#125; 是不是非常简单？ 使用 SVG 作 icon 图标没什么理由不使用 SVG 作 icon 图标：123.logo &#123; background: url(&quot;logo.svg&quot;);&#125; SVG 对于任何分辨率的缩放效果都很好，并且支持 IE9+所有浏览器，所以，放弃使用 .png、.jpg、.gif文件吧。注：以下代码对于使用辅助设备上网的用户可以提升可访问性：123.no-svg .icon-only:after &#123; content: attr(aria-label);&#125; 文本展示优化有时候字体并不是对于所有设备都显示为最佳效果，所以使用浏览器来帮忙吧：12345html &#123; -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility;&#125; 使用 max-height 实现纯CSS幻灯片使用 max-height 与超出隐藏实现纯CSS的幻灯片：123456789.slider ul &#123; max-height: 0; overlow: hidden;&#125;.slider:hover ul &#123; max-height: 1000px; transition: .3s ease; /* animate to max-height */&#125; 继承 box-sizing让 box-sizing 继承自 html ：1234567html &#123; box-sizing: border-box;&#125;*, *:before, *:after &#123; box-sizing: inherit;&#125; 这使得在插件或者其他组件中修改 box-sizing 属性变得更加容易。 设置表格相同宽度123.calendar &#123; table-layout: fixed;&#125; 使用 Flexbox 来避免 Margin Hacks在做多列布局的时候，可以通过 Flexbox 的 space-between 属性来避免nth-、first-、 last-child 等 hacks：12345678.list &#123; display: flex; justify-content: space-between;&#125;.list .person &#123; flex-basis: 23%;&#125; 这样，列之间的空白就会被均匀的填满。 对空链接使用属性选择器当 中没有文本而 href 不为空的时候，显示其链接：123a[href^=&quot;http&quot;]:empty::before &#123; content: attr(href);&#125; 浏览器支持以上技巧支持大部分现代浏览器，如：Chrome、Firefox、Safari、Edge以及IE11。","tags":[{"name":"css技巧","slug":"css技巧","permalink":"http://tawen.github.io/tags/css技巧/"}]},{"title":"javascript","date":"2017-01-24T06:16:05.000Z","path":"2017/01/24/blog20170124/","text":"数据类型 6种原始值（不可变。“除非重置当前变量，否则不能改变元素值。”） Null(只有一个值： null) Undefined(一个没有被赋值的变量会有个默认值 undefined) Number Boolean(两个值：true 和 false) String Symbol 和Object(对象指内存中的可以被标识符引用的一块区域) 数据类型检测typeof(对变量或值调用 typeof 运算符将返回(字符串)下列值之一) * undefined - Undefined类型 * number - Number类型 * boolean - Boolean类型 * string - String类型 * symbol - Symbol类型(ECMAScript6新增) * function - 函数对象([[Call]]在ECMA-262条款中实现了) * object - 引用类型 或 Null类型 1234typeof(Function) // function (Function是函数对象)typeof(new Function) // function (new Function也是是函数对象，同等：var func = function()&#123;&#125;)typeof(Array) // function (Array是函数对象)typeof(new Array) // object（实例化的Array就是object） 变量赋值时候的返回值：12var name = 123; // 返回undefinedname = 456; // 返回456 结语：定义变量的时候赋值返回:undefined 给已声明变量赋值时候返回当前赋值。 获取元素距离页面的top、left1234567891011function getRec(ele) &#123; var _t = document.documentElement.clientTop, _l = document.documentElement.clientLeft, rect = ele.getBoundingClientRect(); return &#123; top: rect.top - _t, right: rect.right - _l, bottom: rect.bottom - _t, left: rect.left - _l &#125;&#125; 注意：IE、Firefox3+、Opera9.5、Chrome、Safari支持，在IE中，默认坐标从(2,2)开始计算，导致最终距离比其他浏览器多出两个像素，我们需要做个兼容。 数字的固定小数位数1234var a=8.88888, b=8;console.log(a.toFixed(2)); // 8.89 或者 8.88console.log(b.toFixed(2)); // 8.00 js是编译语言，数组长度是随时程序变化而变化的1234var arr = [0, 1];arr[3] = 3;console.log(arr[2]); // undefinedconsole.log(arr.length); // 4 矩阵的转置12345678910111213141516171819var arr = [ // 定义一个矩阵（二维数据） [1, 2, 3, 4], [5, 6, 6, 6], [7, 6, 7, 8], [8, 5, 3, 3]];function changeArr(arr) &#123; // 矩阵转置函数 var c; for (var i = 1; i &lt; arr.length; i++) &#123; for (var j = 0; j &lt; i; j++) &#123; c = arr[i][j]; arr[i][j] = arr[j][i]; arr[j][i] = c; &#125; &#125;&#125;changeArr(arr);console.table(arr); 冒泡排序方法123456789101112131415161718192021222324// 第一轮是对n-1的位置定位// 第二轮是 每一个位置的数的 确定var arr = [1, 4, 5, 6, 99, 111, 112, 113, 133], temp = 0, flag = false;for (var i = 0; i &lt; arr.length - 1; i++) &#123; document.writeln(&apos;come&apos;); for (var j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = true; &#125; &#125; if (flag) &#123; flag = false; &#125; else &#123; break; &#125;&#125;for (var i = 0; i &lt; arr.length; i++) &#123; document.writeln(arr[i]);&#125;; 二分查找1234567891011121314151617var arr = [41, 55, 76, 87, 88, 99, 123, 432, 546, 577, 688, 786];function twoFind(arr, wantVal, leftIndex, rightIndex) &#123; if (leftIndex &gt; rightIndex) &#123; document.writeln(&apos;SORRY: 找不到 &apos; + wantVal + &apos; ！&apos;); return; &#125; var minIndex = Math.floor((leftIndex + rightIndex) / 2); if (arr[minIndex] &gt; wantVal) &#123; twoFind(arr, wantVal, leftIndex, minIndex - 1); &#125; else if (arr[minIndex] &lt; wantVal) &#123; twoFind(arr, wantVal, minIndex + 1, rightIndex); &#125; else &#123; document.writeln(&apos;找到了 &apos; + wantVal + &apos; ,下表为&apos; + minIndex); &#125;&#125;twoFind(arr, 9, 0, arr.length - 1); js对象访问属性的二种方式123456function Person () &#123;&#125;;var new1 = new Person ();new1.name=&apos;冯杰&apos;;new1.age=21;window.alert(new1.name);window.alert(new1[&quot;age&quot;]); js之delete只能删除对象的属性123456function Person () &#123;&#125;;var me = new Person();me.name=&apos;冯杰&apos;;console.log(me.name);delete me.name;console.log(me.name); 在js中对象的方法不是通用的，如果生成n个对象，那么就有n个内存堆栈12345678910// js 中 一切类 继承自 Object 而Object 有propotype// 下面是解决办法 prototype 获得类的static性质function God() &#123;&#125;God.prototype.shout = function() &#123; window.alert(&apos;小狗叫&apos;);&#125;var dog1 = new God();var dog2 = new God();dog1.shout();dog2.shout(); 对象1234567891011121314151617181920212223242526272829// js里要想创建对象 除了一般的创建方式 还有 通过Object 方式创建类// Object 类是所有js类的基类 Object 就表示对象（一切的对象）var p1 = new Object();p1.name = &apos;fj&apos;;window.alert(p1.name);window.alert(p1.constructor);// 原型链上新增默认对象方法var num = new Number(1);var num2 = 10;window.alert(num.constructor);window.alert(num2.constructor);// 上面2个弹出是一样的Number.prototype.add = function(a) &#123; //prototype是属于类的 return this + a;&#125;window.alert(num.add(1).add(2));// 小实验 为Array 添加 find(val) 方法Array.prototype.find = function(a) &#123; for (var i = 0; i &lt; this.length; i++) &#123; if (this[i] == a) &#123; return i; &#125; &#125; return &apos;find fail.&apos;;&#125;var arr = [0, 1, 2, 77, 4, 5];window.alert(arr.find(77)); arguments12345678function abc() &#123; var sum = 0; for (var i = 0; i &lt; arguments.length; i++) &#123; sum += arguments[i]; &#125; return sum;&#125;window.alert(abc(1, 2, 3)); call函数目的就是改变对象的this指向12345678var Person = &#123; name: &apos;fjj&apos;&#125;;function test() &#123; window.alert(this.name);&#125;test.call(Person); 体会js的封装1234567function Person() &#123; var name = &apos;fj&apos;; //私有 this.age = 21; //共有&#125;var p1 = new Person();window.alert(p1.name); //undefinedwindow.alert(p1.age); //21 prototype的方法不能访问私有属性和方法12345678910111213function Person() &#123; var name = &apos;fj&apos;; //私有 this.age = 21;&#125;Person.prototype.showName = function() &#123; window.alert(this.name);&#125;Person.prototype.showAge = function() &#123; window.alert(this.age);&#125;var p1 = new Person();p1.showName();p1.showAge(); 继承12345678910111213141516// js 里面是对象冒充来继承的 不算是真正的继承 通过对象冒充 js可以实现多重继承和继承的效果 但是没有Extends关键字function Father(name, age) &#123; this.name = name; this.age = age; this.show = function() &#123; window.alert(this.name + &apos;---&apos; + this.age); &#125;&#125;function Son(name, age) &#123; this.Father = Father; this.Father(name, age); //通过对象冒充 实现继承 这一句非常重要 js是动态语言 不是编译语言 要执行才会分配空间&#125;var me = new Son(&apos;fj&apos;, 21);window.alert(me.name);me.show(); 重载1// js从常理来说是不支持重载的 但是又可以说是天然支持重载 因为js天然支持可变参数 而且我们可以通过arguments[]数组的长度判断 而做出相应的处理 闭包1// 闭包实际上设计一个对象的属性，何时被gc处理的问题 闭包和gc是相关联的 数组长度12345// 数组的长度是根据下标的最大而确定的var arr = new Array();arr[&apos;a&apos;] = 1;arr[&apos;b&apos;] = 2;window.alert(arr.length); // 打出0 LazyMan实现LazyMan（什么是LazyMan？请自行google） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function _LazyMan(_name) &#123; var _this = this; _this.tasks = []; _this.tasks.push(function() &#123; console.log(&apos;Hi! This is &apos; + _name + &apos;!&apos;); // 这里的this是window，所以要缓存this _this.next(); &#125;); setTimeout(function() &#123; _this.next(); &#125;, 0);&#125;// push函数里面的this和setTimeout函数里面的this都指向全局作用域，所以要缓存当前this指向_LazyMan.prototype.next = function() &#123; var _fn = this.tasks.shift(); _fn &amp;&amp; _fn();&#125;_LazyMan.prototype.sleep = function(_time) &#123; var _this = this; _this.tasks.push(function() &#123; setTimeout(function() &#123; console.log(&apos;Wake up after &apos; + _time); _this.next(); &#125;, _time); &#125;); return _this;&#125;_LazyMan.prototype.sleepFirst = function(_time) &#123; var _this = this; _this.tasks.unshift(function() &#123; setTimeout(function() &#123; console.log(&apos;Wake up after &apos; + _time); _this.next(); &#125;, _time); &#125;); return _this;&#125;_LazyMan.prototype.eat = function(_eat) &#123; var _this = this; _this.tasks.push(function() &#123; console.log(&apos;Eat &apos; + _eat); _this.next(); &#125;); return _this;&#125;// 封装对象var LazyMan = function(_name) &#123; return new _LazyMan(_name);&#125;","tags":[{"name":"js","slug":"js","permalink":"http://tawen.github.io/tags/js/"}]},{"title":"jQuery源码分析--data()数据缓存","date":"2017-01-23T02:23:05.000Z","path":"2017/01/23/blog20170123/","text":"data/attr/prop使用区别attr:jquery中attr是通过原生js的getAttribute和setAttribute方法来实现的；1234/*$(&apos;#div1&apos;).attr(&apos;name&apos;,&apos;hello&apos;); alert( $(&apos;#div1&apos;).attr(&apos;name&apos;) );*/document.getElementById(&apos;div1&apos;).setAttribute(&apos;name&apos;,&apos;hello&apos;);alert( document.getElementById(&apos;div1&apos;).getAttribute(&apos;name&apos;) ); prop：是通过原生dom对象的属性直接进行设置和获取属性值得； 1234/*$(&apos;#div1&apos;).prop(&apos;name&apos;,&apos;hello&apos;); alert( $(&apos;#div1&apos;).prop(&apos;name&apos;) );*/document.getElementById(&apos;div1&apos;)[&apos;name&apos;] = &apos;hello&apos;;alert( document.getElementById(&apos;div1&apos;)[&apos;name&apos;] ); data:设置大量数据（例如：json）；12$(&apos;#div1&apos;).data(&apos;name&apos;,&apos;hello&apos;); alert( $(&apos;#div1&apos;).data(&apos;name&apos;) ); 内存泄漏 内存泄漏：内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。 内存泄露的几种情况 循环引用 Javascript闭包 DOM插入顺序 一个DOM对象被一个Javascript对象引用，与此同时又引用同一个或其它的Javascript对象，这个DOM对象可能会引发内存泄漏。这个DOM对象的引用将不会在脚本停止的时候被垃圾回收器回收。要想破坏循环引用，引用DOM元素的对象或DOM对象的引用需要被赋值为null。 含有DOM对象的循环引用将导致大部分当前主流浏览器内存泄露 第一种：多个对象循环引用1234567var a=new Object;var b=new Object;a.r=b;b.r=a; 第二种：循环引用自己123var a=new Object;a.r=a; 循环引用很常见且大部分情况下是无害的，但当参与循环引用的对象中有DOM对象或者ActiveX对象时，循环引用将导致内存泄露。 我们把例子中的任何一个new Object替换成document.getElementById或者document.createElement就会发生内存泄露了。 具体的就深入讨论了，这里的总结 JS的内存泄露，无怪乎就是从DOM中remove了元素，但是依然有变量或者对象引用了该DOM对象。然后内存中无法删除。使得浏览器的内存占用居高不下。这种内存占用，随着浏览器的刷新，会自动释放。 而另外一种情况，就是循环引用，一个DOM对象和JS对象之间互相引用，这样造成的情况更严重一些，即使刷新，内存也不会减少。这就是严格意义上说的内存泄露了。 data原理利用cache对象间接把dom对象与数据联系到一起，这样有效的阻止了json数据和dom元素之间的循环引用导致的内存泄漏。 data源码简化版本12345678910111213141516171819202122232425262728293031jQuery.extend(&#123; acceptData hasData data removeData _data _removeData&#125;);jQuery.fn.extend(&#123; data removeData&#125;);Data.prototype = &#123; key set get access remove hasData discard&#125;;Data.prototype = &#123; key: function( owner ) //分配映射的 set: function( owner, data, value ) //设置cache get: function( owner, key ) //获取cache中属性 access: function( owner, key, value ) // remove: function( owner, key ) // 删除 hasData: function( owner ) // 判断是否存在 discard: function( owner ) // 删除 Object.preventExtensions/freeze 使对象只能获取不能修改12345678910111213141516var obj = &#123; name : &quot;hello&quot; &#125;;Object.freeze(obj);obj.name = &apos;hi&apos;;alert( obj.name );Object.defineProperty( obj, 0, &#123; get: function() &#123; return &#123;&#125;; &#125;&#125;);alert(obj[0]);obj[0] = 123;alert(obj[0]);","tags":[{"name":"data()","slug":"data","permalink":"http://tawen.github.io/tags/data/"}]},{"title":"JavaScript对象模型-执行模型","date":"2017-01-22T02:50:05.000Z","path":"2017/01/22/blog20170122/","text":"数据类型基本数据类型基本数据类型是JS语言最底层的实现。简单数值类型: 有Undefined, Null, Boolean, Number和String。注意，描述中的英文单词在这里仅指数据类型的名称，并不特指JS的全局对象N an, Boolean, Number, String等，它们在概念上的区别是比较大的。对象: 一个无序属性的集合，这些属性的值为简单数值类型、对象或者函数。同上，这里的对象并不特指全局对象Object。函数: 函数是对象的一种，实现上内部属性[[Class]]值为”Function”，表明它是函数类型，除了对象的内部属性方法外，还有[[Construct]]、[[Call]]、[[Scope]]等内部属性。函数作为函数调用与构造器(使用new关键字创建实例对象)的处理机制不一样(Function对象除外)，内部方法[[Construct]]用于实现作为构造器的逻辑，方法[[Call]]实现作为函数调用的逻辑。同上，这里的函数并不特指全局对象Function。函数在JS这个Prototype语言中可以看作是面向对象语言的类，可以用它来构造对象实例。既然函数可以看作是类，所以每一个函数可以看作是一种扩展数据类型。 内置数据类型(内置对象)Function: 函数类型的用户接口。Object: 对象类型的用户接口。Boolean, Number, String: 分别为这三种简单数值类型的对象包装器，对象包装在概念上有点类似C#中的Box/Unbox。Date, Array, RegExp: 可以把它们看作是几种内置的扩展数据类型。 首先，Function, Object, Boolean, Number, String, Date, Array, RegExp等都是JavaScript语言的内置对象，它们都可以看作是函数的派生类型，例如Number instanceof Function为true，Number instanceof Object为true。在这个意义上，可以将它们跟用户定义的函数等同看待。其次，它们各自可以代表一种数据类型，由JS引擎用native code或内置的JS代码实现，是暴露给开发者对这些内置数据类型进行操作的接口。在这个意义上，它们都是一种抽象的概念，后面隐藏了具体的实现机制。在每一个提到Number, Function等单词的地方，应该迅速的在思维中将它们实例化为上面的两种情况之一。 数据类型实现模型描述 Build-in data structure: 指JS内部用于实现**类型的数据结构，这些结构我们基本上无法直接操作。Build-in object: 指JS内置的Number, String, Boolean等这些对象，这是JS将内部实现的数据类型暴露给开发者使用的接口。Build-in constructor: 指JS内置的一些构造器，用来构造相应类型的对象实例。它们被包装成函数对象暴露出来，例如我们可以使用下面的方法访问到这些函数对象: 123456789101112//Passed in FF2.0, IE7, Opera9.25, Safari3.0.4//access the build-in number constructorvar number = new Number(123);var numConstructor1 = number.constructor; //orvar numConstructor2 = new Object(123).constructor;//both numConstructor1 and numConstructor2 are the build-in Number constructornumConstructor1 == numConstructor2 //result: true//access the build-in object constructorvar objConstructor1 = &#123;&#125;.constructor; //orvar objConstructor2 = new Object().constructor;//both objConstructor1 and objConstructor2 are the build-in Object constructorobjConstructor1==objConstructor2 //result: true 具体实现上，上图中横向之间可能也存在关联，例如对于build-in data structure和constructor，Function、 Date、 Array、 RegExp等都可以继承Object的结构而实现，但这是具体实现相关的事情了。 关于简单数值类型的对象化这是一个细微的地方，下面描述对于Boolean, String和Number这三种简单数值类型都适用，以Number为例说明。JS规范要求: 使用var num1=123;这样的代码，直接返回基本数据类型，就是说返回的对象不是派生自Number和Object类型，用num1 instanceof Object测试为false；使用new关键字创建则返回Number类型，例如var num2=new Number(123); num2 instanceof Number为true。将Number当作函数调用，返回结果会转换成简单数值类型。下面是测试代码: 1234567891011//Passed in FF2.0, IE7, Opera9.25, Safari3.0.4var num1 = new Number(123); //num1 derived from Number &amp; Objectnum1 instanceof Number //result: truenum1 instanceof Object //result: true//convert the num1 from Number type to primitive type, so it&apos;s no longer an instance of Number or Objectnum1 = Number(num1); num1 instanceof Number //result: falsenum1 instanceof Object //result: falsevar num2 = 123; //num2 is a primitive typenum2 instanceof Number //result: falsenum2 instanceof Object //result: false 虽然我们得到了一个简单数值类型，但它看起来仍然是一个JS Object对象，具有Object以及相应类型的所有属性和方法，使用上基本没有差别，唯一不同之处是instanceof的测试结果。 Prototype继承Prototype每个对象都有一个[[Prototype]]的内部属性，它的值为null或者另外一个对象。函数对象都有一个显示的prototype属性，它并不是内部[[Prototype]]属性。不同的JS引擎实现者可以将内部[[Prototype]]属性命名为任何名字，并且设置它的可见性，只在JS引擎内部使用。虽然无法在JS代码中访问到内部[Prototype]，但可以使用对象的isPrototypeOf()方法进行测试，注意这个方法会在整个Prototype链上进行判断。使用obj.propName访问一个对象的属性时，按照下面的步骤进行处理(假设obj的内部[[Prototype]]属性名为proto): 如果obj存在propName属性，返回属性的值，否则 如果obj.proto为null，返回undefined，否则 返回obj.proto.propName调用对象的方法跟访问属性搜索过程一样，因为方法的函数对象就是对象的一个属性值。提示: 上面步骤中隐含了一个递归过程，步骤3中obj.proto是另外一个对象，同样将采用1, 2, 3这样的步骤来搜索propName属性。 例如下图所示，object1将具备属性prop1, prop2, prop3以及方法fn1, fn2, fn3。图中虚线箭头表示prototype链。 这就是基于Prototype的继承和共享。其中object1的方法fn2来自object2，概念上即object2重写了object3的方法fn2。JavaScript对象应当都通过prototype链关联起来，最顶层是Object，即对象都派生自Object类型。 类似C++等面向对象语言用类(被抽象了的类型)来承载方法，用对象(实例化对象)承载属性，Prototype语言只用实例化的对象来承载方法和属性。本质区别是前者基于内存结构的描述来实现继承，后者基于具体的内存块实现。 对象创建过程JS中只有函数对象具备类的概念，因此要创建一个对象，必须使用函数对象。函数对象内部有[[Construct]]方法和[[Call]]方法，[[Construct]]用于构造对象，[[Call]]用于函数调用，只有使用new操作符时才触发[[Construct]]逻辑。var obj=new Object(); 是使用内置的Object这个函数对象创建实例化对象obj。var obj={};和var obj=[];这种代码将由JS引擎触发Object和Array的构造过程。function fn(){}; var myObj=new fn();是使用用户定义的类型创建实例化对象。 new Fn(args)的创建过程如下(即函数对象的[[Construct]]方法处理逻辑，对象的创建过程)。另外函数对象本身的创建过程(指定义函数或者用Function创建一个函数对象等方式)虽然也使用了下面的处理逻辑，但有特殊的地方，后面再描述。 创建一个build-in object对象obj并初始化 如果Fn.prototype是Object类型，则将obj的内部[[Prototype]]设置为Fn.prototype，否则obj的[[Prototype]]将为其初始化值(即Object.prototype) 将obj作为this，使用args参数调用Fn的内部[[Call]]方法 3.1 内部[[Call]]方法创建当前执行上下文 3.2 调用F的函数体 3.3 销毁当前的执行上下文 3.4 返回F函数体的返回值，如果F的函数体没有返回值则返回undefined 如果[[Call]]的返回值是Object类型，则返回这个值，否则返回obj注意步骤2中， prototype指对象显示的prototype属性，而[[Prototype]]则代表对象内部Prototype属性(隐式的)。构成对象Prototype链的是内部隐式的[[Prototype]]，而并非对象显示的prototype属性。显示的prototype只有在函数对象上才有意义，从上面的创建过程可以看到，函数的prototype被赋给派生对象隐式[[Prototype]]属性，这样根据Prototype规则，派生对象和函数的prototype对象之间才存在属性、方法的继承/共享关系。 用代码来做一些验证:123456789101112131415//Passed in FF2.0, IE7, Opera9.25, Safari3.0.4function fn()&#123;&#125;//the value of implicit [[Prototype]] property of those objects derived from fn will be assigned to fn.prototypefn.prototype=&#123; attr1:&quot;aaa&quot;, attr2:&quot;bbb&quot;&#125;;var obj=new fn();document.write(obj.attr1 + &quot;&lt;br /&gt;&quot;); //result: aaadocument.write(obj.attr2 + &quot;&lt;br /&gt;&quot;); //result: bbbdocument.write(obj instanceof fn); //result: truedocument.write(&quot;&lt;br /&gt;&quot;);//I change the prototype of fn here, so by the algorithm of Prototype the obj is no longer the instance of fn,//but this won&apos;t affect the obj and its [[Prototype]] property, and the obj still has attr1 and attr2 propertiesfn.prototype=&#123;&#125;;document.write(obj.attr1 + &quot;&lt;br /&gt;&quot;); //result: aaadocument.write(obj.attr2 + &quot;&lt;br /&gt;&quot;); //result: bbbdocument.write(obj instanceof fn); //result: false 关于创建过程返回值的验证:1234567891011//Passed in FF2.0, IE7, Opera9.25, Safari3.0.4function fn()&#123; //according to step 4 described above, //the new fn() operation will return the object &#123; attr1: 111, attr2: 222 &#125;, it&apos;s not an instance of fn! return &#123; attr1: 111, attr2: 222 &#125;;&#125;fn.prototype=&#123; attr1:&quot;aaa&quot;, attr2:&quot;bbb&quot;&#125;;var obj=new fn();document.write(obj.attr1 + &quot;&lt;br /&gt;&quot;); //result: 111document.write(obj.attr2 + &quot;&lt;br /&gt;&quot;); //result: 222document.write(obj instanceof fn); //result: false 做个练习经过上面的理解应，请写出下面这幅图的实现代码。图中CF是一个函数，Cfp是CF的prototype对象，cf1, cf2, cf3, cf4, cf5都是CF的实例对象。虚线箭头表示隐式Prototype关系，实线箭头表示显示prototype关系。 供参考的实现方案:123456789101112131415//Passed in FF2.0, IE7, Opera9.25, Safari3.0.4function CF(q1, q2)&#123; this.q1=q1; this.q2=q2;&#125;CF.P1=&quot;P1 in CF&quot;; CF.P2=&quot;P2 in CF&quot;;function Cfp()&#123; this.CFP1=&quot;CFP1 in Cfp&quot;;&#125;CF.prototype=new Cfp();var cf1=new CF(&quot;aaa&quot;, &quot;bbb&quot;);document.write(cf1.CFP1 + &quot;&lt;br /&gt;&quot;); //result: CFP1 in Cfpdocument.write(cf1.q1 + &quot;&lt;br /&gt;&quot;); //result: aaadocument.write(cf1.q2 + &quot;&lt;br /&gt;&quot;); //result: bbb 本地属性与继承属性对象通过隐式Prototype链能够实现属性和方法的继承，但prototype也是一个普通对象，就是说它是一个普通的实例化的对象，而不是纯粹抽象的数据结构描述。所以就有了这个本地属性与继承属性的问题。首先看一下设置对象属性时的处理过程。JS定义了一组attribute，用来描述对象的属性property，以表明属性property是否可以在JavaScript代码中设值、被for in枚举等。obj.propName=value的赋值语句处理步骤如下: 如果propName的attribute设置为不能设值，则返回 如果obj.propName不存在，则为obj创建一个属性，名称为propName 将obj.propName的值设为value可以看到，设值过程并不会考虑Prototype链，道理很明显，obj的内部[[Prototype]]是一个实例化的对象，它不仅仅向obj共享属性，还可能向其它对象共享属性，修改它可能影响其它对象。用上面CF, Cfp的示例来说明，实例对象cf1具有本地属性q1, q2以及继承属性CFP1，如果执行cf1.CFP1=””，那么cf1就具有本地属性CFP1了，测试结果如下:123456789101112//Passed in FF2.0, IE7, Opera9.25, Safari3.0.4var cf1=new CF(&quot;aaa&quot;, &quot;bbb&quot;);var cf2=new CF(111, 222);document.write(cf1.CFP1 + &quot;&lt;br /&gt;&quot;); //result: CFP1 in Cfpdocument.write(cf2.CFP1 + &quot;&lt;br /&gt;&quot;); //result: CFP1 in Cfp//it will result in a local property in cf1cf1.CFP1=&quot;new value for cf1&quot;;//changes on CF.prototype.CFP1 will affect cf2 but not cf1, because there&apos;s already a local property with//the name CFP1 in cf1, but no such one in cf2CF.prototype.CFP1=&quot;new value for Cfp&quot;;document.write(cf1.CFP1 + &quot;&lt;br /&gt;&quot;); //result: new value for cf1document.write(cf2.CFP1 + &quot;&lt;br /&gt;&quot;); //result: new value for Cfp 语义上的混乱?还是使用上面CF, Cfp示例的场景。根据Prototype的机制，我们可以说对象cf1, cf2等都继承了对象Cfp的属性和方法，所以应该说他们之间存在继承关系。属性的继承/共享是沿着隐式Prototype链作用的，所以继承关系也应当理解为沿着这个链。我们再看instanceOf操作，只有cf1 instanceOf CF才成立，我们说cf1是CF的实例对象，CF充当了类的角色，而不会说cf1是Cfp的实例对象，这样我们应当说cf1继承自CF? 但CF充当的只是一个第三方工厂的角色，它跟cf1之间并没有属性继承这个关系。把CF, Cfp看作一个整体来理解也同样牵强。 Prototype就是Prototype，没有必要强把JavaScript与面向对象概念结合起来， JavaScript只具备有限的面向对象能力，从另外的角度我们可以把它看成函数语言、动态语言，所以它是吸收了多种语言特性的精简版。 对象模型Where are we? 了解了JavaScript的数据类型，清楚了象Number这样的系统内置对象具有多重身份: a)它们本身是一个函数对象，只是由引擎内部实现而已，b)它们代表一种数据类型，我们可以用它们定义、操作相应类型的数据，c)在它们背后隐藏了引擎的内部实现机制，例如内部的数据结构、各种被包装成了JavaScript对象的构造器等。 了解了Prototype机制，知道对象是如何通过它们继承属性和方法，知道了在创建对象过程中JS引擎内部是如何设置Prototype关系的。 接下来对用户自定义函数对象本身的创建过程进行了解之后，我们就可以对JavaScript的对象模型来一个整体性的overview了。 函数对象创建过程JavaScript代码中定义函数，或者调用Function创建函数时，最终都会以类似这样的形式调用Function函数:var newFun=Function(funArgs, funBody); 。创建函数对象的主要步骤如下: 创建一个build-in object对象fn 将fn的内部[[Prototype]]设为Function.prototype 设置内部的[[Call]]属性，它是内部实现的一个方法，处理逻辑参考对象创建过程的步骤3 设置内部的[[Construct]]属性，它是内部实现的一个方法，处理逻辑参考对象创建过程的步骤1,2,3,4 设置fn.length为funArgs.length，如果函数没有参数，则将fn.length设置为0 使用new Object()同样的逻辑创建一个Object对象fnProto 将fnProto.constructor设为fn 将fn.prototype设为fnProto 返回fn 步骤1跟步骤6的区别为，步骤1只是创建内部用来实现Object对象的数据结构(build-in object structure)，并完成内部必要的初始化工作，但它的[[Prototype]]、[[Call]]、[[Construct]]等属性应当为null或者内部初始化值，即我们可以理解为不指向任何对象(对[[Prototype]]这样的属性而言)，或者不包含任何处理(对[[Call]]、[[Construct]]这样的方法而言)。步骤6则将按照前面描述的对象创建过程创建一个新的对象，它的[[Prototype]]等被设置了。从上面的处理步骤可以了解，任何时候我们定义一个函数，它的prototype是一个Object实例，这样默认情况下我们创建自定义函数的实例对象时，它们的Prototype链将指向Object.prototype。另外，Function一个特殊的地方，是它的[[Call]]和[[Construct]]处理逻辑一样。 JavaScript对象模型红色虚线表示隐式Prototype链。 这张对象模型图中包含了太多东西，不少地方需要仔细体会，可以写些测试代码进行验证。彻底理解了这张图，对JavaScript语言的了解也就差不多了。下面是一些补充说明: 图中有好几个地方提到build-in Function constructor，这是同一个对象，可以测试验证:1234567//Passed in FF2.0, IE7, Opera9.25, Safari3.0.4Function==Function.constructor //result: trueFunction==Function.prototype.constructor //result: trueFunction==Object.constructor //result: true//Function also equals to Number.constructor, String.constructor, Array.constructor, RegExp.constructor, etc.function fn()&#123;&#125;Function==fn.constructor //result: true 这说明了几个问题: Function指向系统内置的函数构造器(build-in Function constructor)；Function具有自举性；系统中所有函数都是由Function构造。 左下角的obj1, obj2…objn范指用类似这样的代码创建的对象: function fn1(){}; var obj1=new fn1(); 这些对象没有本地constructor方法，但它们将从Prototype链上得到一个继承的constructor方法，即fn.prototype.constructor，从函数对象的构造过程可以知道，它就是fn本身了。 右下角的obj1, obj2…objn范指用类似这样的代码创建的对象: var obj1=new Object();或var obj1={};或var obj1=new Number(123);或obj1=/\\w+/;等等。所以这些对象Prototype链的指向、从Prototype链继承而来的constructor的值(指它们的constructor是build-in Number constructor还是build-in Object constructor等)等依赖于具体的对象类型。另外注意的是，var obj=new Object(123);这样创建的对象，它的类型仍然是Number，即同样需要根据参数值的类型来确定。 同样它们也没有本地constructor，而是从Prototype链上获得继承的constructor方法，即build-in *** constructor，具体是哪一个由数据类型确定。 关于图中Prototype链的补充说明:Object.prototype是整个链的终结点，它的内部[[Prototype]]为null。所有函数的Prototype链都指向Function.prototype。Function的Prototype链指向Function.prototype，这是规范要求的，因为设计者将Function设计为具有自举性。Function的Prototype链这样设计之后，Function.constructor==Function, Function instanceOf Function都为true。另外Function已经是最顶层的构造器，但Function本身也是一个函数对象，它必然是由某个东西创建出来的，这样自举在语义上合情合理。Function.prototype的Prototype链指向Object.prototype，这也是规范强制要求的。首先Function.prototype是Function的一个实例对象(typeof Function.prototype可以知道它是一个Function，instanceOf无法通过测试，因为Prototype链在内部被额外设置了），所以按照Prototype的规则，Function.prototype的内部[[Prototype]]值应当为Function.prototype这个对象，即它的Prototype链指向自己本身。这样一方面在Prototype链上造成一个死循环，另一方面它本身成为了一个终结点，结果就是所有函数对象将不是派生自Object了。加上这个强制要求之后，Prototype链只有唯一的一个终结点。 执行模型执行上下文(Execution Context)简介JavaScript代码运行的地方都存在执行上下文，它是一个概念，一种机制，用来完成JavaScript运行时作用域、生存期等方面的处理。执行上下文包括Variable Object、Variable Instatiation、Scope/Scope Chain等概念，在不同的场景/执行环境下，处理上存在一些差异，下面先对这些场景进行说明。 函数对象分为用户自定义函数对象和系统内置函数对象，对于用户自定义函数对象将按照下面描述的机制进行处理，但内置函数对象与具体实现相关，ECMA规范对它们执行上下文的处理没有要求，即它们基本不适合本节描述的内容。 执行的JavaScript代码分三种类型，后面会对这三种类型处理上不同的地方进行说明: Global Code，即全局的、不在任何函数里面的代码，例如一个js文件、嵌入在HTML页面中的js代码等。 Eval Code，即使用eval()函数动态执行的JS代码。 Function Code，即用户自定义函数中的函数体JS代码。 基本原理在用户自定义函数中，可以传入参数、在函数中定义局部变量，函数体代码可以使用这些入参、局部变量。背后的机制是什么样呢？当JS执行流进入函数时，JavaScript引擎在内部创建一个对象，叫做Variable Object。对应函数的每一个参数，在Variable Object上添加一个属性，属性的名字、值与参数的名字、值相同。函数中每声明一个变量，也会在Variable Object上添加一个属性，名字就是变量名，因此为变量赋值就是给Variable Object对应的属性赋值。在函数中访问参数或者局部变量时，就是在variable Object上搜索相应的属性，返回其值。一般情况下Variable Object是一个内部对象，JS代码中无法直接访问。规范中对其实现方式也不做要求，因此它可能只是引擎内部的一种数据结构。 大致处理方式就这样，但作用域的概念不只这么简单，例如函数体中可以使用全局变量、函数嵌套定义时情况更复杂点。这些情况下怎样处理？JavaScript引擎将不同执行位置上的Variable Object按照规则构建一个链表，在访问一个变量时，先在链表的第一个Variable Object上查找，如果没有找到则继续在第二个Variable Object上查找，直到搜索结束。这就是Scope/Scope Chain的大致概念。 下面是各个方面详细的处理。 Global ObjectJavaScript的运行环境都必须存在一个唯一的全局对象-Global Object，例如HTML中的window对象。Global Object是一个宿主对象，除了作为JavaScript运行时的全局容器应具备的职责外，ECMA规范对它没有额外要求。它包Math、String、Date、parseInt等JavaScript中内置的全局对象、函数(都作为Global Object的属性)，还可以包含其它宿主环境需要的一些属性。 Variable Object上面简述了Variable Object的基本概念。创建Variable Object，将参数、局部变量设置为Variable Object属性的处理过程叫做Variable Instatiation-变量实例化，后面结合Scope Chain再进行详细说明。 Global CodeVariable Object就是Global Object，这是Variable Object唯一特殊的地方(指它是内部的无法访问的对象而言)。var globalVariable = “WWW”;document.write(window.globalVariable); //result: WWW上面代码在Global Code方式下运行，根据对Variable Object的处理，定义变量globalVariable时就会在Global Object(即window)对象上添加这个属性，所以输出是WWW这个值。12Function CodeVariable Object也叫做Activation Object(因为有一些差异存在，所以规范中重新取一个名字以示区别，Global Code/Eval Code中叫Variable Object，Function Code中就叫做Activation Object)。 每次进入函数执行都会创建一个新的Activation Object对象，然后创建一个arguments对象并设置为Activation Object的属性，再进行Variable Instantiation处理。在退出函数时，Activation Object会被丢弃(并不是内存释放，只是可以被垃圾回收了)。 附arguments对象的属性:length: 为实际传入参数的个数。注意，参考函数对象创建过程，函数对象上的length为函数定义时要求的参数个数；callee: 为执行的函数对象本身。目的是使函数对象能够引用自己，例如需要递归调用的地方。function fnName(…) { … }这样定义函数，它的递归调用可以在函数体内使用fnName完成。var fn=function(…) { … }这样定义匿名函数，在函数体内无法使用名字引用自己，通过arguments.callee就可以引用自己而实现递归调用。参数列表: 调用者实际传入的参数列表。这个参数列表提供一个使用索引访问实际参数的方法。Variable Instantiation处理时会在Activation Object对象上添加属性，前提是函数声明时有指定参数列表。如果函数声明中不给出参数列表，或者实际调用参数个数与声明时的不一样，可以通过arguments访问各个参数。 arguments中的参数列表与Activation Object上的参数属性引用的是相同的参数对象(如果修改，在两处都会反映出来)。规范并不要求arguments是一个数组对象，下面是一个测试:123456789//Passed in FF2.0, IE7, Opera9.25, Safari3.0.4var argumentsLike = &#123; 0: &quot;aaa&quot;, 1: 222, 2: &quot;WWW&quot;, length: 3, callee: function() &#123; &#125; &#125;;document.write(argumentsLike[2] + &quot;&lt;br /&gt;&quot;); //result: WWWdocument.write(argumentsLike[1] + &quot;&lt;br /&gt;&quot;); //result: 222//convert the argumentsLike to an Array object, just as we can do this for the arguments propertyvar array = [].slice.apply(argumentsLike);document.write(array instanceof Array); //result: truedocument.write(&quot;&lt;br /&gt;&quot;);document.write(array.reverse().join(&quot;|&quot;)); //result: WWW|222|aaa Eval CodeVariable Object就是调用eval时当前执行上下文中的Variable Object。在Global Code中调用eval函数，它的Variable Object就是Global Object；在函数中调用eval，它的Variable Object就是函数的Activation Object。1234567891011//Passed in FF2.0, IE7, Opera9.25, Safari3.0.4function fn(arg)&#123; var innerVar = &quot;variable in function&quot;; eval(&apos; \\ var evalVar = &quot;variable in eval&quot;; \\ document.write(arg + &quot;&lt;br /&gt;&quot;); \\ document.write(innerVar + &quot;&lt;br /&gt;&quot;); \\ &apos;); document.write(evalVar);&#125;fn(&quot;arguments for function&quot;); 输出结果是:arguments for functionvariable in functionvariable in eval说明: eval调用中可以访问函数fn的参数、局部变量；在eval中定义的局部变量在函数fn中也可以访问，因为它们的Varible Object是同一个对象。 Scope/Scope Chain首先Scope Chain是一个类似链表/堆栈的结构，里面每个元素基本都是Variable Object/Activation Object。其次存在执行上下文的地方都有当前Scope Chain，可以理解为Scope Chain就是执行上下文的具体表现形式。 Global CodeScope Chain只包含一个对象，即Global Object。在开始JavaScript代码的执行之前，引擎会创建好这个Scope Chain结构。 Function Code函数对象在内部都有一个[[Scope]]属性，用来记录该函数所处位置的Scope Chain。创建函数对象时，引擎会将当前执行环境的Scope Chain传给Function的[[Construct]]方法。[[Construct]]会创建一个新的Scope Chain，内容与传入的Scope Chain完全一样，并赋给被创建函数的内部[[Scope]]属性。在前面函数对象创建过程一节中，这个处理位于步骤4和5之间。进入函数调用时，也会创建一个新的Scope Chain，包括同一个函数的递归调用，退出函数时这个Scope Chain被丢弃。新建的Scope Chain第一个对象是Activation Object，接下来的内容与内部[[Scope]]上存储的Scope Chain内容完全一样。 Eval Code进入Eval Code执行时会创建一个新的Scope Chain，内容与当前执行上下文的Scope Chain完全一样。 实例说明Scope Chain的原理就上面这些，必须结合JS代码的执行、Variable Instantiation的细节处理，才能理解上面这些如何产生作用，下面用一个简单的场景来综合说明。假设下面是一段JavaScript的Global Code:1234567var outerVar1=&quot;variable in global code&quot;;function fn1(arg1, arg2)&#123; var innerVar1=&quot;variable in function code&quot;; function fn2() &#123; return outerVar1+&quot; - &quot;+innerVar1+&quot; - &quot;+&quot; - &quot;+(arg1 + arg2); &#125; return fn2();&#125;var outerVar2=fn1(10, 20); 执行处理过程大致如下: 初始化Global Object即window对象，Variable Object为window对象本身。创建Scope Chain对象，假设为scope_1，其中只包含window对象。 扫描JS源代码(读入源代码、可能有词法语法分析过程)，从结果中可以得到定义的变量名、函数对象。按照扫描顺序:2.1 发现变量outerVar1，在window对象上添加outerVar1属性，值为undefined；2.2 发现函数fn1的定义，使用这个定义创建函数对象，传给创建过程的Scope Chain为scope_1。将结果添加到window的属性中，名字为fn1，值为返回的函数对象。注意fn1的内部[[Scope]]就是scope_1。另外注意，创建过程并不会对函数体中的JS代码做特殊处理，可以理解为只是将函数体JS代码的扫描结果保存在函数对象的内部属性上，在函数执行时再做进一步处理。这对理解Function Code，尤其是嵌套函数定义中的Variable Instantiation很关键；2.3 发现变量outerVar2，在window对象上添加outerVar2属性，值为undefined； 执行outerVar1赋值语句，赋值为”variable in global code”。 执行函数fn1，得到返回值:4.1 创建Activation Object，假设为activation_1；创建一个新的Scope Chain，假设为scope_2，scope_2中第一个对象为activation_1，第二个对象为window对象(取自fn1的[[Scope]]，即scope_1中的内容)；4.2 处理参数列表。在activation_1上设置属性arg1、arg2，值分别为10、20。创建arguments对象并进行设置，将arguments设置为activation_1的属性；4.3 对fn1的函数体执行类似步骤2的处理过程:4.3.1 发现变量innerVar1，在activation_1对象上添加innerVar1属性，值为undefine； 4.3.2 发现函数fn2的定义，使用这个定义创建函数对象，传给创建过程的Scope Chain为scope_2(函数fn1的Scope Chain为当前执行上下文的内容)。将结果添加到activation_1的属性中，名字为fn2，值为返回的函数对象。注意fn2的内部[[Scope]]就是scope_2； 4.4 执行innerVar1赋值语句，赋值为”variable in function code”。4.5 执行fn2:4.5.1 创建Activation Object，假设为activation_2；创建一个新的Scope Chain，假设为scope_3，scope_3中第一个对象为activation_2，接下来的对象依次为activation_1、window对象(取自fn2的[[Scope]]，即scope_2)； 4.5.2 处理参数列表。因为fn2没有参数，所以只用创建arguments对象并设置为activation_2的属性。 4.5.3 对fn2的函数体执行类似步骤2的处理过程，没有发现变量定义和函数声明。 4.5.4 执行函数体。对任何一个变量引用，从scope_3上进行搜索，这个示例中，outerVar1将在window上找到；innerVar1、arg1、arg2将在activation_1上找到。 4.5.5 丢弃scope_3、activation_2(指它们可以被垃圾回收了)。 4.5.6 返回fn2的返回值。 4.6 丢弃activation_1、scope_2。4.7 返回结果。 将结果赋值给outerVar2。 其它情况下Scope Chain、Variable Instantiation处理类似上面的过程进行分析就行了。 根据上面的实例说明，就可以解释下面这个测试代码的结果:12345678910111213141516//Passed in FF2.0, IE7, Opera9.25, Safari3.0.4function fn(obj)&#123; return &#123; //test whether exists a local variable &quot;outerVar&quot; on obj exists: Object.prototype.hasOwnProperty.call(obj, &quot;outerVar&quot;), //test the value of the variable &quot;outerVar&quot; value: obj.outerVar &#125;;&#125;var result1 = fn(window);var outerVar = &quot;WWW&quot;; var result2 = fn(window);document.write(result1.exists + &quot; &quot; + result1.value); //result: true undefineddocument.write(&quot;&lt;br /&gt;&quot;);document.write(result2.exists + &quot; &quot; + result2.value); //result: true WWW result1调用的地方，outerVar声明和赋值的语句还没有被执行，但是测试结果window对象已经拥有一个本地属性outerVar，其值为undefined。result2的地方outerVar已经赋值，所以window.outerVar的值已经有了。实际使用中不要出现这种先使用，后定义的情况，否则某些情况下会有问题，因为会涉及到一些规范中没有提及，不同厂商实现方式上不一致的地方。 一些特殊处理 with(obj) { … }这个语法的实现方式，是在当前的Scope Chain最前面位置插入obj这个对象，这样就会先在obj上搜索是否有相应名字的属性存在。其它类似的还有catch语句。 前面对arguments对象的详细说明中，提到了对函数递归调用的支持问题，了解到了匿名函数使用arguments.callee来实现引用自己，而命名函数可以在函数体内引用自己，根据上面Scope Chain的工作原理我们还无法解释这个现象，因为这里有个特殊处理。任何时候创建一个命名函数对象时，JavaScript引擎会在当前执行上下文Scope Chain的最前面插入一个对象，这个对象使用new Object()方式创建，并将这个Scope Chain传给Function的构造函数[[Construct]]，最终创建出来的函数对象内部[[Scope]]上将包含这个object对象。创建过程返回之后，JavaScript引擎在object上添加一个属性，名字为函数名，值为返回的函数对象，然后从当前执行上下文的Scope Chain中移除它。这样函数对象的Scope Chain中第一个对象就是对自己的引用，而移除操作则确保了对函数对象创建处Scope Chain的恢复。 this关键字处理执行上下文包含的另一个概念是this关键字。Global Code中this关键字为Global Object；函数调用时this关键字为调用者，例如obj1.fn1()，在fn1中this对象为obj1；Eval Code中this关键字为当前执行上下文的Variable Object。 在函数调用时，JavaScript提供一个让用户自己指定this关键字值的机会，即每个函数都有的call、apply方法。例如:fn1.call(obj1, arg1, arg2, …)或者fn1.apply(obj1, argArray)，都是将obj1作为this关键字，调用执行fn1函数，后面的参数都作为函数fn1的参数。如果obj1为null或undefined，则Global Object将作为this关键字的值；如果obj1不是Object类型，则转化为Object类型。它们之间的唯一区别在于，apply允许以数组的方式提供各个参数，而call方法必须一个一个参数的给。前面的测试示例代码中有多处运用到了这个方法。例如window对象并没有hasOwnProperty方法，使用Object.prototype.hasOwnProperty.call(window, “propertyName”)也可以测试它是否拥有某个本地属性。 JavaScript中的闭包Closures示例：12345678//Passed in FF2.0, IE7, Opera9.25, Safari3.0.4function outer()&#123; var a=&quot;aaa&quot;; var b=&quot;bbb&quot;; return function()&#123; return a + &quot; &quot; + b; &#125;;&#125;var inner=outer();document.write(inner()); outer返回的是一个内嵌函数，内嵌函数使用了outer的局部变量a和b。照理outer的局部变量在返回时就超出了作用域因此inner()调用无法使用才对。这就是闭包Closure，即函数调用返回了一个内嵌函数，而内嵌函数引用了外部函数的局部变量、参数等这些应当被关闭(Close)了的资源。 根据前面Scope Chain的理解可以解释，返回的内嵌函数已经持有了构造它时的Scope Chain，虽然outer返回导致这些对象超出了作用域、生存期范围，但JavaScript使用自动垃圾回收来释放对象内存: 按照规则定期检查，对象没有任何引用才被释放。因此上面的代码能够正确运行。 关于使用Closure时的内存泄漏、效率等问题，参考http://www.jibbering.com/faq/faq_notes/closures.html","tags":[{"name":"js执行模型","slug":"js执行模型","permalink":"http://tawen.github.io/tags/js执行模型/"}]},{"title":"JFinal 3.0 发布，重新定义模板引擎","date":"2017-01-21T02:50:05.000Z","path":"2017/01/21/blog20170121/","text":"本次回归码坛为小伙伴们带来的是重新定义过的 Template Engine 将极速开发继续贯彻到 View 层。 Java 模板引擎界已被 Freemarker、Velocity 统治多年，但其在这些年的发展可谓乏善可陈，究其根本原因是因为这个领域严重依赖于第三方工具去做词法、语法分析以及 AST 的构建，并未真正在语言层面进行过深入的追问。 例如 Freemarker、Velocity 是基于 javacc 做的二次开发，其他 java 模板引擎多数也是基于 ANTLR、jflex、javacc 生成后的代码做的二次开发全部自己动手写代码而不是二次开发的 java 模板引擎极为少见，国内较为知名的仅见 HTTL。 由于使用 ANTLR 等工具去做模板引擎可以让 80% 以上的工作由工具代为完成，所以对模板引擎作者极具诱惑力，但诱惑的背后其实是巨大的陷阱。 首先，这类工具无一例外都要求使用一套特定规则先表示出词法和语法，然后再把它们生成为 Parser 源代码而词法、语法描述用的规则和生成的 Parser 并没有很强的语义连接关系，如果生成的 Parser 有 bug，非常难以回溯排错。 其次，生成的 Parser 源码，毫无可读性而言，进而在 Parser 层面根本无法调试，这种构建模板引擎的方式，相当于将自己的代码建立在一个飘摇不安的基础之上。 再次，通过这种方式做出来的模板引擎如果要在更底层改进，则需要先去改语法、词法描述规则文件，然后再生成一次 Parser 源码，然后才可以开始真正写代码，这个重复、麻烦且容易出错的过程也严重阻碍了模板引擎的改进。 最后，这种构建方式通常在运行时还需要一个类似于 runtime.jar 的依赖，这个依赖多多少少也会增加不确定的风险。 模板引擎在本质上是一门程序语言，要开发一门可用于生产环境的模板语言起码要对开发程序语言的相关技术、算法很熟悉，例如常用词法分析算法、语法分析算法、AST、解释器、编译原理等等领域知识。 但非常不幸的是，即便对已有算法很熟悉，仍然只能做出极为平庸的模板引擎，因为模板引擎所处理的对象与程序语言有着十分不同的特征：模板的内容通常是极其自由的文本中嵌入着少量程序语言元素，而类似于 NFA 这样的算法都是面向类似于 java、c、python 这类高度结构化的源代码内容。 JFinal Template Engine 直面这个问题，采用独创的算法彻底代替传统算法，极大降低了复杂度，减少了代码量，同时可读性得到极大提升。JFinal Template Engine 经过公司内部开发者近三个月的试用时间，直到每位开发者都沉醉其中后才放出 jfinal 3.0 版本。 1：独创 DKFF(Dynamic Key Feature Forward) 词法分析算法 传统的 NFA 词法分析算法基于正则表达式与状态图，即便是做一个简单的模板引擎也需要成百上千个状态，NFA 算法对于人类来说几乎不可读，需要先将二维数组表示的状态图存储结构转换成画在纸上的人类可读的状态图，并且还要花费相当长的时间去解读其内涵。而 JFinal Template Engine 只需 7 个状态 403 行代码搞定词法分析，可读高，有利于系统进化。 2：独创 DLRD(Double layer Recursive Descent) 语法分析算法 针对模板文件大量纯文本掺杂少量代码特征，独创 DLRD 语法分析算法，将指令与表达式的语法分析划分在不同的层次之中相比传统递归下降语法分析算法，复杂度降到极致，代码量少到极致仅 215 行代码搞定 statement 语法分析。 DLRD 算法还极为轻松地解决了传统算法面对的左递归、二义性、回溯以及运算符优先级等麻烦问题，无需文法变换即可消除左递归，无需回溯即可解决二义性问题传统递下降法算法需要采用变换文法、回溯、提取公因子方式解决上述问题传统解决方案不仅麻烦而且让文法变换后的程序可读性降低，不利于进化。 3：独创语言级指令扩展 对于传统模板引擎来说指令系统是固定的，相当于程序语言的关键字，无法为语言动态添加新的关键字，JFinal template engine 得益于独创的 DKFF、DLRD 算法，极为轻松的在程序语言层面实现了指令扩展功能，从而整个模板引擎只需提供了极少的常用指令，其她所有指令均由扩展而成，例如 com.jfinal.template.ext.directive 以及com.jfinal.plugin.activerecord.sql 包之下的所有指令全是扩展而来。 基于以上主要创新， JFinal 在极简的路上继续挺进，一个 MVC + ORM 各层全面实现极速开发的框架由此诞生： 1：极简设计 JFinal Template Engine 消灭了大量传统模板引擎中的无聊概念，例如 macro、layout、pageContent、nested、tag 插值等等概念，但凡一门可用于生产环境的语言，只需利用表达式、语句、函数、分支、循环等基本要素，就可以像呼吸空气一样自由地实现上述这些功能，引入新的概念纯属制造麻烦。 以 macro 为例，该概念产生于很古老的程序语言，已证明是历史性糟粕在后起的程序语言中被抛弃，可却在 freemarker、velocity 等模板引擎中死而复生，以致于后来者也争相跟风模仿引入了 macro 概念。 2：独创空合安全取值调用操作符 JFinal Template Engine 引入了 swift 与 C#语言中的空合操作符，并在其基础之上进行了极为自然的扩展，该表达式符号为两个紧靠的问号： ??12345value ?? rightExpr // 当value为null时，表达式取值rightExprobject.value ?? // 当 object 为 null 时变为安全取值，不报空指针异常，表达式的值为nullobject.method() ?? // 当 object 为 null 时变为安全调用，不报空指针异常，表达式的值为nullobject.value ?? rightExpr // 空合并与安全取值的组合用法，当object为null时表达式取值rightExprobject.method() ?? rightExpr // 空合并安全调用的组合用法，当object为null时表达式取值为rightExpr swift 与 C# 语言仅支持第一种用法并称之为空合操作符，而 JFinal Template Engine 在空合的基础上再支持安全取值、安全调用两个扩展，在模板引擎的应用场景之下的开发体验极为顺滑。 3：消灭插值指令 传统模板引擎通常会引入所谓的插值指令，而其它指令则使用另一套规则，而 jfinal template engine 将插值指令仍然当成是指令，并不引进新的概念，不仅在实现上更加简洁只需 21 行代码，而且降低了学习成本 123#(value)#(object.value)#(map.key) 4：消灭 macro 指令 如果真心将 template engine 当成一门语言去设计，原本用 macro 实现的功能只需要使用所有语言中都有的 function/method 概念，即可更为简单实现，如下是利用 fcuntion 实现 layout 功能的示例先在 layout.html 中定义 layout() 函数，并在 body调用 main() 函数1234567#define layout()&lt;html&gt; &lt;body&gt; #@main() &lt;body&gt;&lt;/html&gt;#end 然后在最终的页面，直接调用 layout() 并定义 main() 函数1234#@layout()#define main()...#end 注意：以上的 layout.html、layout、main 这些名称可以随便取名，不是具体的概念，仅为一个名字 JFinal Template Engine 代码仅有 5556 行，仅为 freemarker 的十分之一，完全手写算法，无第三方依赖，对于有任何一门程序语言的开发者学习成本几乎为 0。为控制篇幅，在此不在赘述。jfinal 3.0 版不仅仅是重新定义了 Template Engine，还对其她方面做了非常有价值的改进 1：Routes 级拦截器 jfinal 3.0 可以在 Routes 中添加拦截器，Routes 极拦截器，将拦截所有在此 Routes 中映射的 Controller：1234567public class AdminRoutes extends Routes &#123; public void config() &#123; addInterceptor(new AdminInterceptor()); add(&quot;/admin&quot;, IndexAdminController.classs); add(&quot;/admin/project&quot;, ProjectAdminController.classs); &#125;&#125; 上例中的 AdminInterceptor 将拦截 IndexAdminController、ProjectAdminController 中的所有 action，这非常有利于多个控制器配置了相同拦截器的应用场景，减少了代码冗余。 2：active record 模块 sql 管理模块 JFinal 3.0利用自带的Template Engine极为简洁的实现了Sql管理功能，可以将sql保存在外部配置文件之中，并且以极少概念极少 API 实现 mybatis 的核心功能 123#sql(&quot;findPrettyGirl&quot;) select * from girl where age &gt; ? and age &lt; ? and weight &lt; 50#end java 代码中的使用方式：1find(getSql(&quot;findPrettyGirl&quot;), 16, 20); 同时还提供了 namespace 支持与 para 动态绑定功能，详见 jfinal 手册 3：Cron4jPlugin 支持任务调度 Cron4jPlugin 对 cron4j 进行了极简封装，简单用法如下：123Cron4jPlugin cp = new Cron4jPlugin();cp.addTask(&quot;* * * * *&quot;, new MyTask());me.add(cp); 外部配置文件用法详见 jfinal 手册 4：renderQrCode 支持二维码生成 添加 Controller.renderQrCode(…) 极速生成二维码 jfinal 3.0 一如既往地坚持极简设计风格，在极速开发的路上一路挺进，力争为开发者带来更高的开发效率，更好的开发体验，更低的学习成本，进一步节约时间去陪恋人、家人和朋友！篇幅所限，更多功能增强与改进详见 changelog: http://www.jfinal.com/share/190 ONE MORE THING：JFinal 俱乐部频道今起正式开放，将为小伙伴们提供更高附加值的产品与服务进一步提升开发效率，节省开发时间。老司机要发车了，GO GO GO：http://www.jfinal.com/club","tags":[{"name":"JFinal 3.0","slug":"JFinal-3-0","permalink":"http://tawen.github.io/tags/JFinal-3-0/"}]},{"title":"jQuery源码分析--$.Deferred()","date":"2017-01-20T12:50:05.000Z","path":"2017/01/20/blog20170120/","text":"直接上例子12345678910111213141516171819202122232425//源码结构jQuery.extend(&#123; Deferred : function()&#123;&#125;, when : function()&#123;&#125; &#125;);//$.Deferred() 相当于 $.Callbacks()$.Deferred(); -&gt; $.Callbacks();$.when();//简单例子var dfd = $.Deferred();setTimeout(function()&#123; alert(111); dfd.resolve(); &#125;,1000);dfd.done(function()&#123; alert(222);&#125;); 下面是Deferred源码tuples：123[ &quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;resolved&quot; ],[ &quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;rejected&quot; ],[ &quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks(&quot;memory&quot;) ] resolve/reject/notify 相当于Callbacks中的 fire；done/fail/progress 相当于Callbacks中的 add。 promise与deferred的关系promise下面的方法：state、always、then、promise、pipe、done、fail、progress deferred下面的方法：包括promise下面所有方法以及resolve、reject、notify方法 返回deferred.promise()时，相当于是promise对象，promise对象下面没有resolve、reject、notify方法，所以外部没有办法修改执行是的状态。 when工具方法when返回一个不能再外部修改状态的延迟对象promise；多延迟对象同时完成后触发done、fail、then、progress； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051when: function( subordinate /* , ..., subordinateN */ ) &#123; var i = 0, resolveValues = core_slice.call( arguments ), length = resolveValues.length, // the count of uncompleted subordinates remaining = length !== 1 || ( subordinate &amp;&amp; jQuery.isFunction( subordinate.promise ) ) ? length : 0, // the master Deferred. If resolveValues consist of only a single Deferred, just use that. deferred = remaining === 1 ? subordinate : jQuery.Deferred(), // Update function for both resolve and progress values updateFunc = function( i, contexts, values ) &#123; return function( value ) &#123; contexts[ i ] = this; values[ i ] = arguments.length &gt; 1 ? core_slice.call( arguments ) : value; if( values === progressValues ) &#123; deferred.notifyWith( contexts, values ); &#125; else if ( !( --remaining ) ) &#123; deferred.resolveWith( contexts, values ); &#125; &#125;; &#125;, progressValues, progressContexts, resolveContexts; // add listeners to Deferred subordinates; treat others as resolved if ( length &gt; 1 ) &#123; progressValues = new Array( length ); progressContexts = new Array( length ); resolveContexts = new Array( length ); for ( ; i &lt; length; i++ ) &#123; if ( resolveValues[ i ] &amp;&amp; jQuery.isFunction( resolveValues[ i ].promise ) ) &#123; resolveValues[ i ].promise() .done( updateFunc( i, resolveContexts, resolveValues ) ) .fail( deferred.reject ) .progress( updateFunc( i, progressContexts, progressValues ) ); &#125; else &#123; --remaining; &#125; &#125; &#125; // if we&apos;re not waiting on anything, resolve the master if ( !remaining ) &#123; deferred.resolveWith( resolveContexts, resolveValues ); &#125; return deferred.promise(); &#125;&#125;);","tags":[{"name":"$.Deferred()","slug":"Deferred","permalink":"http://tawen.github.io/tags/Deferred/"}]},{"title":"脚本引用中的DEFER和ASYNC的用法和区别","date":"2017-01-19T06:50:05.000Z","path":"2017/01/19/blog20170119/","text":"因为浏览器在遇到script标签的时候，文档的解析会停止，不再构建document，有时打开一个网页上会出现空白一段时间，浏览器显示是刷新请求状态(也就是一直转圈)，这就会给用户很不好的体验，defer和async的合理使用就可以避免这个情况，而且通常script的位置建议写在页面底部(移动端应用的比较多，这两个都是html5中的新属性)。 所以相对于默认的script引用，这里配合defer和async就有两种新的用法，它们之间什么区别那？ 1.默认引用 script: &lt;script type=&quot;text/javascript&quot; src=&quot;x.min.js&quot;&gt;&lt;/script&gt; 当浏览器遇到 script 标签时，文档的解析将停止，并立即下载并执行脚本，脚本执行完毕后将继续解析文档。 2.async模式 &lt;script type=&quot;text/javascript&quot; src=&quot;x.min.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt; 当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，脚本下载完成后开始执行脚本，脚本执行的过程中文档将停止解析，直到脚本执行完毕。 3.defer模式 &lt;script type=&quot;text/javascript&quot; src=&quot;x.min.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt; 当浏览器遇到 script 标签时，文档的解析不会停止，其他线程将下载脚本，待到文档解析完成，脚本才会执行。 所以async和defer的最主要的区别就是async是异步下载并立即执行，然后文档继续解析，defer是异步加载后解析文档，然后再执行脚本，这样说起来是不是理解了一点了； 它们的核心功能就是异步，那么两种属性怎么去区分什么情况下用哪个那，主要的参考是如果脚本不依赖于任何脚本，并不被任何脚本依赖，那么则使用 defer，如果脚本是模块化的，不依赖于任何脚本，那么则使用 async；主要功能点说完了，小伙伴们有没有分清楚他们的区别了那。","tags":[{"name":"defer","slug":"defer","permalink":"http://tawen.github.io/tags/defer/"},{"name":"async","slug":"async","permalink":"http://tawen.github.io/tags/async/"}]},{"title":"支付宝又开始集五福啦","date":"2017-01-18T07:00:05.000Z","path":"2017/01/18/blog20170118/","text":"开篇之前告诉大家一个可能会比较嫌弃的消息，为什么嫌弃?因为跟去年支付宝的敬业福有关。近日，支付宝方面公布了2017年春晚期间支付宝红包玩法：今年的活动将再次延用去年集五福的理念。 2017支付宝集五福活动说明你没看错，又是集五福。看到这儿可能不少网友开始清清嗓眼儿那口老痰准备开喷了，毕竟不少人因为敬业福或多或少有些许心理阴影。但是先莫慌，从笔者了解到的信息来看，今年支付宝集五福会对比去年要容易得多，并且集齐的几率应该会挺大的。 今年有一个万能福卡支付宝方面表示：今年不会对任何一张福卡刻意营造稀缺悬念。也就是说，像去年敬业福极度稀缺的情况不会再出现了。并且今年还推出了“万能福卡”，万能福卡可以替代任何一张副卡。然后比较有趣味性的还有一张“顺手牵羊卡”能换走好友的任一福卡(坏笑) 扫“福”字集福另外，今年集福的门槛上也降低了不少。想对去年的各种靠加好友获取福卡，今年可以从两个几乎没有门槛的方向上来集齐五福。 2017支付宝集五福攻略如下(根据官方资料整理)： 1、通过活动入口扫描“福”字可获得福卡，包括商品、对联甚至是手写的福字，都可以。 2、支付宝蚂蚁森林给好友浇水等互动过程中也会获得福卡。 支付宝蚂蚁森林 截止除夕夜活动结束前最终集齐五福的用户可获得随机(注意是随机，不是去年的平分)红包，最高 666 元。 支付宝2017年集五福的新姿势你get到了吗?","tags":[{"name":"支付宝集五福","slug":"支付宝集五福","permalink":"http://tawen.github.io/tags/支付宝集五福/"}]},{"title":"js中this使用","date":"2017-01-17T11:50:05.000Z","path":"2017/01/17/blog20170117/","text":"函数在创建之后，会构建自己的执行环境以及作用域，这是一开始就确定了。但是实际的上下文(context)环境，也可以理解为就是this，它是动态确定的，即在函数运行时才确定this所指向的对象，而非声明时所指向的对象。 对象方法中调用this如果函数被当中对象的一个方法进行调用，则this值指向该对象。12345678var person = &#123; name: &apos;Alice&apos;, sayName: function() &#123; alert(&apos;welcome &apos; + this.name); &#125;&#125;person.sayName(); // this == person, alert: &apos;welcome Alice&apos; 在这里，函数的this指向该对象(即 person)；但是有一点需要注意，就是当对象的方法被赋予给一个变量时，其则变为了函数触发，此时的this为 window 或者 undefined(严格模式下)，如下： 12345var name = &apos;Bob&apos;;var person; // 即上面的定义，此不拓展详细，直接使用var say = person.sayName; // this == window || undefinedsay(); // &apos;welcome Bob&apos; || throw an error: Cannot read property &apos;name&apos; of undefined(...) 函数内部使用在函数内部当中使用了 this，即函数被当做方法使用，不同于 1 当中作为对象的方法使用，此时调用，是在全局作用域下进行调用，即在window下进行调用，由定义可以知道，在全局作用域下声明一个函数，其自动加为window的一个属性。this此时名正言顺的会指向window，严格模式下为 undefined123function sayThis() &#123; alert(this == window); // true&#125; 结合第一点，函数作为对象的一个方法使用，这里存在一个小坑，即闭包，啥是闭包，这个在这里就不扯开了，最简单的理解就是 Function that returns function，如果不理解什么是闭包的话，可以去翻翻 《JavaScript 高级程序设计》第七章关于闭包的相关内容。第一点当中存在一个小坑，就是将对象的方法赋予给一个变量的时候，其变为函数触发，此时的 this 实际上是指向 window(非严格模式)。 那么，当函数中返回一个函数，此时在对象当中调用该方法，其就相当于是函数触发，此时的 this，在不做任何上下文绑定的前提之下，其指向 window(非严格模式)。 1234567891011121314var name = &apos;Bob&apos;, person = &#123; name: &apos;Alice&apos;, sayName: function() &#123; console.log(this === person); // true return function() &#123; console.log(this === person); // false console.log(this === window); // true console.log(this.name); // Bob &#125;; &#125; &#125;;person.sayName()(); 当然，要解决这个问题的方法，很简单，就是给他绑定一个上下文。1234567891011121314var name = &apos;Bob&apos;, person = &#123; name: &apos;Alice&apos;, sayName: function() &#123; console.log(this === person); // true return function() &#123; console.log(this === person); // true console.log(this === window); // false console.log(this.name); // Alice &#125;.bind(this); &#125; &#125;;person.sayName()(); new 当中进行使用我们知道在使用 new 方法创建对象的时候，会经过如下这些个过程： 创建对象，将 this 值赋予新的对象 调用构造函数，为 this 添加属性和方法 返回 this 给当前的对象 1234567function Person(name, age) &#123; this.name = name; this.age = age;&#125;var person1 = new Person(&apos;Alice&apos;, 29);console.log(person1.name); // Alice 这里要记得使用 new 运算符，否则，其只能算是普通的调用，而不是创建一个新的实例对象。而当做普通函数调用的话，实际上即 第 2 种情况下，对函数普通调用，此时的 this 指向 window 12345678910function Person(name, age) &#123; this.name = name; this.age = age; return this;&#125;var person1 = Person(&apos;Alice&apos;, 29);console.log(person1.name); // Aliceconsole.log(window.name); // Aliceconsole.log(person1 === window); // true 这是正常情况下，this 会正确返回并且指向该对象，但是在构造函数当中，如果返回了一个对象，那么 this 会指向返回的那个对象。1234567891011function Person(name, age) &#123; this.name = name; this.age = age; return &#123; name: &apos;Bob&apos; &#125;;&#125;var person1 = new Person(&apos;Alice&apos;);console.log(person1.name); // Bobconsole.log(person1.age); // undefined 题外话，类似的，联想到 var a = new Person()，则 a instanceof Person一定返回 true吗？留给你们想一想咯。 4使用 call、apply 或 bind 改变 this在引用类型 Function当中，函数存在两个方法属性，call 和 apply，在 ECMAScript5当中，加入了 bind 方法。题外话，他们三者区别，应该都知道了吧，不知道的加紧补习呀。 1234567891011var name = &apos;Bob&apos;;var person = &#123; name: &apos;Alice&apos;, age: 29&#125;function sayName() &#123; console.log(this.name);&#125;sayName.call(person); // Alice 这里是使用了 call 方法来改变了 this的执行环境，至于使用 apply，效果一样，只是二者差别在于传入参数的不同。12func.call(context, arg1, arg2, ...)func.apply(context, [arg1, arg2, ...]) 使用 bind 方法进行上下文的改变，bind 方法与 call 和 apply有着本质的不同，其不同点是，bind()函数返回的是一个新的函数，即方法，而后两者则都是立即执行函数，使用的时候即调用了该函数，返回方法操作的结果。 并且，使用 bind()方法创建的 上下文，其为永久的上下文环境，不可修改，即使是使用 call 或者 apply方法，也无法修改 this 所指向的值。 12345678910111213var name = &apos;Bob&apos;;var person = &#123; name: &apos;Alice&apos;, age: 29&#125;function sayName() &#123; console.log(this.name);&#125;var say = sayName.bind(person);say(); // AlicesayName(); // Bob 箭头函数箭头函数并不创建其自身的上下文，其上下文 this，取决于其在定义时的外部函数。 并且，箭头函数拥有静态的上下文，即一次绑定之后，便不可再修改，即使是用了 第 4 种用途当中的改变上下文的方法，也不为之动容。 12345678910111213var num = [1, 2, 3];(function() &#123; var showNumber = () =&gt; &#123; console.log(this === num); // true console.log(this); // [1, 2, 3] &#125; console.log(this === num); // true showNumber(); // true &amp;&amp; [1, 2, 3] showNumber.call([1, 2]); // true &amp;&amp; [1, 2, 3] showNumber.apply([1, 2]); // true &amp;&amp; [1, 2, 3] showNumber.bind([1, 2])(); // true &amp;&amp; [1, 2, 3]&#125;).call(num); 由于箭头函数的外部决定上下文以及静态上下文等的特性，不太建议使用箭头函数在全局环境下来定义方法，因为不能通过其他方法改变其上下文。这很蛋疼。 1234567891011function Period (hours, minutes) &#123; this.hours = hours; this.minutes = minutes;&#125;Period.prototype.format = () =&gt; &#123; console.log(this === window); // =&gt; true return this.hours + &apos; hours and &apos; + this.minutes + &apos; minutes&apos;;&#125;;var walkPeriod = new Period(2, 30); console.log(walkPeriod.hours);walkPeriod.format(); // =&gt; &apos;undefined hours and undefined minutes&apos; 此时的 this 实际上是指向了 window，所以 this.hours 和 this.minutes实际上没有声明的，故为 undefined。 在全局环境下，还是选用 函数表达式 来进行函数的定义，可以保证正确的上下文环境12345678910function Period (hours, minutes) &#123; this.hours = hours; this.minutes = minutes;&#125;Period.prototype.format = function() &#123; console.log(this === walkPeriod); // =&gt; true return this.hours + &apos; hours and &apos; + this.minutes + &apos; minutes&apos;;&#125;;var walkPeriod = new Period(2, 30); walkPeriod.format(); // &apos;2 hours and 30 minutes&apos;","tags":[{"name":"js","slug":"js","permalink":"http://tawen.github.io/tags/js/"},{"name":"js中this","slug":"js中this","permalink":"http://tawen.github.io/tags/js中this/"}]},{"title":"jQuery源码分析--$.Callbacks()","date":"2017-01-14T12:50:05.000Z","path":"2017/01/14/blog20170116/","text":"先上个简单的小例子:12345678910111213141516171819function aaa()&#123; alert(1);&#125;function bbb()&#123; alert(2);&#125;function ccc()&#123; alert(3);&#125;var cb = $.Callbacks();cb.add( aaa );cb.add( bbb );cb.add( ccc );cb.fire(); Callbacks的四个参数：once、memory、uniqueonce：fire只能触发一次（此参数作用与for循环）；memory：记忆参数，此参数作用于add方法；unique：唯一的（去重复）此参数设置在add方法中；stopOnFalse：此参数使return false起效果（此参数作于余额for循环）。 参数可支持组合方式 详细源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163jQuery.Callbacks = function( options ) &#123; // Convert options from String-formatted to Object-formatted if needed // (we check in cache first) options = typeof options === &quot;string&quot; ? ( optionsCache[ options ] || createOptions( options ) ) : jQuery.extend( &#123;&#125;, options ); var // Last fire value (for non-forgettable lists) memory, // Flag to know if list was already fired fired, // Flag to know if list is currently firing firing, // First callback to fire (used internally by add and fireWith) firingStart, // End of the loop when firing firingLength, // Index of currently firing callback (modified by remove if needed) firingIndex, // Actual callback list list = [], // Stack of fire calls for repeatable lists stack = !options.once &amp;&amp; [], // Fire callbacks fire = function( data ) &#123; memory = options.memory &amp;&amp; data; fired = true; firingIndex = firingStart || 0; firingStart = 0; firingLength = list.length; firing = true; for ( ; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++ ) &#123; if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false &amp;&amp; options.stopOnFalse ) &#123; memory = false; // To prevent further calls using add break; &#125; &#125; firing = false; if ( list ) &#123; if ( stack ) &#123; if ( stack.length ) &#123; fire( stack.shift() ); &#125; &#125; else if ( memory ) &#123; list = []; &#125; else &#123; self.disable(); &#125; &#125; &#125;, // Actual Callbacks object self = &#123; // Add a callback or a collection of callbacks to the list add: function() &#123; if ( list ) &#123; // First, we save the current length var start = list.length; (function add( args ) &#123; jQuery.each( args, function( _, arg ) &#123; var type = jQuery.type( arg ); if ( type === &quot;function&quot; ) &#123; if ( !options.unique || !self.has( arg ) ) &#123; list.push( arg ); &#125; &#125; else if ( arg &amp;&amp; arg.length &amp;&amp; type !== &quot;string&quot; ) &#123; // Inspect recursively add( arg ); &#125; &#125;); &#125;)( arguments ); // Do we need to add the callbacks to the // current firing batch? if ( firing ) &#123; firingLength = list.length; // With memory, if we&apos;re not firing then // we should call right away &#125; else if ( memory ) &#123; firingStart = start; fire( memory ); &#125; &#125; return this; &#125;, // Remove a callback from the list remove: function() &#123; if ( list ) &#123; jQuery.each( arguments, function( _, arg ) &#123; var index; while( ( index = jQuery.inArray( arg, list, index ) ) &gt; -1 ) &#123; list.splice( index, 1 ); // Handle firing indexes if ( firing ) &#123; if ( index &lt;= firingLength ) &#123; firingLength--; &#125; if ( index &lt;= firingIndex ) &#123; firingIndex--; &#125; &#125; &#125; &#125;); &#125; return this; &#125;, // Check if a given callback is in the list. // If no argument is given, return whether or not list has callbacks attached. has: function( fn ) &#123; return fn ? jQuery.inArray( fn, list ) &gt; -1 : !!( list &amp;&amp; list.length ); &#125;, // Remove all callbacks from the list empty: function() &#123; list = []; firingLength = 0; return this; &#125;, // Have the list do nothing anymore disable: function() &#123; list = stack = memory = undefined; return this; &#125;, // Is it disabled? disabled: function() &#123; return !list; &#125;, // Lock the list in its current state lock: function() &#123; stack = undefined; if ( !memory ) &#123; self.disable(); &#125; return this; &#125;, // Is it locked? locked: function() &#123; return !stack; &#125;, // Call all callbacks with the given context and arguments fireWith: function( context, args ) &#123; if ( list &amp;&amp; ( !fired || stack ) ) &#123; args = args || []; args = [ context, args.slice ? args.slice() : args ]; if ( firing ) &#123; stack.push( args ); &#125; else &#123; fire( args ); &#125; &#125; return this; &#125;, // Call all the callbacks with the given arguments fire: function() &#123; self.fireWith( this, arguments ); return this; &#125;, // To know if the callbacks have already been called at least once fired: function() &#123; return !!fired; &#125; &#125;; return self;&#125;;","tags":[{"name":"$.Callbacks()","slug":"Callbacks","permalink":"http://tawen.github.io/tags/Callbacks/"}]},{"title":"jQuery源码分析--工具方法$.ready()","date":"2017-01-14T12:50:05.000Z","path":"2017/01/14/blog20170114/","text":"三种dom加载方式1234567891011121314//第一种$(function()&#123; &#125;)//第二种$(document).ready(function()&#123; &#125;)//第三种$(document).on(&quot;ready&quot;,function()&#123; &#125;) 等加载外部js完成后，再执行$(function(){})123456789$.holdReady(true);$.getScript(&quot;test.js&quot;,function()&#123; $.holdReady(false)&#125;);$(function()&#123; //这样等test.js加载完成执行&#125;)","tags":[{"name":"ready()","slug":"ready","permalink":"http://tawen.github.io/tags/ready/"}]},{"title":"jQuery源码分析--插件接口extend","date":"2017-01-13T02:50:05.000Z","path":"2017/01/13/blog20170113/","text":"语法：1234$.fn.extend() //实例方法 this--&gt; $()$.extend() //静态方法 this--&gt; $jQuery.extend([deep], target, object1, [objectN]) deep:深拷贝 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364jQuery.extend = jQuery.fn.extend = function() &#123; var options, name, src, copy, copyIsArray, clone, target = arguments[0] || &#123;&#125;, i = 1, length = arguments.length, deep = false; // Handle a deep copy situation if ( typeof target === &quot;boolean&quot; ) &#123; deep = target; target = arguments[1] || &#123;&#125;; // skip the boolean and the target i = 2; &#125; // Handle case when target is a string or something (possible in deep copy) if ( typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target) ) &#123; target = &#123;&#125;; &#125; // extend jQuery itself if only one argument is passed if ( length === i ) &#123; target = this; --i; &#125; for ( ; i &lt; length; i++ ) &#123; // Only deal with non-null/undefined values if ( (options = arguments[ i ]) != null ) &#123; // Extend the base object for ( name in options ) &#123; src = target[ name ]; copy = options[ name ]; // Prevent never-ending loop if ( target === copy ) &#123; continue; &#125; // Recurse if we&apos;re merging plain objects or arrays if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) &#123; if ( copyIsArray ) &#123; copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src : []; &#125; else &#123; clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;; &#125; // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // Don&apos;t bring in undefined values &#125; else if ( copy !== undefined ) &#123; target[ name ] = copy; &#125; &#125; &#125; &#125; // Return the modified object return target;&#125;;","tags":[{"name":"插件接口extend","slug":"插件接口extend","permalink":"http://tawen.github.io/tags/插件接口extend/"}]},{"title":"jQuery源码分析--匿名函数自执行","date":"2017-01-12T02:50:05.000Z","path":"2017/01/12/blog20170112/","text":"匿名函数自执行123(function( window, undefined ) &#123; &#125;)(window) 传window参数的作用： 速度会快点； 对于压缩版本，可以简写； undefined是window的属性；（在ie7下是可以被修改的） use strict：严格模式（ie低版本不支持） jquery构造对象的方法： 12345678// Define a local copy of jQueryjQuery = function( selector, context ) &#123; // The jQuery object is actually just the init constructor &apos;enhanced&apos; return new jQuery.fn.init( selector, context, rootjQuery );&#125;// Give the init function the jQuery prototype for later instantiationjQuery.fn.init.prototype = jQuery.fn; 1234function Test()&#123; &#125;Test.prototype.constructor = Test // js源码会在函数创建完成时会自动在prototype原型上创建constructor指向构造函数","tags":[{"name":"匿名函数自执行","slug":"匿名函数自执行","permalink":"http://tawen.github.io/tags/匿名函数自执行/"}]},{"title":"读书笔记--监听器Listener","date":"2017-01-11T02:50:05.000Z","path":"2017/01/11/blog20170111/","text":"对应设计模式的Listener模式，事件触发时会自动触发该事件对应的Listener。主要监听session、request、context等进行监听。 Listener的概述使用Listener和Event来完成相应事件的处理。 listener的使用1234567891011121314151617import javax.servlet.http.HttpSession;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;public class SessionListenerTest implements HttpSessionListener &#123; public void sessionCreated(HttpSessionEvent se) &#123; HttpSession session = se.getSession(); System.out.println(&quot;新创建了一个session: &quot; + session); &#125; public void sessionDestroyed(HttpSessionEvent se) &#123; HttpSession session = se.getSession(); System.out.println(&quot;销毁了一个session: &quot; + session); &#125;&#125; 12345&lt;listener&gt; &lt;listener-class&gt; com.helloweenvsfei.listener.SessionListenerTest &lt;/listener-class&gt;&lt;/listener&gt; Listener的分类 8中listener，主要监听session、request、context的创建和销毁。6中Event 监听对象的创建和销毁HttpSessionListener、ServletContextListener、ServletRequestListener分别用于监听Session、content、request的创建和销毁。 HttpSessionListener：创建Session时：sessionCreated(HttpSessionEvent se)；超时或者执行session.invalidate()时： sessionDestroyed(HttpSessionEvent se)。用于收集在线信息。 ServletContextListener：服务启动或者热部署时：contextInitialized(ServletContextEvent event)；服务器关闭或者只关闭web时：contextDestroyed(ServletContextEvent event)。该listener可用获取web.xml里面的配置的初始化信息。 ServletRequestListener：用户请求时：requestInitialized(ServletRequestEvent event)；请求完成自动销毁时：requestDestroyed(ServletRequestEvent event)。如果html页面有多个图片会多次触发listener事件。 实例：监听session、request、context12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import javax.servlet.ServletContext;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.ServletRequestEvent;import javax.servlet.ServletRequestListener;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;public class ListenerTest implements HttpSessionListener, ServletContextListener, ServletRequestListener &#123; Log log = LogFactory.getLog(getClass()); // 创建 session public void sessionCreated(HttpSessionEvent se) &#123; HttpSession session = se.getSession(); log.info(&quot;新创建一个session, ID为: &quot; + session.getId()); &#125; // 销毁 session public void sessionDestroyed(HttpSessionEvent se) &#123; HttpSession session = se.getSession(); log.info(&quot;销毁一个session, ID为: &quot; + session.getId()); &#125; // 加载 context public void contextInitialized(ServletContextEvent sce) &#123; ServletContext servletContext = sce.getServletContext(); log.info(&quot;即将启动&quot; + servletContext.getContextPath()); &#125; // 卸载 context public void contextDestroyed(ServletContextEvent sce) &#123; ServletContext servletContext = sce.getServletContext(); log.info(&quot;即将关闭&quot; + servletContext.getContextPath()); &#125; // 创建 request public void requestInitialized(ServletRequestEvent sre) &#123; HttpServletRequest request = (HttpServletRequest) sre .getServletRequest(); String uri = request.getRequestURI(); uri = request.getQueryString() == null ? uri : (uri + &quot;?&quot; + request .getQueryString()); request.setAttribute(&quot;dateCreated&quot;, System.currentTimeMillis()); log.info(&quot;IP &quot; + request.getRemoteAddr() + &quot; 请求 &quot; + uri); &#125; // 销毁 request public void requestDestroyed(ServletRequestEvent sre) &#123; HttpServletRequest request = (HttpServletRequest) sre .getServletRequest(); long time = System.currentTimeMillis() - (Long) request.getAttribute(&quot;dateCreated&quot;); log.info(request.getRemoteAddr() + &quot;请求处理结束, 用时&quot; + time + &quot;毫秒. &quot;); &#125;&#125; 监听对象的属性变化 另一个Listener用于监听Session、context、request的属性变化，借口名格式为：xxxAttributeListener，包括HttpSessionAttributeListener、ServletContextAttributeListener、ServletRequestAttributeListener。当当向被监听对象添加、更新、移除属性时，会分别执行xxxAdded()/xxxReplaced()/xxxRemoved()方法，xxx分别代表Session、context、request。1234567891011121314151617181920212223242526272829303132333435import javax.servlet.http.HttpSession;import javax.servlet.http.HttpSessionAttributeListener;import javax.servlet.http.HttpSessionBindingEvent;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;public class SessionAttributeListenerTest implements HttpSessionAttributeListener &#123; Log log = LogFactory.getLog(getClass()); // 添加属性 public void attributeAdded(HttpSessionBindingEvent se) &#123; HttpSession session = se.getSession(); String name = se.getName(); log.info(&quot;新建session属性：&quot; + name + &quot;, 值为：&quot; + se.getValue()); &#125; // 删除属性 public void attributeRemoved(HttpSessionBindingEvent se) &#123; HttpSession session = se.getSession(); String name = se.getName(); log.info(&quot;删除session属性：&quot; + name + &quot;, 值为：&quot; + se.getValue()); &#125; // 修改属性 public void attributeReplaced(HttpSessionBindingEvent se) &#123; HttpSession session = se.getSession(); String name = se.getName(); Object oldValue = se.getValue(); log.info(&quot;修改session属性：&quot; + name + &quot;, 原值：&quot; + oldValue + &quot;, 新值：&quot; + session.getAttribute(name)); &#125;&#125; 监听Session内的对象HttpSessionBindingListener：当对象放到Session里面执行：valueBound(HttpSessionBindingEvent event)；当对象从Session中移除时执行：valueUnbound(HttpSessionBindingEvent event)。对象必须实现Listener接口。 HttpSessionActivationListener：服务器关闭时会将Session里的内容保存到硬盘上，这个过程叫做钝化。服务器重新启动时会将Session内容从硬盘上重新加载。当Session里的内容被钝化时执行：sessionWillPassivate(HttpSessionEvent se)；当对象重新加载时：sessionDidActivte(HttpSessionEvent se)。对象必须实现Listener接口。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.io.Serializable;import java.util.Date;import javax.servlet.http.HttpSession;import javax.servlet.http.HttpSessionActivationListener;import javax.servlet.http.HttpSessionBindingEvent;import javax.servlet.http.HttpSessionBindingListener;import javax.servlet.http.HttpSessionEvent;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;public class PersonInfo implements HttpSessionActivationListener, HttpSessionBindingListener, Serializable &#123; private static final long serialVersionUID = -4780592776386225973L; Log log = LogFactory.getLog(getClass()); private String name; private Date dateCreated; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Date getDateCreated() &#123; return dateCreated; &#125; public void setDateCreated(Date dateCreated) &#123; this.dateCreated = dateCreated; &#125; // 从硬盘加载后 public void sessionDidActivate(HttpSessionEvent se) &#123; HttpSession session = se.getSession(); log.info(this + &quot;已经成功从硬盘中加载。sessionId: &quot; + session.getId()); &#125; // 即将被钝化到硬盘时 public void sessionWillPassivate(HttpSessionEvent se) &#123; HttpSession session = se.getSession(); log.info(this + &quot;即将保存到硬盘。sessionId: &quot; + session.getId()); &#125; // 被放进session前 public void valueBound(HttpSessionBindingEvent event) &#123; HttpSession session = event.getSession(); String name = event.getName(); log.info(this + &quot;被绑定到session \\&quot;&quot; + session.getId() + &quot;\\&quot;的&quot; + name + &quot;属性上&quot;); // 记录放到session中的时间 this.setDateCreated(new Date()); &#125; // 从session中移除后 public void valueUnbound(HttpSessionBindingEvent event) &#123; HttpSession session = event.getSession(); String name = event.getName(); log.info(this + &quot;被从session \\&quot;&quot; + session.getId() + &quot;\\&quot;的&quot; + name + &quot;属性上移除&quot;); &#125; @Override public String toString() &#123; return &quot;PersonInfo(&quot; + name + &quot;)&quot;; &#125;&#125; Listener使用案例单点登录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot; %&gt;&lt;jsp:directive.page import=&quot;com.helloweenvsfei.singleton.PersonInfo&quot; /&gt;&lt;% String action = request.getParameter(&quot;action&quot;); String account = request.getParameter(&quot;account&quot;); if(&quot;login&quot;.equals(action) &amp;&amp; account.trim().length() &gt; 0)&#123; // 登录，将personInfo放入session PersonInfo personInfo = new PersonInfo(); personInfo.setAccount(account.trim().toLowerCase()); personInfo.setIp(request.getRemoteAddr()); personInfo.setLoginDate(new java.util.Date()); session.setAttribute(&quot;personInfo&quot;, personInfo); response.sendRedirect(response.encodeRedirectURL(request.getRequestURI())); return; &#125; else if(&quot;logout&quot;.equals(action))&#123; // 注销，将personInfo从session中移除 session.removeAttribute(&quot;personInfo&quot;); response.sendRedirect(response.encodeRedirectURL(request.getRequestURI())); return; &#125;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body &#123; font-size:12px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;c:choose&gt; &lt;c:when test=&quot;$&#123; personInfo != null &#125;&quot;&gt; &lt;!-- 已经登录，将显示帐号信息 --&gt; 欢迎您，$&#123; personInfo.account &#125;。&lt;br/&gt; 您的登录IP为$&#123; personInfo.ip &#125;，&lt;br/&gt; 登录时间为&lt;fmt:formatDate value=&quot;$&#123; personInfo.loginDate &#125;&quot; pattern=&quot;yyyy-MM-dd HH:mm&quot;/&gt;。 &lt;a href=&quot;$&#123; pageContext.request.requestURI &#125;?action=logout&quot;&gt;退出&lt;/a&gt; &lt;!-- 每5秒钟刷新一次页面 --&gt; &lt;script&gt;setTimeout(&quot;location=location; &quot;, 5000); &lt;/script&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;!-- 没有登录，将显示登录页面 --&gt; $&#123; msg &#125; &lt;c:remove var=&quot;msg&quot; scope=&quot;session&quot; /&gt; &lt;form action=&quot;$&#123; pageContext.request.requestURI &#125;?action=login&quot; method=&quot;post&quot;&gt; 帐号： &lt;input name=&quot;account&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;/body&gt;&lt;/html&gt;","tags":[{"name":"Listener","slug":"Listener","permalink":"http://tawen.github.io/tags/Listener/"}]},{"title":"读书笔记--会话跟踪","date":"2017-01-10T06:19:05.000Z","path":"2017/01/10/blog20170110/","text":"cookie机制 在浏览器地址栏输入javascript:alert(document.cookie)查看网站cookie 记录用户访问次数 java中把Cookie封装成javax.servlet.http.Cookie类。 每个Cookie都是Cookie类的对象。 服务端通过Cookie类对象对客服端进行操作。 通过request.getCookie()获取客服端提交的所有Cookie（以Cookie[]数组形式返回）。 通过response.addCookie(Cookie cookie)向客服端设置Cookie。 Cookie对象使用key-value属性对的形式保存用户状态，一个Cookie对象保存一个属性对，一个request和response同时使用多个Cookie。123456789101112131415161718192021222324252627282930313233request.setCharacterEncoding(&quot;UTF-8&quot;);String username = &quot;&quot;;int visitTimes = 0;// 所有的 cookieCookie[] cookies = request.getCookies();// 遍历所有的 Cookie 寻找 用户帐号信息与登录次数信息for(int i=0; cookies!=null&amp;&amp;i&lt;cookies.length; i++)&#123; Cookie cookie = cookies[i]; out.print(cookie.getName()); out.print(&quot;:&quot;); out.print(cookie.getValue()); out.print(&quot;&lt;br&gt;&quot;); if(&quot;username&quot;.equals(cookie.getName()))&#123; username = cookie.getValue(); &#125; else if(&quot;visitTimes&quot;.equals(cookie.getName()))&#123; visitTimes = Integer.parseInt(cookie.getValue()); cookie.setValue(&quot;&quot; + ++visitTimes); &#125;&#125;// 如果没有找到 Cookie 中保存的用户名，则转到登录界面if(username == null || username.trim().equals(&quot;&quot;))&#123; throw new Exception(&quot;您还没有登录。请先登录&quot;);&#125;// 修改 Cookie，更新用户的访问次数Cookie visitTimesCookie = new Cookie(&quot;visitTimes&quot;, Integer.toString(++visitTimes));response.addCookie(visitTimesCookie); Cookie不可跨域名Unicode编码保存中文编码使用java.net.URLEncoder类的encode(String str , String encoding)方法，解码使用java.net.URLDecoder类的decode(String str , String encoding)。 服务端：1234567// 使用中文的 Cookie. name 与 value 都使用 UTF-8 编码. Cookie cookie = new Cookie( URLEncoder.encode(&quot;姓名&quot;, &quot;UTF-8&quot;), URLEncoder.encode(&quot;刘京华&quot;, &quot;UTF-8&quot;)); // 发送到客户端 response.addCookie(cookie); 客户端：12345678910111213if(request.getCookies() != null)&#123; for(Cookie cc : request.getCookies())&#123; String cookieName = URLDecoder.decode(cc.getName(), &quot;UTF-8&quot;); String cookieValue = URLDecoder.decode(cc.getValue(), &quot;UTF-8&quot;); out.println(cookieName + &quot;=&quot;); out.println(cookieValue + &quot;; &lt;br/&gt;&quot;); &#125;&#125;else&#123; out.println(&quot;Cookie 已经写入客户端. 请刷新页面. &quot;);&#125; Base64编码：保存二进制图片 Cookie不仅可以使用ASCII与Unicode编码，还能使用二进制数据。读取图片 123456789101112131415161718File file = new File(this.getServletContext().getRealPath(&quot;/&quot;)+&quot;cookie.gif&quot;);// 二进制数组byte[] binary = new byte[(int)file.length()];// 从图片文件读取二进制数据. InputStream ins = this.getServletContext().getResourceAsStream(file.getName());ins.read(binary);ins.close();// BASE64 编码String content = BASE64Encoder.class.newInstance().encode(binary);// 包含二进制数据的 CookieCookie cookie = new Cookie(&quot;file&quot;, URLEncoder.encode(content,&quot;utf-8&quot;)); // 将 Cookie 发送到客户端 response.addCookie(cookie); 显示图片1234567891011121314151617181920212223242526// 清除输出out.clear();for(Cookie cookie : request.getCookies())&#123; if(cookie.getName().equals(&quot;file&quot;))&#123; // 从 Cookie 中取二进制数据 byte[] binary = BASE64Decoder.class.newInstance().decodeBuffer(URLDecoder.decode(cookie.getValue(), &quot;UTF-8&quot;).replace(&quot; &quot;, &quot;&quot;)); // 设置内容类型为 gif 图片 response.setHeader(&quot;Content-Type&quot;, &quot;image/gif&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;inline;filename=cookie.gif&quot;); response.setHeader(&quot;Connection&quot;, &quot;close&quot;); // 设置长度 response.setContentLength(binary.length); // 输出到客户端 response.getOutputStream().write(binary); response.getOutputStream().flush(); response.getOutputStream().close(); return; &#125;&#125; 设置Cookie的属性 name/value/maxAge/secure/path/domain/comment/version maxAge：Cookie失效时间，单位秒。为正数表示还有多长时间失效；为负数表示临时cookie关闭浏览器即会失效；为0删除Cookie；默认为-1。secure：Cookie是否被安全协议传输。默认为false。path：Cookie使用路径comment：Cookie用处说明 Session Sesssion对应的类是javax.servlet.http.HttpSession类。第一次访问是创建key-value属性对；通过getAttribute和setAttribute来获取和设置属性；通过request.getSession()方法来获取客户Session。 request.getSession() 若不存在，返回null； request.getSession(true) 若不存在，先创建Session，再返回Session。 servlet中必须使用request来获取HttpSession，而jsp中内置了Session隐藏对象，可以直接使用。 session的有效期getMaxInactiveInterval()setMaxInactiveInterval() Tomcat中session默认超时时间为20分钟。 URL地址重写session和cookie的比较存取方式Cookie只保存ASCII字符串，如果需要存取Unicode和二进制数据，需要进行utf-8等方式编码；Cookie不能直接存取java对象；Session可以存取任意类型数据。 隐私安全有效期服务器负担","tags":[{"name":"cookie","slug":"cookie","permalink":"http://tawen.github.io/tags/cookie/"},{"name":"session","slug":"session","permalink":"http://tawen.github.io/tags/session/"}]},{"title":"读书笔记--过滤器filter","date":"2017-01-10T06:19:05.000Z","path":"2017/01/10/blog20170110-2/","text":"Filter和Lister是Servlet规范里面的两个高级特性。不同于Servlet，他们不用处理客户请求，只用于对request和response进行修改或者对context、session、request事件进行监听。 Filter概述滤镜链（FilterChain）：多个Filter12345678910111213141516171819202122232425262728293031323334353637package javax.servlet;import java.io.IOException;public interface Filter2 &#123; /** * web 程序启动时调用此方法, 用于初始化该 Filter * * @param config * 可以从该参数中获取初始化参数以及ServletContext信息等 * @throws ServletException */ public void init(FilterConfig config) throws ServletException; /** * 客户请求服务器时会经过 * * @param request * 客户请求 * @param response * 服务器响应 * @param chain * 滤镜链, 通过 chain.doFilter(request, response) 将请求传给下个 Filter 或 * Servlet * @throws ServletException * @throws IOException */ public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException; /** * web 程序关闭时调用此方法, 用于销毁一些资源 */ public void destroy();&#125; Filter配置12345678910111213&lt;filter&gt; &lt;filter-name&gt;logFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.helloweenvsfei.filter.LogFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;waterMarkFile&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/logo.png&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;logFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;&lt;/filter-mapping&gt; dispatcher配置到达Servlet的方式（request/forward/include/error） Filter经典案例 防盗链Filter 12345678910111213141516171819202122232425262728293031323334353637383940public class ImageRedirectFilter implements Filter &#123; public void init(FilterConfig config) throws ServletException &#123; &#125; public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; // 禁止缓存 response.setHeader(&quot;Cache-Control&quot;, &quot;no-store&quot;); response.setHeader(&quot;Pragrma&quot;, &quot;no-cache&quot;); response.setDateHeader(&quot;Expires&quot;, 0); // 链接来源地址 String referer = request.getHeader(&quot;referer&quot;); if (referer == null || !referer.contains(request.getServerName())) &#123; /** * 如果 链接地址来自其他网站，则返回错误图片 */ request.getRequestDispatcher(&quot;/error.gif&quot;).forward(request, response); &#125; else &#123; /** * 图片正常显示 */ chain.doFilter(request, response); &#125; &#125; public void destroy() &#123; &#125;&#125; 1234567891011&lt;filter&gt; &lt;filter-name&gt;imageRedirectFilter&lt;/filter-name&gt; &lt;filter-class&gt; com.helloweenvsfei.filter.ImageRedirectFilter &lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;imageRedirectFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/images/*&lt;/url-pattern&gt; &lt;url-pattern&gt;/upload/images/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 字符编码Filter 12345678910111213141516171819202122232425262728293031public class CharacterEncodingFilter implements Filter &#123; private String characterEncoding; private boolean enabled; @Override public void init(FilterConfig config) throws ServletException &#123; characterEncoding = config.getInitParameter(&quot;characterEncoding&quot;); enabled = &quot;true&quot;.equalsIgnoreCase(characterEncoding.trim()) || &quot;1&quot;.equalsIgnoreCase(characterEncoding.trim()); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; if (enabled || characterEncoding != null) &#123; request.setCharacterEncoding(characterEncoding); response.setCharacterEncoding(characterEncoding); &#125; chain.doFilter(request, response); &#125; @Override public void destroy() &#123; characterEncoding = null; &#125;&#125; 123456789101112131415161718&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; com.helloweenvsfei.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;characterEncoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;enable&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 日志记录filter 1234567891011121314151617181920212223242526272829303132333435363738394041public class LogFilter implements Filter &#123; private Log log = LogFactory.getLog(this.getClass()); private String filterName; public void init(FilterConfig config) throws ServletException &#123; // 获取 Filter 的 name，配置在 web.xml 中 filterName = config.getFilterName(); log.info(&quot;启动 Filter: &quot; + filterName); &#125; public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; long startTime = System.currentTimeMillis(); String requestURI = request.getRequestURI(); requestURI = request.getQueryString() == null ? requestURI : (requestURI + &quot;?&quot; + request.getQueryString()); chain.doFilter(request, response); long endTime = System.currentTimeMillis(); log.info(request.getRemoteAddr() + &quot; 访问了 &quot; + requestURI + &quot;, 总用时 &quot; + (endTime - startTime) + &quot; 毫秒。&quot;); &#125; public void destroy() &#123; log.info(&quot;关闭 Filter: &quot; + filterName); &#125;&#125; 异常捕获filter 123456789101112131415161718192021222324252627282930313233343536373839404142public class ExceptionHandlerFilter implements Filter &#123; public void destroy() &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; try &#123; chain.doFilter(request, response); &#125; catch (Exception e) &#123; Throwable rootCause = e; while (rootCause.getCause() != null) &#123; rootCause = rootCause.getCause(); &#125; String message = rootCause.getMessage(); message = message == null ? &quot;异常：&quot; + rootCause.getClass().getName() : message; request.setAttribute(&quot;message&quot;, message); request.setAttribute(&quot;e&quot;, e); if (rootCause instanceof AccountException) &#123; request.getRequestDispatcher(&quot;/accountException.jsp&quot;).forward( request, response); &#125; else if (rootCause instanceof BusinessException) &#123; request.getRequestDispatcher(&quot;/businessException.jsp&quot;).forward( request, response); &#125; else &#123; request.getRequestDispatcher(&quot;/exception.jsp&quot;).forward(request, response); &#125; &#125; &#125; public void init(FilterConfig arg0) throws ServletException &#123; &#125;&#125; 权限验证filter 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class PrivilegeFilter implements Filter &#123; private Properties pp = new Properties(); public void init(FilterConfig config) throws ServletException &#123; // 从 初始化参数 中获取权 限配置文件 的位置 String file = config.getInitParameter(&quot;file&quot;); String realPath = config.getServletContext().getRealPath(file); try &#123; pp.load(new FileInputStream(realPath)); &#125; catch (Exception e) &#123; config.getServletContext().log(&quot;读取权限控制文件失败。&quot;, e); &#125; &#125; public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) req; // 获取访问的路径，例如：admin.jsp String requestURI = request.getRequestURI().replace( request.getContextPath() + &quot;/&quot;, &quot;&quot;); // 获取 action 参数，例如：add String action = req.getParameter(&quot;action&quot;); action = action == null ? &quot;&quot; : action; // 拼接成 URI。例如：log.do?action=list String uri = requestURI + &quot;?action=&quot; + action; // 从 session 中获取用户权限角色。 String role = (String) request.getSession(true).getAttribute(&quot;role&quot;); role = role == null ? &quot;guest&quot; : role; boolean authentificated = false; // 开始检查该用户角色是否有权限访问 uri for (Object obj : pp.keySet()) &#123; String key = ((String) obj); // 使用正则表达式验证 需要将 ? . 替换一下，并将通配符 * 处理一下 if (uri.matches(key.replace(&quot;?&quot;, &quot;\\\\?&quot;).replace(&quot;.&quot;, &quot;\\\\.&quot;) .replace(&quot;*&quot;, &quot;.*&quot;))) &#123; // 如果 role 匹配 if (role.equals(pp.get(key))) &#123; authentificated = true; break; &#125; &#125; &#125; if (!authentificated) &#123; throw new RuntimeException(new AccountException( &quot;您无权访问该页面。请以合适的身份登陆后查看。&quot;)); &#125; // 继续运行 chain.doFilter(req, res); &#125; public void destroy() &#123; pp = null; &#125;&#125; 内容替换filter gzip压缩filter 内容替换filter 图片水印Filter 缓存Filter xslt转化Filter 文件上传Filter","tags":[{"name":"过滤器filter","slug":"过滤器filter","permalink":"http://tawen.github.io/tags/过滤器filter/"}]},{"title":"位运算符NOT(~)","date":"2017-01-09T08:50:05.000Z","path":"2017/01/09/blog20170109/","text":"位运算符由否定好(~)表示，它是ECMAScript中为数不多的与二进制算术有关的运算符之一。位运算符NOT是三步的处理过程： 把运算数转为32位二进制数字 再转为它的二进制反码 把二进制反码转为浮点数 1234567891011121314var temp = ~5;/*5 二进制 101，补满 32位00000000000000000000000000000101按位取反11111111111111111111111111111010由于32位开头第一个是1，所以这是一个负数，将二进制转换成负数，需要先反码00000000000000000000000000000101之后，再+100000000000000000000000000000110转换成十进制为6，加上符号变成负数 -6*/alert(temp);// 弹出【-6】 感觉很麻烦，而上述操作简单来说，可以相当于对数字求负，然后减1，比如~25 === -26","tags":[{"name":"js","slug":"js","permalink":"http://tawen.github.io/tags/js/"},{"name":"位运算符NOT(~)","slug":"位运算符NOT","permalink":"http://tawen.github.io/tags/位运算符NOT/"}]},{"title":"读书笔记--jsp行为","date":"2017-01-06T08:50:05.000Z","path":"2017/01/06/blog20170106/","text":"JSP行为是一组JSP内置标签，jsp行为是对常用jsp功能的抽象与封装。（自定义jsp行为和标准jsp行为）标准jsp行为格式：1&lt;jsp:elements &#123;attribute=&quot;value&quot;&#125;* /&gt; include行为1&lt;jsp:include page=&quot;relativeURL&quot; flush=&quot;true&quot; /&gt; flush属性：设置读入被保存文件内容前是否清空缓存，默认为false javabean 行为 包括useBean、setProperty、getProperty useBean1&lt;jsp:useBean id=&quot;beanID&quot; class=&quot;className&quot; scope=&quot;value&quot; /&gt; id 引用javabean对象 class 全类名 scope javabean使用范围 setProperty1&lt;jsp:setProperty name=&quot;beanName&quot; property=&quot;propertyName&quot; value=&quot;&quot; /&gt; getProperty1&lt;jsp:getProperty name=&quot;beanName&quot; property=&quot;propertyName&quot; /&gt; jstl 是一套标准jsp行为 plugin行为1234&lt;jsp:plugin /&gt; //定义java applet&lt;jsp:params /&gt; //定义一组一对多的参数&lt;jsp:param /&gt; //定义单个参数&lt;jsp:fallback /&gt; //定义不支持applet的替代信息 forword 行为1&lt;jsp:forword page=&quot;relativeURL&quot;&gt; directive 行为12345&lt;jsp:directive.page&gt; //&lt;%@ page%&gt; &lt;jsp:directive.include file=&quot;relativeURL&quot; &gt; //&lt;%@ include file=&quot;relativeURL&quot; %&gt; &lt;jsp:directive.taglib uri=&quot;&quot; prefix=&quot;c&quot; &gt; //&lt;%@ taglib uri=&quot;&quot; prefix=&quot;c&quot; %&gt;","tags":[{"name":"jsp","slug":"jsp","permalink":"http://tawen.github.io/tags/jsp/"}]},{"title":"读书笔记--jsp配置","date":"2017-01-06T03:50:05.000Z","path":"2017/01/06/blog20170106-3/","text":"jsp配置123456789101112&lt;servlet&gt; &lt;servlet-name&gt;configuration&lt;/servlet-name&gt; &lt;jsp-file&gt;/configuration.jsp&lt;/jsp-file&gt; &lt;init-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;xiaomei&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;configuration&lt;/servlet-name&gt; &lt;servlet-name&gt;/configuration&lt;/servlet-name&gt;&lt;/servlet-mapping&gt; jsp-config 标签123456789&lt;jsp-config&gt; &lt;taglib&gt; &lt;taglib-uri&gt;&lt;/taglib-uri&gt; &lt;taglib-location&gt;&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;&lt;/url-pattern&gt; &lt;/jsp-property-group&gt;&lt;/jsp-config&gt;","tags":[{"name":"jsp","slug":"jsp","permalink":"http://tawen.github.io/tags/jsp/"}]},{"title":"读书笔记--jsp内置对象","date":"2017-01-06T02:50:05.000Z","path":"2017/01/06/blog20170106-2/","text":"九大内置对象： out、request、respone、page、pageContext、session、application、exception、config outout是javax.servlet.jsp.JspWriter类的实例； requestrequest是javax.servlet.ServletRequest类的实例，代表客户端请求； 1234567891011121314void setAttribute(String name,Object value)Object getAttribute(String name)String getMethod()String getParemeter(String key)String[] getParemeterValues(String key)Enumeration getParemeterNames()Cookie[] getCookies()String getContentPath()String getRequestURI()void setCharacterEncoding(String encoding)String getHead(String name)Enumeration getHeadNames()Dispatcher getRequestDispatcher()HttpSession getSession() responseresponse是javax.servlet.ServletResponse类的实例，代表客户端请求；123456addCookie(Cookie cookie)OutputStream getOutputStream()void sendRedirect(String url)PrintWriter getOut()void setHeader(String name,String valuse);void setStatus(int status) configconfig是javax.servlet.ServletConfig类的实例；1234String getInitParameter(String name)Enumeration getInitParameterNames()ServletContext getServletContext()String getServletName() sessionsession是javax.servlet.http.HttpSession类的实例；12345String getId()Long getCreationTime()Long getLastAccessedTime()int getMaxInactiveInterval()int setMaxInactiveInterval() applicationapplication是javax.servlet.ServletContext类的实例； pagepage是javax.servlet.jsp.HttpJspPage类的实例； pageContextexceptionexception是java.lang.Exception类的对象；","tags":[{"name":"jsp","slug":"jsp","permalink":"http://tawen.github.io/tags/jsp/"}]},{"title":"读书笔记--jsp指令","date":"2017-01-05T08:50:05.000Z","path":"2017/01/05/blog20170105/","text":"JSP指令用来声明JSP页面的一些属性。（编码方式、文件类型等） JSP指令格式：1&lt;%@ directive language=&quot;java&quot; contentType=&quot;text/html;charset =utf-8&quot; %&gt; 指令类型： page 、taglib 、 include page指令 page允许的属性只能出现一次，否则编译出错。import属性除外。 属性名称区分大小写 属性名称包括：language、import、session（默认为ture，可以直接使用session）、autoFlush（是否运行缓存，默认为true）、buffer（指定缓存大小，单位kb）、isThreadSafe（线程是否安全，默认为false，只能运行一个线程）、isErrorPage（指定页面是否为错误处理页面，默认为false；如果为true，jsp内置一个exception对象）、errorPage（某个JSP页面的相对路径）、contentType（文件类型）、info（任意字符串）、trimDirectiveWhitespaces（是否去除指令前后空白，默认为false） contentType html格式 text/html 纯文本 text/plain jpg图片 image/jpeg gif图片 image/gif word application/msword include指令1&lt;%@ include file=&quot;relativeURL&quot; %&gt; 先包含后编译 1&lt;jsp:include file=&quot;relativeURL&quot; &gt; 先运行后包含 taglib指令1&lt;%@ taglib uri=&quot;&quot; prefix=&quot;c&quot; %&gt; uri属性 类库地址 prefix 标签的前缀","tags":[{"name":"jsp","slug":"jsp","permalink":"http://tawen.github.io/tags/jsp/"}]},{"title":"Bootstrap之modal传参解决方案","date":"2017-01-04T01:50:05.000Z","path":"2017/01/04/blog20170104/","text":"今天用bootstrap的模态框做删除操作；发现点击删除后不能传参。 1、在点击触发modal事件元素上添加1data-data=&quot;数据&quot; 2、在boostrap.js文件modal模块中添加1if ($this.data(&quot;data&quot;)) $target.attr(&quot;data-data&quot;,option.data) 3、然后在模态框的div结构中就会有data-data属性标签了1&lt;div class=&quot;modal fade in&quot; id=&quot;deleteModal&quot; data-data=&quot;数据&quot; style=&quot;display: block;&quot;&gt; 4、数据已经传入到公用的删除结构中，就可以根据数据做操作了！","tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://tawen.github.io/tags/Bootstrap/"}]},{"title":"chrome设置--disable-web-security解决跨域","date":"2017-01-03T00:50:05.000Z","path":"2017/01/03/blog20170103/","text":"用Ajax获取数据，是常有的事情，同域下自然没问题了，如果是不同域获取数据，浏览器就有个同源策略的限制 错误提醒：Origin * is not allowed by Access-Control-Allow-Origin 有人会说用JSONP了。如果后台的数据接口只是返回单纯的json数据呢，而且也不能修改符合JSONP的方式的数据形式。 这个时候，我们该怎么办呢？ 如果你用的浏览器是Chrome的话，那么就有福音了。在打开Chrome的地址后边加上 –args –disable-web-security就可以屏蔽安全访问了[ –args：此参数可有可无]，然后就随意的调用不同域下的数据了。","tags":[{"name":"--disable-web-security","slug":"disable-web-security","permalink":"http://tawen.github.io/tags/disable-web-security/"}]},{"title":"HTTP协议","date":"2016-12-29T01:50:05.000Z","path":"2016/12/29/blog20161229/","text":"引言HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。HTTP协议的主要特点可概括如下： 1.支持客户/服务器模式。 2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 一、HTTP协议详解之URL篇http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。 HTTP URL (URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下：http://host[&quot;:&quot;port][abs_path]http表示要通过HTTP协议来定位网络资源；host表示合法的Internet主机域名或者IP地址；port指定一个端口号，为空则使用缺省端口80；abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。eg:1、输入：www.guet.edu.cn浏览器自动转换成：http://www.guet.edu.cn/2、http:192.168.0.116:8080/index.jsp 二、HTTP协议详解之请求篇http请求由三部分组成，分别是：请求行、消息报头、请求正文 1、请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。 请求方法（所有方法全为大写）有多种，各个方法的解释如下：GET 请求获取Request-URI所标识的资源POST 在Request-URI所标识的资源后附加新的数据HEAD 请求获取由Request-URI所标识的资源的响应消息报头PUT 请求服务器存储一个资源，并用Request-URI作为其标识DELETE 请求服务器删除Request-URI所标识的资源TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断CONNECT 保留将来使用OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求应用举例：GET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源，eg:GET /form.html HTTP/1.1 (CRLF) POST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。eg：POST /reg.jsp HTTP/ (CRLF)Accept:image/gif,image/x-xbit,… (CRLF)…HOST:www.guet.edu.cn (CRLF)Content-Length:22 (CRLF)Connection:Keep-Alive (CRLF)Cache-Control:no-cache (CRLF)(CRLF) //该CRLF表示消息报头已经结束，在此之前为消息报头user=jeffrey&amp;pwd=1234 //此行以下为提交的数据 HEAD方法与GET方法几乎是一样的，对于HEAD请求的回应部分来说，它的HTTP头部中包含的信息与通过GET请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到Request-URI所标识的资源的信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。2、请求报头后述3、请求正文(略) 三、HTTP协议详解之响应篇 在接收和解释请求消息后，服务器返回一个HTTP响应消息。 HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文1、状态行格式如下：HTTP-Version Status-Code Reason-Phrase CRLF其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求常见状态代码、状态描述、说明：200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，eg：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常eg：HTTP/1.1 200 OK （CRLF） 2、响应报头后述 3、响应正文就是服务器返回的资源的内容 四、HTTP协议详解之消息报头篇HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。 HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。 1、普通报头在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。eg：Cache-Control 用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.eg：为了指示IE浏览器（客户端）不要缓存页面，服务器端的JSP程序可以编写如下：response.sehHeader(“Cache-Control”,”no-cache”);//response.setHeader(“Pragma”,”no-cache”);作用相当于上述代码，通常两者//合用这句代码将在发送的响应消息中设置普通报头域：Cache-Control:no-cache Date普通报头域表示消息产生的日期和时间 Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接 2、请求报头请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。常用的请求报头AcceptAccept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。Accept-CharsetAccept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。Accept-EncodingAccept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。Accept-LanguageAccept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。AuthorizationAuthorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。Host（发送请求时，该报头域是必需的）Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg：我们在浏览器中输入：http://www.guet.edu.cn/index.html浏览器发送的请求消息中，就会包含Host请求报头域，如下：Host：www.guet.edu.cn此处使用缺省端口号80，若指定了端口号，则变成：Host：www.guet.edu.cn:指定端口号User-Agent我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。请求报头举例：GET /form.html HTTP/1.1 (CRLF)Accept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,/ (CRLF)Accept-Language:zh-cn (CRLF)Accept-Encoding:gzip,deflate (CRLF)If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)If-None-Match:W/“80b1a4c018f3c41:8317” (CRLF)User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)Host:www.guet.edu.cn (CRLF)Connection:Keep-Alive (CRLF)(CRLF) 3、响应报头响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。常用的响应报头LocationLocation响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。ServerServer响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。下面是Server响应报头域的一个例子：Server：Apache-Coyote/1.1WWW-AuthenticateWWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。eg：WWW-Authenticate:Basic realm=”Basic Auth Test!” //可以看出服务器对请求资源采用的是基本验证机制。 4、实体报头请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。常用的实体报头Content-EncodingContent-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法，eg：Content-Encoding：gzipContent-LanguageContent-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读者。eg：Content-Language:daContent-LengthContent-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。Content-TypeContent-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。eg：Content-Type:text/html;charset=ISO-8859-1Content-Type:text/html;charset=GB2312Last-ModifiedLast-Modified实体报头域用于指示资源的最后修改日期和时间。ExpiresExpires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。eg：Expires：Thu，15 Sep 2006 16:23:12 GMTHTTP1.1的客户端和缓存必须将其他非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0，jsp中程序如下：response.setDateHeader(“Expires”,”0”); 五、利用telnet观察http协议的通讯过程实验目的及原理： 利用MS的telnet工具，通过手动输入http请求信息的方式，向服务器发出请求，服务器接收、解释和接受请求后，会返回一个响应，该响应会在telnet窗口上显示出来，从而从感性上加深对http协议的通讯过程的认识。 实验步骤： 1、打开telnet1.1 打开telnet运行–&gt;cmd–&gt;telnet 1.2 打开telnet回显功能set localecho 2、连接服务器并发送请求2.1 open www.guet.edu.cn 80 //注意端口号不能省略 HEAD /index.asp HTTP/1.0 Host:www.guet.edu.cn /我们可以变换请求方法,请求桂林电子主页内容,输入消息如下/ open www.guet.edu.cn 80 GET /index.asp HTTP/1.0 //请求资源的内容 Host:www.guet.edu.cn 2.2 open www.sina.com.cn 80 //在命令提示符号下直接输入telnet www.sina.com.cn 80 HEAD /index.asp HTTP/1.0 Host:www.sina.com.cn 3 实验结果： 3.1 请求信息2.1得到的响应是: HTTP/1.1 200 OK //请求成功Server: Microsoft-IIS/5.0 //web服务器Date: Thu,08 Mar 200707:17:51 GMTConnection: Keep-AliveContent-Length: 23330Content-Type: text/htmlExpries: Thu,08 Mar 2007 07:16:51 GMTSet-Cookie: ASPSESSIONIDQAQBQQQB=BEJCDGKADEDJKLKKAJEOIMMH; path=/Cache-control: private //资源内容省略 3.2 请求信息2.2得到的响应是: HTTP/1.0 404 Not Found //请求失败Date: Thu, 08 Mar 2007 07:50:50 GMTServer: Apache/2.0.54 Last-Modified: Thu, 30 Nov 2006 11:35:41 GMTETag: “6277a-415-e7c76980”Accept-Ranges: bytesX-Powered-By: mod_xlayout_jh/0.0.1vhs.markII.remixVary: Accept-EncodingContent-Type: text/htmlX-Cache: MISS from zjm152-78.sina.com.cnVia: 1.0 zjm152-78.sina.com.cn:80&lt;squid/2.6.STABLES-20061207&gt;X-Cache: MISS from th-143.sina.com.cnConnection: close 失去了跟主机的连接 按任意键继续… 4 .注意事项：1、出现输入错误，则请求不会成功。 2、报头域不分大小写。 3、更深一步了解HTTP协议，可以查看RFC2616，在http://www.letf.org/rfc上找到该文件。 4、开发后台程序必须掌握http协议 六、HTTP协议相关技术补充1、基础： 高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等 中介由三种：代理(Proxy)、网关(Gateway)和通道(Tunnel)，一个代理根据URI的绝对格式来接受请求，重写全部或部分消息，通过 URI的标识把已格式化过的请求发送到服务器。网关是一个接收代理，作为一些其它服务器的上层，并且如果必须的话，可以把请求翻译给下层的服务器协议。一 个通道作为不改变消息的两个连接之间的中继点。当通讯需要通过一个中介(例如：防火墙等)或者是中介不能识别消息的内容时，通道经常被使用。 代理(Proxy)：一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的 服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处 理没有被用户代理完成的请求。网关(Gateway)：一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。 通道(Tunnel)：是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继 的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。 2、协议分析的优势—HTTP分析器检测网络攻击以模块化的方式对高层协议进行分析处理，将是未来入侵检测的方向。HTTP及其代理的常用端口80、3128和8080在network部分用port标签进行了规定 3、HTTP协议Content Lenth限制漏洞导致拒绝服务攻击使用POST方法时，可以设置ContentLenth来定义需要传送的数据长度，例如ContentLenth:999999999，在传送完成前，内 存不会释放，攻击者可以利用这个缺陷，连续向WEB服务器发送垃圾数据直至WEB服务器内存耗尽。这种攻击方法基本不会留下痕迹。http://www.cnpaf.net/Class/HTTP/0532918532667330.html 4、利用HTTP协议的特性进行拒绝服务攻击的一些构思服务器端忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求（毕竟客户端的正常请求比率非常之小），此时从正常客户的角度看来，服务器失去响应，这种情况我们称作：服务器端受到了SYNFlood攻击（SYN洪水攻击）。而Smurf、TearDrop等是利用ICMP报文来Flood和IP碎片攻击的。本文用“正常连接”的方法来产生拒绝服务攻击。19端口在早期已经有人用来做Chargen攻击了，即Chargen_Denial_of_Service，但是！他们用的方法是在两台Chargen 服务器之间产生UDP连接，让服务器处理过多信息而DOWN掉，那么，干掉一台WEB服务器的条件就必须有2个：1.有Chargen服务2.有HTTP 服务方法：攻击者伪造源IP给N台Chargen发送连接请求（Connect），Chargen接收到连接后就会返回每秒72字节的字符流（实际上根据网络实际情况，这个速度更快）给服务器。 5、Http指纹识别技术 Http指纹识别的原理大致上也是相同的：记录不同服务器对Http协议执行中的微小差别进行识别.Http指纹识别比TCP/IP堆栈指纹识别复杂许 多,理由是定制Http服务器的配置文件、增加插件或组件使得更改Http的响应信息变的很容易,这样使得识别变的困难；然而定制TCP/IP堆栈的行为 需要对核心层进行修改,所以就容易识别. 要让服务器返回不同的Banner信息的设置是很简单的,象Apache这样的开放源代码的Http服务器,用户可以在源代码里修改Banner信息,然 后重起Http服务就生效了；对于没有公开源代码的Http服务器比如微软的IIS或者是Netscape,可以在存放Banner信息的Dll文件中修 改,相关的文章有讨论的,这里不再赘述,当然这样的修改的效果还是不错的.另外一种模糊Banner信息的方法是使用插件。常用测试请求：1：HEAD/Http/1.0发送基本的Http请求2：DELETE/Http/1.0发送那些不被允许的请求,比如Delete请求3：GET/Http/3.0发送一个非法版本的Http协议请求4：GET/JUNK/1.0发送一个不正确规格的Http协议请求Http指纹识别工具Httprint,它通过运用统计学原理,组合模糊的逻辑学技术,能很有效的确定Http服务器的类型.它可以被用来收集和分析不同Http服务器产生的签名。 6、其他：为了提高用户使用浏览器时的性能，现代浏览器还支持并发的访问方式，浏览一个网页时同时建立多个连接，以迅速获得一个网页上的多个图标，这样能更快速完成整个网页的传输。HTTP1.1中提供了这种持续连接的方式，而下一代HTTP协议：HTTP-NG更增加了有关会话控制、丰富的内容协商等方式的支持，来提供更高效率的连接。","tags":[{"name":"js","slug":"js","permalink":"http://tawen.github.io/tags/js/"}]},{"title":"读书笔记——load-on-startup","date":"2016-12-29T01:50:05.000Z","path":"2016/12/29/blog20161230/","text":"web.xml中load-on-startup的作用1)load-on-startup元素标记容器是否在启动的时候就加载这个servlet(实例化并调用其init()方法)。 2)它的值必须是一个整数，表示servlet应该被载入的顺序 2)当值为0或者大于0时，表示容器在应用启动时就加载并初始化这个servlet； 3)当值小于0或者没有指定时，则表示容器在该servlet被选择时才会去加载。 4)正数的值越小，该servlet的优先级越高，应用启动时就越先加载。 5)当值相同时，容器就会自己选择顺序来加载。 所以，x，中x的取值1，2，3，4，5代表的是优先级，而非启动延迟时间。","tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://tawen.github.io/tags/Servlet/"}]},{"title":"DOM编程","date":"2016-12-28T01:50:05.000Z","path":"2016/12/28/blog20161228/","text":"1. DHTMLa. DOM: JavaScript将浏览器本身、网页文档、以及网页文档中的HTML元素等都用相应的内置对象来表示， 这些对象及对象之间的层次关系统称为DOM(文档对象模型)。 b. 事件 c. 事件源 d. 事件驱动(Event Driver) e. 事件处理程序(Event Handler) f. DHTML定义： css、脚本编程语言和DOM的结合使用，能够使HTML文档与用户具有交互性和动态变换性， 这三种技术的单一称谓叫DHTML(Dynamic HTML,动态HTML)。 g. 如何编写事件处理程序 方法1：在事件源对象所对应的HTML标签上增加一个要处理的属性，让事件属性值等于处理该事件的函数名或程序代码。1eg:&lt;body oncontextmenu=&quot;hideContextmenu()&quot;&gt;&lt;/body&gt; 方法2：直接在JavaScript代码中，设置元素编写某个元素对象对象的事件属性，让事件属性值等于处理该事件的函数名或程序代码。 方法3：在一个专门的标签对中编写某个元素对象的某种事件处理程序代码，并用for属性指定事件源和用event属性指定事件名。12345eg:&lt;script language=&quot;javascript&quot; for=&quot;document&quot; event=&quot;oncontextmenu&quot;&gt;window.event.returnValue=false;&lt;/script&gt; 2. window对象window代表整个浏览器窗口 window对象的成员方法： alert方法 confirm方法 prompt方法：显示用户输入框，返回用户输入的内容，可以有初始值。 navigate方法：让浏览器自动导航到指定页面 setInterval方法：浏览器每隔多长时间调用setInterval中程序代码。设置的时间以毫秒为单位。 setTimeout方法：设置浏览器过多长时间以后执行指定程序代码，时间以毫秒为单位。 clearInterval方法：取消前面etInterval方法进行的设置，参数须为etInterval方法的返回值。 clearTimeout方法：。。。 moveTo方法：用于将浏览器窗口移动到屏幕的某个位置。 resizeTo方法：改变浏览窗口大小，浏览器左上角坐标保持不变。 open方法：打开新窗口。 showModalDialog方法：显示对话框窗口。 showLessModalDialog方法：显示非。。。 frames数组对象1234567&lt;frameset&gt;&lt;frame&gt;&lt;/frame&gt;&lt;frame&gt;&lt;/frame&gt;&lt;/frameset&gt; 注意parent和top对象的区别 Event对象 用于获取和设置当前对象的有关信息 属性： altKey:判断alt键是否按下，按下则为true，否则为false。 ctrlKey shiftKey clientX,clientY:窗口客户区（有效区）x,y坐标 screenX,screenY:用于设置和返回相对屏幕顶点的x,y坐标 offsetX,offsetY:用于设置和返回相对事件源的x,y坐标 X,Y:用于设置和返回相对事件源的父元素的x,y坐标 returnValue:用于设置和返回事件的返回值，以便浏览器判断是否需要对当前事件按照默认的方式进行处理， 设 置为false则浏览器会取消该事件的默认处理。 cancelBubble：用于设置事件是否向下传递 srcElement:用于设置和返回发生当前事件的事件源对象 keyCode:用于设置和返回键盘按下和弹起时按键的Unicode码值 button:鼠标事件 事件 专用事件 onload事件：浏览器装载完整个网页之后发生 onunload事件：浏览器窗口卸载完网页文档之后的事件 onbeforeunload：浏览器窗口卸载完网页文档之前的事件 通用事件 onclick事件 onmousemove事件 onmouseover事件 onmouseout事件 onmousedown事件 onmouseup事件 onkeydown事件 onkeyup事件 onkeypress事件：用户按下数字或字母键，按下并弹起两个步骤 window对象属性 closed：窗口是否关闭 opener：返回打开当前窗口的对象，如在父窗口中打开一个子窗口，子窗口的opener就是父窗口对象 defaultstatus：默认情况下状态栏显示的文本内容 status:设置和返回窗口状态栏当前正在显示的文本内容 screenTop:返回窗口左上角顶点在屏幕上的垂直位置 screenLeft:返回窗口左上角顶点在屏幕上的水平位置 对象类型的属性 location对象：用于设置和获得当前网页文档的url信息 window.location.href=”www.baidu.com&quot;; //等效于window.navigate(“www.baidu.com&quot;);定向到某一网页 window.location.replace(“www.baidu.com&quot;); //可以用于载入一个新网页，替换掉原来的网页 window.location.reload(“www.baidu.com&quot;); //重新载入，刷新 event对象：获取和设置当前发生的事件的有关信息 frames数组对象：表示窗口中所有中所有子窗口的集合，frameset标签会将浏览器窗口划分为若干子窗口，这些子窗口就用frames表示 screen对象：提供显示器色彩度和分辨率信息 clipboardData对象：提供了读写剪贴板的若干方法 history对象：提供了重新装载浏览器曾新访问过了的URL列表中的若干方法 document对象：代表整个网页文档 3. document对象cookie cookie是什么？ cookie由服务器颁发给浏览器，浏览器首次访问服务器时，服务器将cookie信息保存在浏览器中，浏览器将cookie信息保存在cookie存储区中， 浏览器下次访问服务器时将cookie信息带过去，cookie因服务器而不同。不同的浏览器cookie信息也不相同。 关于cookie的第二讲没有看完 属性 与&lt;body&gt;标签相关的属性 alinkColor属性：超链接被选中时的颜色 linkColor属性：超链接在正常状态下的颜色 vlinkColor属性：访问过的超链接的颜色 bgColor属性:文档背景颜色 fgColor属性：用于指定文档中文本的默认前景色 **js中颜色名称的字符串也可以是16进制rgb颜色值 描述网 页文档信息的属性： charset属性：设置和返回浏览器显示网页内容时所使用的当前编码字符集 defaultCharset：返回浏览器缺省编码字符集名称 cookie属性：设置和返回cookie字符串 fileCreatedDate属性：用于返回网页文档的创建时间，返回值为字符串 fileModifiedDate:网页文档的修改时间，返回值为字符串 fileSize:当前网页文档的大小 lastModified:用于返回web服务器向浏览器传递当前文档内容时，伴随发送的last-Modified头时的日期字符串格式 url:用于设置或返回浏览器访问当前网页时所采用的URL地址 URLUnencoded:返回浏览器访问当前网页时所采用的URL地址解码后的字符串 referrer:用于返回导航到当前网页的超链接源的URL地址 对象属性 forms数组：代表HTML文档所有form标签对的集合 anchors数组：代表HTML文档中所有指定name属性或id属性a标签对的集合，当对a标签指定了name或id属性，它就成了 定为标记符。anchors也即是定为标记的集合。 links数组：代表HTML文档中所有指定href属性a标签对的集合 images数组：代表所有image标签对的集合 scripts数组：代表所有script标签的集合 applets数组：代表所有applet标签的集合，Java中的一个专门技术 all数组：所有标签对象的集合 styleSheets数组对象：代表HTML文档中所有style,link标签或者是通过import语句定义和引用的样式表的集合 body对象：代表HTML文档中的body标签对，body中的元素可以作为body对象属性来引用 title对象：代表HTML文档中的title标签对，可以设置显示在浏览器标题栏上的内容 注：一般来说每个HTML标签在JavaScript中都有与之相对应的对象，HTML标签所有属性在JavaScript的对象中也有与之相对应的属性(并非一一对应) HTML元素对象与HTML元素标签之间的关系 id属性值不能重复，但name属性则可以 &lt;script&gt;标签的属性 defer：不用设置属性值的属性，装载的过程中不执行&lt;script&gt;标签对中的内容，装载完成之后才执行。 如果&lt;script&gt;标签对中有document.write(),document.write()执行的结果会覆盖原来的网页 language属性 type属性：W3C要求用type代替language属性，&lt;script type=”text/javascript”&gt;&lt;/script&gt; src属性：引用js文件 **一个web服务器如何借助image标签来收集其他web站点的页面访问次数的？ **使用script标签的src属性为其他站点的网页提供各种扩展功能。 方法 write方法：用于动态的向HTML文档中写入内容 writeln方法：可换行 open方法：打开新文档。建议使用window的open方法，功能一样。 close方法：关闭文档流。 clear方法：清除文档中的所有内容。 等价于一 下两句，最好用下面两句 document.write(“”); document.close(); getElementById方法 getElementByName方法 getElementByTagName方法 createElement方法：产生代表HTML元素的对象 createStyleSheet：产生样式表，或增加样式规则 文档加密 没听完。。。 4. body对象body对象–方法举例 appendChild方法：将一个对象所对应的HTML元素作为body标签对最后一个元素添加到body标签对中。1234567891011121314151617181920212223eg:&lt;script language=&quot;javascript&quot; name=script1&gt;function createA()&#123;var oa=document.createElement(&quot;A&quot;);oa.href=&quot;http://www.baidu.com&quot;;oa.innerText=&quot;我的百度&quot;;document.body.appendChild(oa);&#125;&lt;/script&gt;&lt;body onload=&quot;createA()&quot;&gt;下面的链接是动态产生的&lt;br&gt;&lt;body&gt; 专用属性： background属性：用于设置网页背景图片URL地址 bgProperties属性：用于设置背景图片是否随网页文档的滚动而滚动，缺省值是空字符串，表示背景图片随网页文档的滚动而滚动。设置为fixed则不滚动了。 text属性：用于设置和返回网页文档的文本的显示颜色。 topMarginx bottomMargin leftMargin rightMargin 分别用于设置网页文档的上边距下边距，左边距右边距 通用属性： id属性：用于设置和返回HTML元素的id属性值。id属性值用于给html元素指定唯一标识名。 name属性：用于设置和返回HTML元素的name属性值。 className属性：用于设置和返回HTML元素的class属性值。 innerText属性：用于设置和返回HTML元素的标签对之间的内容。返回只返回文本。 innerHTML属性：返回连同标签和文本一起返回。 outerText属性：设置和返回HTML标签符号本身和嵌套在他里面的内容。 outerHTML属性： offsetTop offsetLeft 用于设置或返回元素边界左上角顶点相对于他上层HTML元素左上角顶点的垂直和水平距离。 offsetWidth offsetHeight 返回HTML元素对象自身的宽度和高度。 clientTop clientLeft 返回元素对象客户区左上角顶点相对于自身边界的垂直和水平距离。 scroll对象：用于设置和返回HTML元素中是否显示滚动条。字符串类型，有三个值yes\\no\\auto scrollTop属性：用于设置和返回HTML元素上边界与当前被显示的内容上边界之间的距离。 scrollLeft属性：用于设置和返回HTML元素左边界与当前被显示的内容左边界之间的距离。 scrollWidth属性 scrollHeight属性 返回HTML元素整个内容的宽度和高度，包括当前没有显示的那部分内容。 body对象–事件 onselectstart和onscroll事件 onselectstart事件 选取网页文档内容时发生，若该事件处理函数返回FALSE则禁止复制网页文档中的内容 onscrol l事件：拖动滚动条时发生的事件。 onselectstart和onscroll事件应用实例。 body对象–对象类型属性 all数组与style对象 all：某个对象对应的HTML标签中所包含的所有的HTML子元素对象的集合。使用方式上和document的all属性用法相同。 style对象：用于设置某个对象对应的HTML标签的样式风格。 eg：在页面上实现图标的漂浮移动实例 5. form对象Form对象 form对象最主要的功能是能够直接访问HTML文档中的Form表单。一个web页面中可以有一个或多个form表单， 使用document.forms数组对象可以访问到各form表单。可以将&lt;form&gt;标签中嵌入的表单字段元素的名称作为form对象属性， 来引用该表单字段元素所对应的对象。 submit方法：用于向服务器提交表单数据，该方法并不产生onsubmit事件。 item方法：返回代表form表单中某个表单字段元素所对应的对象，接受的参数可以是表单字段元素的名称， 也可以是表单字段元素在form表单中的索引序号。item方法不能返回&lt;input type=”image”&gt;类型表单字段元素。 form对象属性 name,target,title,enctype,encoding(IE6以前的浏览器只支持encoding属性),method,action onsubmit事件 仅当onsubmit的处理函数返回true时表单方可被提交，否则不能被提交 form对象属性 all数组属性，通用属性，代表某个对象对应的html标签中包含的所有HTML子元素对象的集合，这里代表&lt;form&gt; 标签下所有元素对象的集合。 elements数组属性，代表form标签下除了&lt;input type=image&gt;之外的表单字段元素对象的集合。 children数组属性，所有直接子元素对象集合 6. form表单字段元素对象属性： defaultValue属性 disabled属性 form属性 readOnly属性 title属性 value属性 checked属性 列表框（select）专有属性 multiple属性 selectIndex属性 options属性 列表框选择相对象的属性 text属性 value属性 selected index 方法： blur方法 focus方法 click方法 setCapture方法 releaseCapture方法 selecte元素对象的add方法 事件： onChange事件 onSelect事件 onFocus事件 onBlur事件","tags":[{"name":"js","slug":"js","permalink":"http://tawen.github.io/tags/js/"}]},{"title":"电脑开机没法进入系统","date":"2016-12-27T01:50:05.000Z","path":"2016/12/27/blog20161227/","text":"今天早上来公司，打开电脑电源，等了好久都没用进入windows系统，显示屏一直没画面。后来发现，鼠标和键盘的指示灯也没法点亮！导致是什么原因呢？ 拯救电脑行动：1、因为显示屏没有画面，所以怀疑是连接主机的显示数据线有问题，所以换了一根，结果还是不行；2、后来仔细一开始键盘和鼠标指示灯都没法点亮；所以打开主机箱，把内存拔下来重新插上擦擦，重启插上，结果还是不行；3、后来仔细观察发现cpu风扇还在正常工作；所以想bios方面有问题，所以把主板电子拔下来，给主板放电，结果终于好了。 后来网上查了主板电子的作用，做以下记录：（将电池取下后几秒钟即可完成放电）1.以清除BIOS更改后的全部设置；2.恢复BIOS的初始设置；3.用于超频后，参数调得过高引起的不开机。","tags":[]},{"title":"使用npm scripts替代gulp","date":"2016-12-26T01:50:05.000Z","path":"2016/12/26/blog20161226/","text":"为什么要用npm scripts替代gulp现在前端自动化的配套工具估计都离不开gulp或者是grunt，有一些或许会用上webpack辅助用上最新的ES6语法等；但是不知道大家在使用gulp众多插件的时候有没有碰到过一些问题，比如：有一些插件你仅仅需要用到其中一点点的API、插件更新速度非常慢、有一些插件碰到bug的时候调试起来非常麻烦等。所以总结一下gulp或者grunt其实都会有以下问题： 依赖于插件作者调试很不方便插件文档说明不连贯而如果直接使用npm scripts完全可以避免这些问题，在我们package.json里面的scripts属性直接定义需要执行的任务，比如npm start和npm test其实就是npm run start和npm run test的缩写，我们可以在scripts里面定义各种需要的任务，举个最简单的例子(清除dist目录)： 1234567891011121314151617# 1.用gulp插件来实现var gulp = require(&apos;gulp&apos;);var del = require(&apos;del&apos;);gulp.task(&apos;clean&apos;, function() &#123; del([&apos;./dist/**/*&apos;]).then(paths =&gt; &#123; console.log(&apos;Deleted files and folders:\\n&apos;, paths.join(&apos;\\n&apos;)); &#125;);&#125;);# 2.用npm scripts来实现# package.json配置 ... &quot;scripts&quot;: &#123; clean: &quot;rimraf ./dist&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;rimraf&quot;: &quot;^2.5.2&quot; &#125; 从上面示例代码可以看出明显直接用npm scripts实现的同一个功能相对gulp要简单得多，当然这个功能比较简单，如果碰到复杂的一些任务肯定就有反对的声音了。那我们将细细将上面三点来阐述。 依赖于插件作者当你需要使用到最新的或者不那么流行的技术时，根本就没有插件给你使用；或者一些插件已经过时了。最新Babel 6已经发布，很多API明显修改了，所以很多gulp插件根本不适用于最新版本。 这个时候你就必须等待作者来更新插件，或者你自己去fix这些问题，这会导致你不能及时用上最新版本的工具。相反，当你直接使用npm scripts的时候，你只需要直接找到可以实现的工具即可。这意味着当新版本的Mocha、Babel、Webpack、Browserify发布的时候，你就可以马上用上这些版本。 就目前插件数量来说，没有什么可以打败npm包： 调试很不方便由于gulp增加了一层抽象，所以会有潜在的bug： 是否基础工具崩溃了？是否Grunt/Gulp插件崩溃了？是否配置文件出错了？是否用了不稳定的版本？而直接使用npm scripts直接避免了第2点跟第3点，而由于不使用那么多插件，那么包相对较少，第4点也很少会碰到。 插件文档说明不连贯相比有用过很多插件的人都知道，一些核心的工具文档写得总比包装起来的Gulp插件要清晰得多。举个简单的例子来说，如果我需要用到gulp-eslint插件，那么就可能会不断在gulp-eslint的文档跟ESLint网站切换，必须对比看看两者存在些什么区别。 为什么我们总是忽略使用npm scripts而更青睐于Gulp Gulp和Grunt之所以这么流行，主要有下面4个点： 开发者认为npm scripts需要能写命令行的技能 开发者认为npm scripts能处理的能力不足够 开发者觉得Gulp的流对于快速构建是很有必要的 开发者认为npm scripts不能跨平台运行 开发者认为npm scripts需要能写命令行的技能其实你完全不需要精通于Unix或者Windows的命令行脚本，比如你不知道在Unix下面删除一个目录的命令是：rm -rf，这其实没啥问题，你完全可以使用rimraf，同时它也是跨平台的。在这里推荐一个工具包资源网站：libraries.io 开发者认为npm scripts能处理的能力不足够npm scripts其实比你想象中的要强大，主要依赖于预处理和后置处理钩子，比如下面例子： 12345678910&#123; &quot;name&quot;: &quot;npm-scripts-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;npm scripts demo&quot;, &quot;scripts&quot;: &#123; &quot;prebuild&quot;: &quot;echo I run before the build script&quot;, &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot;, &quot;postbuild&quot;: &quot;echo I run after the build script&quot; &#125;&#125; 正如上面例子一样，prebuild定义的脚本会比build任务先执行，而postbuild定义的脚本会比build任务后执行，因为相对于build来说，增加了一个前缀pre和post，所以当我执行npm run build的时候会自动地顺序执行prebuild -&gt; build -&gt; postbuild。 同时你可以将一个大的任务不断拆分成小的任务，比如： 12345678910&#123; &quot;name&quot;: &quot;npm-scripts-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;npm scripts demo&quot;, &quot;scripts&quot;: &#123; &quot;clean&quot;: &quot;rimraf ./dist &amp;&amp; mkdir dist&quot;, &quot;prebuild&quot;: &quot;npm run clean&quot;, &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot; &#125;&#125; 在上面例子中将clean任务抽离出来了，当你执行npm run build的时候，会先自动执行npm run prebuild任务，那就相当于执行了npm run clean任务了，注意上面的&amp;&amp;表示先后顺序执行，区别于&amp;表示同时执行。 npm scripts的一些缺点不得不承认，用npm scripts来写自动化构建任务还是存在一些不足：不能在JSON文件里面写注释。有一些方法可以弥补这方面的不足： 写功能相对小而独立并且命名好的脚本名字 脚本跟文档分离（将文档写进READ.md） 直接分离脚本写进Makefile等独立的文件 推荐使用第一种，脚本名字本来就应该能够直接描述功能。","tags":[{"name":"npm","slug":"npm","permalink":"http://tawen.github.io/tags/npm/"}]},{"title":"前端工具概述","date":"2016-12-23T09:50:05.000Z","path":"2016/12/23/blog20161223-2/","text":"node , 是javascript语言的环境和平台， npm , bower 是一类，包管理， webpack , browserify , 是一类，javascript预编译模块的方案， requirejs , seajs , 是一类, 基于commonjs，amd，cmd，umd 之类的模块类包加载方案的框架， grunt , gulp , 前端工具，合并、压缩、编译 sass/less，browser 自动载入资源， react , angular , vue , backbone , 是一类，mvc , mvvm , mvp 之类的前端框架， jquery , zepto , prototype , 是一类，前端 DOM , BOM 类库 ， ext , yui , kissy , dojo , 是一类，前端应用组件， underscore , 函数式编程库。","tags":[]},{"title":"npm 常用命令详解","date":"2016-12-23T01:50:05.000Z","path":"2016/12/23/blog20161223/","text":"npm是什么NPM的全称是Node Package Manager，是随同NodeJS一起安装的包管理和分发工具，它很方便让JavaScript开发者下载、安装、上传以及管理已经安装的包 npm install 安装模块基础语法 123456789101112npm install (with no args, in package dir)npm install [&lt;@scope&gt;/]&lt;name&gt;npm install [&lt;@scope&gt;/]&lt;name&gt;@&lt;tag&gt;npm install [&lt;@scope&gt;/]&lt;name&gt;@&lt;version&gt;npm install [&lt;@scope&gt;/]&lt;name&gt;@&lt;version range&gt;npm install &lt;tarball file&gt;npm install &lt;tarball url&gt;npm install &lt;folder&gt;alias: npm icommon options: [-S|--save|-D|--save-dev|-O|--save-optional] [-E|--save-exact] [--dry-run] 安装包，默认会安装最新的版本 1npm install gulp 安装指定版本1npm install gulp@3.9.1 安装包并将信息保持到项目的package.json文件中 项目对模块的依赖可以使用下面的 3 种方法来表示（假设当前版本号是 1.1.0 ）： 兼容模块新发布的补丁版本：~1.1.0、1.1.x、1.1 兼容模块新发布的小版本、补丁版本：^1.1.0、1.x、1 兼容模块新发布的大版本、小版本、补丁版本：*、x -S, –save 安装包信息将加入到dependencies（生产阶段的依赖）1npm install gulp --save 或 npm install gulp -S package.json 文件的 dependencies 字段：123&quot;dependencies&quot;: &#123; &quot;gulp&quot;: &quot;^3.9.1&quot;&#125; -D, –save-dev 安装包信息将加入到devDependencies（开发阶段的依赖），所以开发阶段一般使用它1npm install gulp --save-dev 或 npm install gulp -D package.json 文件的 devDependencies字段：123&quot;devDependencies&quot;: &#123; &quot;gulp&quot;: &quot;^3.9.1&quot;&#125; -O, –save-optional 安装包信息将加入到optionalDependencies（可选阶段的依赖）1npm install gulp --save-optional 或 npm install gulp -O package.json 文件的optionalDependencies字段：123&quot;optionalDependencies&quot;: &#123; &quot;gulp&quot;: &quot;^3.9.1&quot;&#125; -E, –save-exact 精确安装指定模块版本1npm install gulp --save-exact 或 npm install gulp -E 输入命令npm install gulp -ES，留意package.json 文件的 dependencies 字段，以看出版本号中的^消失了123&quot;dependencies&quot;: &#123; &quot;gulp&quot;: &quot;3.9.1&quot;&#125; 模块的依赖都被写入了package.json文件后，他人打开项目的根目录（项目开源、内部团队合作），使用npm install命令可以根据dependencies配置安装所有的依赖包 1npm install 本地安装（local） 1npm install gulp 全局安装（global）,使用 -g 或 –global1npm install gulp -g npm uninstall 卸载模块基础语法123npm uninstall [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;]... [-S|--save|-D|--save-dev|-O|--save-optional]aliases: remove, rm, r, un, unlink 如卸载开发版本的模块 1npm uninstall gulp --save-dev npm update 更新模块基础语法1npm update [-g] [&lt;pkg&gt;...] npm outdated 检查模块是否已经过时基础语法1npm outdated [[&lt;@scope&gt;/]&lt;pkg&gt; ...] 此命令会列出所有已经过时的包，可以及时进行包的更新 npm ls 查看安装的模块基础语法123npm ls [[&lt;@scope&gt;/]&lt;pkg&gt; ...]aliases: list, la, ll 查看全局安装的模块及依赖1npm ls -g npm init 在项目中引导创建一个package.json文件安装包的信息可保持到项目的package.json文件中，以便后续的其它的项目开发或者他人合作使用，也说package.json在项目中是必不可少的。 npm init [-f|–force|-y|–yes] npm help 查看某条命令的详细帮助基础语法1npm help &lt;term&gt; [&lt;terms..&gt;] 例如输入npm help install，系统在默认的浏览器或者默认的编辑器中打开本地nodejs安装包的文件/nodejs/node_modules/npm/html/doc/cli/npm-install.html1npm help install npm root 查看包的安装路径输出 node_modules的路径1npm root [-g] npm config 管理npm的配置路径1234567npm config set &lt;key&gt; &lt;value&gt; [-g|--global]npm config get &lt;key&gt;npm config delete &lt;key&gt;npm config listnpm config editnpm get &lt;key&gt;npm set &lt;key&gt; &lt;value&gt; [-g|--global] 对于config这块用得最多应该是设置代理，解决npm安装一些模块失败的问题 例如我在公司内网，因为公司的防火墙原因，无法完成任何模块的安装，这个时候设置代理可以解决1npm config set proxy=http://dev-proxy.oa.com:8080 又如国内的网络环境问题，某官方的IP可能被和谐了，幸好国内有好心人，搭建了镜像，此时我们简单设置镜像1npm config set registry=&quot;http://r.cnpmjs.org&quot; 也可以临时配置，如安装淘宝镜像1npm install -g cnpm --registry=https://registry.npm.taobao.org npm cache 管理模块的缓存基础语法 12345678npm cache add &lt;tarball file&gt;npm cache add &lt;folder&gt;npm cache add &lt;tarball url&gt;npm cache add &lt;name&gt;@&lt;version&gt;npm cache ls [&lt;path&gt;]npm cache clean [&lt;path&gt;] 最常用命令无非清除npm本地缓存1npm cache clean npm start 启动模块基础语法1npm start [-- &lt;args&gt;] 该命令写在package.json文件scripts的start字段中，可以自定义命令来配置一个服务器环境和安装一系列的必要程序，如123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;gulp -ws&quot;&#125; 此时在cmd中输入npm start命令相当于执行gulpfile.js文件自定义的watch和server命令。 如果package.json文件没有设置start，则将直接启动node server.js npm stop 停止模块基础语法1npm stop [-- &lt;args&gt;] npm restart 重新启动模块基础语法1npm restart [-- &lt;args&gt;] npm test 测试模块基础语法12npm test [-- &lt;args&gt;]npm tst [-- &lt;args&gt;] 该命令写在package.json文件scripts的test字段中，可以自定义该命令来执行一些操作，如123&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;gulp release&quot;&#125;, 此时在cmd中输入npm test命令相当于执行gulpfile.js文件自定义的release命令。 npm version 查看模块版本基础语法12345npm version [&lt;newversion&gt; | major | minor | patch | premajor | preminor | prepatch | prerelease | from-git]&apos;npm [-v | --version]&apos; to print npm version&apos;npm view &lt;pkg&gt; version&apos; to view a package&apos;s published version&apos;npm ls&apos; to inspect current package/dependency versions 查看模块的版本1npm version npm view 查看模块的注册信息基础语法123npm view [&lt;@scope&gt;/]&lt;name&gt;[@&lt;version&gt;] [&lt;field&gt;[.&lt;subfield&gt;]...]aliases: info, show, v 查看模块的依赖关系1npm view gulp dependencies 查看模块的源文件地址1npm view gulp repository.url 查看模块的贡献者，包含邮箱地址1npm view npm contributors npm adduser 用户登录基础语法1npm adduser [--registry=url] [--scope=@orgname] [--always-auth] npm publish 发布模块基础语法1234npm publish [&lt;tarball&gt;|&lt;folder&gt;] [--tag &lt;tag&gt;] [--access &lt;public|restricted&gt;]Publishes &apos;.&apos; if no argument suppliedSets tag &apos;latest&apos; if no --tag specified npm access 在发布的包上设置访问级别基础语法 123456789npm access public [&lt;package&gt;]npm access restricted [&lt;package&gt;]npm access grant &lt;read-only|read-write&gt; &lt;scope:team&gt; [&lt;package&gt;]npm access revoke &lt;scope:team&gt; [&lt;package&gt;]npm access ls-packages [&lt;user&gt;|&lt;scope&gt;|&lt;scope:team&gt;]npm access ls-collaborators [&lt;package&gt; [&lt;user&gt;]]npm access edit [&lt;package&gt;] npm package.json的语法英文原版：https://docs.npmjs.com/files/package.json 这块内容好多，国内有好心人整理：《npm的package.json中文文档》，从这份文档拷贝出一些比较常见的，如下： 默认值npm会根据包内容设置一些默认值。1&quot;scripts&quot;: &#123;&quot;start&quot;: &quot;node server.js&quot;&#125; 如果包的根目录有server.js文件，npm会默认将start命令设置为node server.js。1&quot;scripts&quot;:&#123;&quot;preinstall&quot;: &quot;node-waf clean || true; node-waf configure build&quot;&#125; 如果包的根目录有wscript文件，npm会默认将preinstall命令用node-waf进行编译。1&quot;scripts&quot;:&#123;&quot;preinstall&quot;: &quot;node-gyp rebuild&quot;&#125; 如果包的根目录有binding.gyp文件，npm会默认将preinstall命令用node-gyp进行编译。1&quot;contributors&quot;: [...] 如果包的根目录有AUTHORS文件，npm会默认逐行按Name (url)格式处理，邮箱和url是可选的。#号和空格开头的行会被忽略。 name在package.json中最重要的就是name和version字段。他们都是必须的，如果没有就无法install。name和version一起组成的标识在假设中是唯一的。改变包应该同时改变version。 name是这个东西的名字。注意： 不要把node或者js放在名字中。因为你写了package.json它就被假定成为了js，不过你可以用”engine”字段指定一个引擎（见后文）。 这个名字会作为在URL的一部分、命令行的参数或者文件夹的名字。任何non-url-safe的字符都是不能用的。 这个名字可能会作为参数被传入require()，所以它应该比较短，但也要意义清晰。 在你爱上你的名字之前，你可能要去npm registry查看一下这个名字是否已经被使用了。http://registry.npmjs.org/ versionversion必须能被node-semver解析，它被包在npm的依赖中。（要自己用可以执行npm install semver） 可用的“数字”或者“范围”见semver(7). description放简介，字符串，方便在npm search中搜索 keywords关键字，数组、字符串，方便在npm search中搜索 bugs你项目的提交问题的url和（或）邮件地址 { “url” : “http://github.com/owner/project/issues&quot;,“email” : “project@hostname.com“} license你应该要指定一个许可证，让人知道使用的权利和限制的。 最简单的方法是，假如你用一个像BSD或者MIT这样通用的许可证，就只需要指定一个许可证的名字，像这样：1&#123; &quot;license&quot; : &quot;BSD&quot; &#125; 如果你又更复杂的许可条件，或者想要提供给更多地细节，可以这样:12345&quot;licenses&quot; : [ &#123; &quot;type&quot; : &quot;MyLicense&quot; , &quot;url&quot; : &quot;http://github.com/owner/project/path/to/license&quot; &#125;] repository指定你的代码存放的地方。这个对希望贡献的人有帮助。如果git仓库在github上，那么npm docs命令能找到你。 这样做： 123456789&quot;repository&quot; : &#123; &quot;type&quot; : &quot;git&quot; , &quot;url&quot; : &quot;http://github.com/isaacs/npm.git&quot; &#125;&quot;repository&quot; : &#123; &quot;type&quot; : &quot;svn&quot; , &quot;url&quot; : &quot;http://v8.googlecode.com/svn/trunk/&quot; &#125; URL应该是公开的（即便是只读的）能直接被未经过修改的版本控制程序处理的url。不应该是一个html的项目页面。因为它是给计算机看的。 scripts“scripts”是一个由脚本命令组成的hash对象，他们在包不同的生命周期中被执行。key是生命周期事件，value是要运行的命令。 参考上面的npm start、npm test命令 更多详细请看 npm-scripts(7) config“config” hash可以用来配置用于包脚本中的跨版本参数。在实例中，如果一个包有下面的配置：1234&#123; &quot;name&quot; : &quot;foo&quot;, &quot;config&quot; : &#123; &quot;port&quot; : &quot;8080&quot; &#125; &#125; 然后有一个“start”命令引用了npm_package_config_port环境变量，用户可以通过npm config set foo:port 8001来重写他。 参见 npm-config(7) 和 npm-scripts(7)。 dependencies依赖是给一组包名指定版本范围的一个hash。这个版本范围是一个由一个或多个空格分隔的字符串。依赖还可以用tarball或者git URL。 请不要将测试或过渡性的依赖放在dependencieshash中。见下文的devDependencies 详见semver(7). version 必须完全和version一致 version 必须比version大 =version 同上 &lt;version 同上 &lt;=version 同上 ~version 大约一样，见semver(7) 1.2.x 1.2.0, 1.2.1, 等，但不包括1.3.0 http://… 见下文’依赖URL’ 所有 “” 空，同* version1 - version2 同 &gt;=version1 &lt;=version2. range1 || range2 二选一。 git… 见下文’依赖Git URL’ user/repo 见下文’GitHub URLs’ 比如下面都是合法的：12345678910111213&#123; &quot;dependencies&quot; : &#123; &quot;foo&quot; : &quot;1.0.0 - 2.9999.9999&quot; , &quot;bar&quot; : &quot;&gt;=1.0.2 &lt;2.1.2&quot; , &quot;baz&quot; : &quot;&gt;1.0.2 &lt;=2.3.4&quot; , &quot;boo&quot; : &quot;2.0.1&quot; , &quot;qux&quot; : &quot;&lt;1.0.0 || &gt;=2.3.1 &lt;2.4.5 || &gt;=2.5.2 &lt;3.0.0&quot; , &quot;asd&quot; : &quot;http://asdf.com/asdf.tar.gz&quot; , &quot;til&quot; : &quot;~1.2&quot; , &quot;elf&quot; : &quot;~1.2.3&quot; , &quot;two&quot; : &quot;2.x&quot; , &quot;thr&quot; : &quot;3.3.x&quot; &#125;&#125; devDependencies如果有人要使用你的模块，那么他们可能不需要你开发使用的外部测试或者文档框架。 在这种情况下，最好将这些附属的项目列在devDependencies中。 这些东西会在执行npm link或者npm install的时候初始化，并可以像其他npm配置参数一样管理。详见npm-config(7)。 对于非特定平台的构建步骤，比如需要编译CoffeeScript，可以用prepublish脚本去实现，并把它依赖的包放在devDependency中。（译者注：prepublish定义了在执行npm publish的时候先行执行的脚本） 比如： 1234567891011&#123; &quot;name&quot;: &quot;ethopia-waza&quot;, &quot;description&quot;: &quot;a delightfully fruity coffee varietal&quot;, &quot;version&quot;: &quot;1.2.3&quot;, &quot;devDependencies&quot;: &#123; &quot;coffee-script&quot;: &quot;~1.6.3&quot; &#125;, &quot;scripts&quot;: &#123; &quot;prepublish&quot;: &quot;coffee -o lib/ -c src/waza.coffee&quot; &#125;, &quot;main&quot;: &quot;lib/waza.js&quot;&#125; prepublish脚本会在publishing前运行，这样用户就不用自己去require来编译就能使用。并且在开发模式中（比如本地运行npm install）会运行这个脚本以便更好地测试。","tags":[{"name":"npm","slug":"npm","permalink":"http://tawen.github.io/tags/npm/"}]},{"title":"jquery的stop()用法","date":"2016-12-22T03:50:05.000Z","path":"2016/12/22/blog20161222-2/","text":"stop(stopAll,goToEnd) 参数stopAll，可选。代表是否要清空未执行完的动画队列。如果使用stop()方法，则会立即停止当前正在运行的动画，如果接下来还有动画等待执行，则以当前状态开始接下来的动画。 参数goToEnd，可选。代表是否直接将正在执行的动画跳转到末状态。 stop(false)：不停止被选元素所有加入队列的动画，仅停止当前的动画。 stop(true)：停止所有加入队列的动画。 stop(false,true)：直接停止当前动画，并跳转至当前动画的最终末尾效果位置，接着正常执行后面的动画队列，直至完成整个动画。 stop(true,true)：animater跳到当前动画的最终末尾效果位置。","tags":[{"name":"jquery","slug":"jquery","permalink":"http://tawen.github.io/tags/jquery/"},{"name":"stop","slug":"stop","permalink":"http://tawen.github.io/tags/stop/"}]},{"title":"markdown 简明语法","date":"2016-12-22T01:50:05.000Z","path":"2016/12/22/blog20161222/","text":"基本符号 *,-,+ 3个符号效果都一样，这3个符号被称为 Markdown符号 空白行表示另起一个段落 `是表示inline代码，tab是用来标记 代码段，分别对应html的code，pre标签 换行 单一段落( &lt; p &gt;) 用一个空白行 连续两个空格 会变成一个 连续3个符号，然后是空行，表示 hr横线 标题 生成h1–h6,在文字前面加上 1–6个# 来实现 文字加粗是通过 文字左右各两个符号 引用 在第一行加上 “&gt;”和一个空格，表示代码引用，还可以嵌套 列表这个是markdown文件的主要表示方式，主题要点化 使用*,+,-加上一个空格来表示 可以支持嵌套 有序列表用 数字+英文点+空格来表示 列表内容很长，不需要手工输入换行符，css控制段落的宽度，会自动的缩放的 链接 直接写 锚文本 引用 先定义 [ref_name]:url，然后在需要写入url的地方， 这样使用[锚文本][ref_name]，通常的ref_name一般用数字表示，这样显得专业 简写url：用尖括号包裹url 这样生成的url锚文本就是url本身 插入图片 一行表示: 1![alt_text](url &quot;可选的title&quot;) 引用表示法: ![alt_text][id],预先定义 [id]:url “可选title” 直接使用标签，这样可以指定图片的大小尺寸 特殊符号 用\\来转义，表示文本中的markdown符号 可以在文本种直接使用html标签，但是要注意在使用的时候，前后加上空行 文本前后各加一个符号，表示斜体","tags":[{"name":"markdown","slug":"markdown","permalink":"http://tawen.github.io/tags/markdown/"}]},{"title":"java学习记录--Java反射机制","date":"2016-12-21T14:17:17.000Z","path":"2016/12/21/blog20161221-10/","text":"理解Class类并实例化Class类对象 Java Reflection Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法 Java反射机制提供的功能 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时调用任意一个对象的成员变量和方法 生成动态代理 反射相关的主要API：java.lang.Class:代表一个类java.lang.reflect.Method:代表类的方法java.lang.reflect.Field:代表类的成员变量java.lang.reflect.Constructor:代表类的构造方法。。。 Class 类在Object类中定义了以下的方法，此方法将被所有子类继承：● public final Class getClass() 以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。 对照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个类的有关信息。 Class本身也是一个类 Class 对象只能由系统建立对象 一个类在 JVM 中只会有一个Class实例 一个Class对象对应的是一个加载到JVM中的一个.class文件 每个类的实例都会记得自己是由哪个 Class 实例所生成 通过Class可以完整地得到一个类中的完整结构 实例化Class类对象(四种方法) 1）前提：若已知具体的类，通过类的class属性获取，该方法 最为安全可靠，程序性能最高 实例：Class clazz = String.class;2）前提：已知某个类的实例，调用该实例的getClass()方法获 取Class对象 实例：Class clazz = “www.atguigu.com”.getClass();3）前提：已知一个类的全类名，且该类在类路径下，可通过 Class类的静态方法forName()获取，可能抛出ClassNotFoundException 实例：Class clazz = Class.forName(“java.lang.String”);4）其他方式(不做要求) ClassLoader cl = this.getClass().getClassLoader(); Class clazz4 = cl.loadClass(“类的全类名”); 了解：ClassLoader类加载器是用来把类(class)装载进内存的。JVM 规范定义了两种类型的类加载器：启动类加载器(bootstrap)和用户自定义加载器(user-defined class loader)。 JVM在运行时会产生3个类加载器组成的初始化加载器层次结构 ，如下图所示： 123456789101112131415161718192021//1.获取一个系统类加载器ClassLoader classloader = ClassLoader.getSystemClassLoader();System.out.println(classloader);//2.获取系统类加载器的父类加载器，即扩展类加载器classloader = classloader.getParent();System.out.println(classloader);//3.获取扩展类加载器的父类加载器，即引导类加载器classloader = classloader.getParent();System.out.println(classloader);//4.测试当前类由哪个类加载器进行加载classloader = Class.forName(&quot;exer2.ClassloaderDemo&quot;).getClassLoader();System.out.println(classloader);//5.测试JDK提供的Object类由哪个类加载器加载classloader = Class.forName(&quot;java.lang.Object&quot;).getClassLoader();System.out.println(classloader);//*6.关于类加载器的一个主要方法：getResourceAsStream(String str):获取类路径下的指定文件的输入流InputStream in = null;in = this.getClass().getClassLoader().getResourceAsStream(&quot;exer2\\\\test.properties&quot;);System.out.println(in); 2.1.创建类的对象：调用Class对象的newInstance()方法要 求： 1）类必须有一个无参数的构造器。 2）类的构造器的访问权限需要足够。 难道没有无参的构造器就不能创建对象了吗？不是！只要在操作的时候明确的调用类中的构造方法，并将参数传递进去之后，才可以实例化操作。步骤如下：1）通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器2）向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。3）通过Constructor实例化对象。123456789//1.根据全类名获取对应的Class对象String name = “atguigu.java.Person&quot;;Class clazz = null;clazz = Class.forName(name);//2.调用指定参数结构的构造器，生成Constructor的实例Constructor con = clazz.getConstructor(String.class,Integer.class);//3.通过Constructor的实例创建对应类的对象，并初始化类属性Person p2 = (Person) con.newInstance(&quot;Peter&quot;,20);System.out.println(p2); 通过反射调用类的指定方法、指定属性 Field、Method、Constructor、Superclass、Interface、Annotation 实现的全部接口 所继承的父类 全部的构造器 全部的方法 全部的Field 使用反射可以取得：1.实现的全部接口public Class&lt;?&gt;[] getInterfaces()确定此对象所表示的类或接口实现的接口。 2.所继承的父类public Class&lt;? Super T&gt; getSuperclass()返回表示此 Class 所表示的实体（类、接口、基本类型）的父类的 Class。 3.全部的构造器public Constructor[] getConstructors()返回此 Class 对象所表示的类的所有public构造方法。public Constructor[] getDeclaredConstructors()返回此 Class 对象表示的类声明的所有构造方法。 Constructor类中：取得修饰符: public int getModifiers();取得方法名称: public String getName();取得参数的类型：public Class&lt;?&gt;[] getParameterTypes(); 4.全部的方法public Method[] getDeclaredMethods()返回此Class对象所表示的类或接口的全部方法public Method[] getMethods()返回此Class对象所表示的类或接口的public的方法 Method类中：public Class&lt;?&gt; getReturnType()取得全部的返回值public Class&lt;?&gt;[] getParameterTypes()取得全部的参数public int getModifiers()取得修饰符public Class&lt;?&gt;[] getExceptionTypes()取得异常信息 5.全部的Fieldpublic Field[] getFields()返回此Class对象所表示的类或接口的public的Field。public Field[] getDeclaredFields()返回此Class对象所表示的类或接口的全部Field。 Field方法中：public int getModifiers() 以整数形式返回此Field的修饰符public Class&lt;?&gt; getType() 得到Field的属性类型public String getName() 返回Field的名称。 Annotation相关 get Annotation(Class annotationClass)getDeclaredAnnotations()7.泛型相关获取父类泛型类型：Type getGenericSuperclass()泛型类型：ParameterizedType获取实际的泛型类型参数数组：getActualTypeArguments() 8.类所在的包 Package getPackage() 通过反射调用类中的指定方法、指定属性1.调用指定方法通过反射，调用类中的方法，通过Method类完成。步骤：1.通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型。2.之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。 说明： 1.Object 对应原方法的返回值，若原方法无返回值，此时返回null 2.若原方法若为静态方法，此时形参Object obj可为null 3.若原方法形参列表为空，则Object[] args为null 4.若原方法声明为private,则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法，将可访问private的方法。 2.调用指定属性 在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和get()方法就可以完成设置和取得属性内容的操作。public Field getField(String name) 返回此Class对象表示的类或接口的指定的public的Field。public Field getDeclaredField(String name)返回此Class对象表示的类或接口的指定的Field。 在Field中：public Object get(Object obj) 取得指定对象obj上此Field的属性内容public void set(Object obj,Object value) 设置指定对象obj上此Field的属性内容 注：在类中属性都设置为private的前提下，在使用set()和get()方法时，首先要使用Field类中的setAccessible(true)方法将需要操作的属性设置为可以被外部访问。public void setAccessible(true)访问私有属性时，让这个属性可见。 动态代理 之前为大家讲解过代理机制的操作，属于静态代理，特征是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。 最好可以通过一个代理类完成全部的代理功能 动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。 动态代理使用场合: 调试 远程方法调用 代理设计模式的原理: 使用一个代理将对象包装起来, 然后用该代理对象取代原始对象. 任何对原始对象的调用都要通过代理. 代理对象决定是否以及何时将方法调用转到原始对象上 Proxy ：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一个或多个接口动态地生成实现类。 提供用于创建动态代理类和动态代理对象的静态方法 static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;… interfaces) 创建一个动态代理类所对应的Class对象 static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 直接创建一个动态代理对象 1.创建一个实现接口InvocationHandler的类，它必须实现invoke方法，以完成代理的具体操作。12345678910public Object invoke(Object theProxy, Method method, Object[] params) throws Throwable&#123; try &#123; Object retval = method.invoke(targetObj, params); // Print out the result System.out.println(retval); return retval; &#125; catch (Exception exc)&#123;&#125; &#125; 2.创建被代理的类以及接口 3.通过Proxy的静态方法12345678newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 创建一个Subject接口代理 RealSubject target = new RealSubject();// Create a proxy to wrap the original implementation DebugProxy proxy = new DebugProxy(target); // Get a reference to the proxy through the Subject interface Subject sub = (Subject) Proxy.newProxyInstance( Subject.class.getClassLoader(), new Class[] &#123; Subject.class &#125;, proxy); 4.通过 Subject代理调用RealSubject实现类的方法 12String info = sub.say(“Peter&quot;, 24); System.out.println(info);","tags":[{"name":"java学习记录","slug":"java学习记录","permalink":"http://tawen.github.io/tags/java学习记录/"}]},{"title":"java学习记录--多线程","date":"2016-12-21T14:17:17.000Z","path":"2016/12/21/blog20161221-9/","text":"程序、进程、线程的概念程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。 进程(process)是程序的一次执行过程，或是正在运行的一个程序。动态过程：有它自身的产生、存在和消亡的过程。 如：运行中的QQ，运行中的MP3播放器 程序是静态的，进程是动态的线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。 若一个程序可同一时间执行多个线程，就是支持多线程的 Java中多线程的创建和使用 Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来实现。 Thread类的特性 每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体 通过该Thread对象的start()方法来调用这个线程 构造方法 Thread()：创建新的Thread对象 Thread(String threadname)：创建线程并指定线程实例名 Thread(Runnable target)：指定创建线程的目标对象，它实现了Runnable接口中的run方法 Thread(Runnable target, String name)：创建新的Thread对象 继承 Thread 类与实现 Runnable 接口继承Thread类 定义子类继承Thread类。 子类中重写Thread类中的run方法。 创建Thread子类对象，即创建了线程对象。 调用线程对象start方法：启动线程，调用run方法。 实现Runnable接口 定义子类，实现Runnable接口。 子类中重写Runnable接口中的run方法。 通过Thread类含参构造器创建线程对象。 将Runnable接口的子类对象作为实际参数传递给Thread类的构造方法中。 调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。 1public class Thread extends Object implements Runnable 【区别】继承Thread: 线程代码存放Thread子类run方法中。实现Runnable：线程代码存在接口的子类的run方法。 【实现方法的好处】1）避免了单继承的局限性2）多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。 Thread类的主要方法void start(): 启动线程，并执行对象的run()方法run(): 线程在被调度时执行的操作String getName(): 返回线程的名称void setName(String name):设置该线程名称static currentThread(): 返回当前线程 线程的调度与设置优先级 调度策略 时间片 抢占式：高优先级的线程抢占CPU Java的调度方法 同优先级线程组成先进先出队列（先到先服务），使用时间片策略 对高优先级，使用优先调度的抢占式策略 线程的优先级控制MAX_PRIORITY（10）;MIN _PRIORITY （1）;NORM_PRIORITY （5）; 涉及的方法：getPriority() ：返回线程优先值setPriority(int newPriority) ：改变线程的优先级线程创建时继承父线程的优先级 Thread类的有关方法(2)static void yield()：线程让步 暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程 若队列中没有同优先级的线程，忽略此方法 join() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止 低优先级的线程也可以获得执行 static void sleep(long millis)：(指定时间:毫秒) 令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。 抛出InterruptedException异常stop(): 强制线程生命期结束 boolean isAlive()：返回boolean，判断线程是否还活着 补充：线程的分类 Java中的线程分为两类：一种是守护线程，一种是用户线程。 它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。 守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程。 Java垃圾回收就是一个典型的守护线程。 若JVM中都是守护线程，当前JVM将退出。 线程的生命周期JDK中用Thread.State枚举表示了线程的几种状态 要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态： 新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件 运行：当就绪的线程被调度并获得处理器资源时,便进入运行状态， run()方法定义了线程的操作和功能 阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态 死亡：线程完成了它的全部工作或线程被提前强制性地中止 线程的同步Java对于多线程的安全问题提供了专业的解决方式： 同步机制synchronized (对象）{ // 需要被同步的代码； } synchronized还可以放在方法声明中，表示整个方法 为同步方法。例如： public synchronized void show (String name){ …. } 线程的通信 wait() 与 notify() 和 notifyAll() wait()：令当前线程挂起并放弃CPU、同步资源，使别的线程可访问并修改共享资源，而当前线程排队等候再次对资源的访问 notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待 notifyAll ()：唤醒正在排队等待资源的所有线程结束等待. Java.lang.Object提供的这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.IllegalMonitorStateException异常 wait() 方法 在当前线程中调用方法： 对象名.wait() 使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出 notify (或notifyAll) 为止。 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁） 调用此方法后，当前线程将释放对象监控权 ，然后进入等待 在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。 notify()/notifyAll() 在当前线程中调用方法： 对象名.notify() 功能：唤醒等待该对象监控权的一个线程。 调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）","tags":[{"name":"java学习记录","slug":"java学习记录","permalink":"http://tawen.github.io/tags/java学习记录/"}]},{"title":"java学习记录--IO流","date":"2016-12-21T13:17:17.000Z","path":"2016/12/21/blog20161221-8/","text":"java.io.File类的使用File类的常见构造方法：1public File(String pathname) 以pathname为路径创建File对象，可以是绝对路径或者相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。12public File(String parent,String child)以parent为父路径，child为子路径创建File对象。 File的静态属性String separator存储了当前系统的路径分隔符。 在UNIX中，此字段为‘/’，在Windows中，为‘\\’ 访问文件名：123456getName()getPath()getAbsoluteFile()getAbsolutePath()getParent()renameTo(File newName) 文件操作相关:12createNewFile()delete() 文件检测:12345exists()canWrite()canRead()isFile()isDirectory() 目录操作相关:1234mkDir()mkDirs()list()listFiles() 获取常规文件信息:12lastModified()length() IO原理及流的分类流的分类按操作数据单位不同分为：字节流(8 bit)，字符流(16 bit)按数据流的流向不同分为：输入流，输出流按流的角色的不同分为：节点流，处理流 Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。 节点流：(输入) FileInputStream、FileReader (输出） FileOutputStream、FileWriter缓冲流：(输入流）：BufferedInputStream、BufferedReader (输出流）：BufferedOutputStream、BufferedWriter 1234567891011## 文件流&gt; FileInputStream / FileOutputStream / FileReader / FileWriter** InputStream &amp; Reader **InputStream 和 Reader 是所有输入流的基类。InputStream（典型实现：FileInputStream） int read()int read(byte[] b)int read(byte[] b, int off, int len)1Reader（典型实现：FileReader） int read()int read(char [] c)int read(char [] c, int off, int len)12345程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件 IO 资源。** OutputStream &amp; Writer **OutputStream 和 Writer 也非常相似： void write(int b/int c);void write(byte[] b/char[] cbuf);void write(byte[] b/char[] buff, int off, int len);void flush();void close(); 需要先刷新，再关闭此流1因为字符流直接以字符作为操作单位，所以 Writer 可以用字符串来替换字符数组，即以 String 对象作为参数 void write(String str);void write(String str, int off, int len); 缓冲流 BufferedInputStream / BufferedOutputStream / BufferedReader / BufferedWriter 为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组 根据数据操作单位可以把缓冲流分为： 12BufferedInputStream 和 BufferedOutputStreamBufferedReader 和 BufferedWriter 缓冲流要“套接”在相应的节点流之上，对读写的数据提供了缓冲的功能，提高了读写的效率，同时增加了一些新的方法 对于输出的缓冲流，写出的数据会先在内存中缓存，使用flush()将会使内存中的数据立刻写出 转换流 InputStreamReader / OutputStreamWriter 转换流提供了在字节流和字符流之间的转换 Java API提供了两个转换流：InputStreamReader和OutputStreamWriter 字节流中的数据都是字符时，转成字符流操作更高效。 InputStreamReader 用于将字节流中读取到的字节按指定字符集解码成字符。需要和InputStream“套接”。 构造方法1234public InputStreamReader(InputStream in)public InputSreamReader(InputStream in,String charsetName)如： Reader isr = new InputStreamReader(System.in,”ISO5334_1”); OutputStreamWriter 用于将要写入到字节流中的字符按指定字符集编码成字节。需要和OutputStream“套接”。构造方法12public OutputStreamWriter(OutputStream out)public OutputSreamWriter(OutputStream out,String charsetName) 标准输入/输出流 System.in和System.out分别代表了系统标准的输入和输出设备 默认输入设备是键盘，输出设备是显示器 12System.in的类型是InputStreamSystem.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类 通过System类的setIn，setOut方法对默认设备进行改变。 12public static void setIn(InputStream in)public static void setOut(PrintStream out) 打印流（了解） PrintStream / PrintWriter 在整个IO包中，打印流是输出信息最方便的类。 PrintStream(字节打印流)和PrintWriter(字符打印流) 提供了一系列重载的print和println方法，用于多种数据类型的输出 PrintStream和PrintWriter的输出不会抛出异常 PrintStream和PrintWriter有自动flush功能 System.out返回的是PrintStream的实例 数据流（了解） DataInputStream / DataOutputStream 为了方便地操作Java语言的基本数据类型的数据，可以使用数据流。 数据流有两个类：(用于读取和写出基本数据类型的数据） DataInputStream 和 DataOutputStream 分别“套接”在 InputStream 和 OutputStream 节点流上123456DataInputStream中的方法 boolean readBoolean() byte readByte() char readChar() float readFloat() double readDouble() short readShort() long readLong() int readInt() String readUTF() void readFully(byte[] b) DataOutputStream中的方法 将上述的方法的read改为相应的write即可。 对象流 —-涉及序列化、反序列化 ObjectInputStream / ObjectOutputStream ObjectInputStream和OjbectOutputSteam 用于存储和读取对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。 序列化(Serialize)：用ObjectOutputStream类将一个Java对象写入IO流中 反序列化(Deserialize)：用ObjectInputStream类从IO流中恢复该Java对象 ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量 随机存取文件流 RandomAccessFile RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件 支持只访问文件的部分内容 可以向已存在的文件后追加内容 RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。RandomAccessFile 类对象可以自由移动记录指针： 12long getFilePointer()：获取文件记录指针的当前位置void seek(long pos)：将文件记录指针定位到 pos 位置 构造器 12public RandomAccessFile(File file, String mode) public RandomAccessFile(String name, String mode) 创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指定 RandomAccessFile 的访问模式： r: 以只读方式打开 rw：打开以便读取和写入 rwd:打开以便读取和写入；同步文件内容的更新 rws:打开以便读取和写入；同步文件内容和元数据的更新","tags":[{"name":"java学习记录","slug":"java学习记录","permalink":"http://tawen.github.io/tags/java学习记录/"}]},{"title":"java学习记录--Java枚举&注解","date":"2016-12-21T12:17:17.000Z","path":"2016/12/21/blog20161221-7/","text":"枚举类如何自定义枚举类JDK 1.5 新增的 enum 关键字用于定义枚举类若枚举只有一个成员, 则可以作为一种单例模式的实现方式 枚举类的属性 枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰枚举类的使用 private final 修饰的属性应该在构造器中为其赋值若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数 必须在枚举类的第一行声明枚举类对象。 枚举类和普通类的区别： 使用 enum 定义的枚举类默认继承了 java.lang.Enum 类 枚举类的构造器只能使用 private 访问控制符 枚举类的所有实例必须在枚举类中显式列出(, 分隔 ; 结尾). 列出的实例系统会自动添加 public static final 修饰 JDK 1.5 中可以在 switch 表达式中使用Enum定义的枚举类的对象作为表达式, case 子句可以直接使用枚举值的名字, 无需添加枚举类作为限定 如何使用enum定义枚举类枚举类的主要方法values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常。 实现接口的枚举类和普通 Java 类一样，枚举类可以实现一个或多个接口 若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式, 则可以让每个枚举值分别来实现该方法 注解AnnotationJDK内置的基本注解类型（3个）使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素 @Override: 限定重写父类方法, 该注释只能用于方法@Deprecated: 用于表示某个程序元素(类, 方法等)已过时@SuppressWarnings: 抑制编译器警告 自定义注解类型 定义新的 Annotation 类型使用 @interface 关键字 Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明. 其方法名和返回值定义了该成员的名字和类型. 可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用 default 关键字 123public @interface MyAnnotation&#123; String name() default “atguigu&quot;;&#125; 没有成员定义的 Annotation 称为标记; 包含成员变量的 Annotation 称为元数据 Annotation JDK 5.0 在 java.lang.reflect 包下新增了 AnnotatedElement 接口, 该接口代表程序中可以接受注解的程序元素 当一个 Annotation 类型被定义为运行时 Annotation 后, 该注释才是运行时可见, 当 class 文件被载入时保存在 class 文件中的 Annotation 才会被虚拟机读取 程序可以调用 AnnotationElement 对象的如下方法来访问 Annotation 信息 对注解进行注解（4个）JDK 的元 Annotation 用于修饰其他 Annotation 定义 JDK5.0提供了专门在注解上的注解类型，分别是： Retention Target Documented Inherited @Retention: 只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 可以保留多长时间, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用 @Rentention 时必须为该 value 成员变量指定值: RetentionPolicy.SOURCE: 编译器直接丢弃这种策略的注释RetentionPolicy.CLASS: 编译器将把注释记录在 class 文件中. 当运行 Java 程序时, JVM 不会保留注解。 这是默认值RetentionPolicy.RUNTIME:编译器将把注释记录在 class 文件中. 当运行 Java 程序时, JVM 会保留注释. 程序可以通过反射获取该注释 1234567891011public enum RetentionPolicy&#123; SOURCE, CLASS, RUNTIME&#125;@Retention(RetentionPolicy.SOURCE)@interface MyAnnotation1&#123; &#125;@interface MyAnnotation2&#123; &#125;@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation3&#123; &#125; @Target: 用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素. @Target 也包含一个名为 value 的成员变量.@Documented: 用于指定被该元 Annotation 修饰的 Annotation 类将被 javadoc 工具提取成文档.定义为Documented的注解必须设置Retention值为RUNTIME。@Inherited: 被它修饰的 Annotation 将具有继承性.如果某个类使用了被 @Inherited 修饰的 Annotation, 则其子类将自动具有该注解实际应用中，使用较少 利用反射获取注解信息（在反射部分涉及）","tags":[{"name":"java学习记录","slug":"java学习记录","permalink":"http://tawen.github.io/tags/java学习记录/"}]},{"title":"java学习记录--Java泛型","date":"2016-12-21T11:17:17.000Z","path":"2016/12/21/blog20161221-6/","text":"泛型(Generic)概念泛型，JDK1.5新加入的，解决数据类型的安全性问题，其主要原理是在类声明时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这样在类声明或实例化时只要指定好需要的具体的类型即可。Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮。 泛型的声明:1interface List&lt;T&gt; 和 class TestGen&lt;K,V&gt; 其中，T,K,V不代表值，而是表示类型。这里使用任意字母都可以。常用T表示，是Type的缩写。 泛型的实例化： 一定要在类名后面指定类型参数的值（类型）。如：12List&lt;String&gt; strList = new ArrayList&lt;String&gt;();Iterator&lt;Customer&gt; iterator = customers.iterator(); T只能是类，不能用基本数据类型填充。 泛型的几个重要使用 1.在集合中使用泛型 对象实例化时不指定泛型，默认为：Object。 泛型不同的引用不能相互赋值。 加入集合中的对象类型必须与指定的泛型类型一致。 静态方法中不能使用类的泛型。 如果泛型类是一个接口或抽象类，则不可创建泛型 类的对象。 不能在catch中使用泛型 从泛型类派生子类，泛型类型需具体化 2.自定义泛型类 12345678910111213141516171819202122class Person&lt;T&gt;&#123; //使用T类型定义变量 private T info; //使用T类型定义一般方法 public T getInfo()&#123; return info; &#125; public void setInfo(T info)&#123; this.info = info; &#125; //使用T类型定义构造器 public Person()&#123;&#125; public Person(T info)&#123; this.info = info; &#125; //static的方法中不能声明泛型 //public static void show(T t)&#123; //&#125; //不能在try-catch中使用泛型定义 //try&#123;&#125; //catch(T t)&#123;&#125; &#125; 3.泛型方法 方法，也可以被泛型化，不管此时定义在其中的类是不是泛型化的。在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型。 泛型方法的格式：[访问权限] &lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出的异常123456789public class DAO &#123; public &lt;E&gt; E get(int id, E e)&#123; E result = null; return result; &#125;&#125; 泛型和继承的关系如果B是A的一个子类型（子类或者子接口），而G是具有泛型声明的类或接口，G并不是G的子类型！ 比如：String是Object的子类，但是List并不是List的子类。 通配符 1.使用类型通配符：？比如：List&lt;?&gt; ，Map&lt;?,?&gt;List&lt;?&gt;是List、List等各种泛型List的父类。 2.读取List&lt;?&gt;的对象list中的元素时，永远是安全的，因为不管list的真实类型是什么，它包含的都是Object。 3.写入list中的元素时，不行。因为我们不知道c的元素类型，我们不能向其中添加对象。唯一的例外是null，它是所有类型的成员。 将任意元素加入到其中不是类型安全的：Collection&lt;?&gt; c = new ArrayList();c.add(new Object()); // 编译时错误因为我们不知道c的元素类型，我们不能向其中添加对象。 add方法有类型参数E作为集合的元素类型。我们传给add的任何参数都必须是一个未知类型的子类。因为我们不知道那是什么类型，所以我们无法传任何东西进去。唯一的例外的是null，它是所有类型的成员。 另一方面，我们可以调用get()方法并使用其返回值。返回值是一个未知的类型，但是我们知道，它总是一个Object 泛型应用 用户在设计类的时候往往会使用类的关联关系，例如，一个人中可以定义一个信息的属性，但是一个人可能有各种各样的信息（如联系方式、基本信息等），所以此信息属性的类型就可以通过泛型进行声明，然后只要设计相应的信息类即可。","tags":[{"name":"java学习记录","slug":"java学习记录","permalink":"http://tawen.github.io/tags/java学习记录/"}]},{"title":"java学习记录--Java异常处理","date":"2016-12-21T10:17:17.000Z","path":"2016/12/21/blog20161221-4/","text":"Java异常Error: Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。一般不编写针对性的代码进行处理。Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理 常见异常类型*Throwable * Error * AWTError、ThreadDeath * Exception * 编译(checked)异常：SQLException、IOException、ClassNotFoundException * RuntimeException：NullPointerException、ArithmeticException、ClassCastException、ArrayIndexOutOfBoundsException 异常处理机制 Java提供的是异常处理的抓抛模型。 Java程序的执行过程中如出现异常，会生成一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为抛出(throw)异常。 异常对象的生成 由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，如果在当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出——自动抛出 由开发人员手动创建：Exception exception = new ClassCastException();——创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样 如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理。如果异常没有在调用者方法中处理，它继续被抛给这个调用方法的上层方法。这个过程将一直继续下去，直到异常被处理。这一过程称为捕获(catch)异常。 如果一个异常回到main()方法，并且main()也不处理，则程序运行终止。 程序员通常只能处理Exception，而对Error无能为力。 异常处理是通过try-catch-finally语句实现的。 123456789101112try&#123; ...... //可能产生异常的代码&#125;catch( ExceptionName1 e )&#123; ...... //当产生ExceptionName1型异常时的处置措施&#125;catch( ExceptionName2 e )&#123;...... //当产生ExceptionName2型异常时的处置措施&#125; [ finally&#123;...... //无论是否发生异常，都无条件执行的语句 &#125; ] 捕获异常的有关信息：与其它对象一样，可以访问一个异常对象的成员变量或调用它的方法。getMessage() 获取异常信息，返回字符串printStackTrace() 获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。 finally 捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理。不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return，finally块中的语句都会被执行。finally语句和catch语句是任选的 声明抛出异常 声明抛出异常是Java中处理异常的第二种方式如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。 声明抛出异常举例： 123456public void readFile(String file) throws FileNotFoundException &#123; …… // 读文件的操作可能产生FileNotFoundException类型的异常 FileInputStream fis = new FileInputStream(file); ..…… &#125; 人工抛出异常 Java异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要人工创建并抛出。 首先要生成异常类对象，然后通过throw语句实现抛出操作(提交给Java运行环境)。IOException e = new IOException();throw e; 可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将会产生语法错误：throw new String(&quot;want to throw&quot;); 创建用户自定义异常类 一般地，用户自定义异常类都是RuntimeException的子类。 自定义异常类通常需要编写几个重载的构造器。 自定义的异常类对象通过throw抛出。 自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型。 用户自定义异常类MyException，用于描述数据取值范围错误信息。用户自己的异常类必须继承现有的异常类。 123456789101112class MyException extends Exception &#123; static final long serialVersionUID = 1L; private int idnumber; public MyException(String message, int id) &#123; super(message); this.idnumber = id; &#125; public int getId() &#123; return idnumber; &#125;&#125;","tags":[{"name":"java学习记录","slug":"java学习记录","permalink":"http://tawen.github.io/tags/java学习记录/"}]},{"title":"java学习记录--Java集合","date":"2016-12-21T10:17:17.000Z","path":"2016/12/21/blog20161221-5/","text":"Java集合框架Java 集合可分为 Collection 和 Map 两种体系 Collection接口： Set：元素无序、不可重复的集合 —类似高中的“集合” List：元素有序，可重复的集合 —”动态”数组 Map接口：具有映射关系“key-value对”的集合 —类似于高中的“函数” y = f(x) (x1,y1) (x2,y2)Collection接口继承树:Map接口继承树: Iterator迭代器接口遍历集合方法： 使用 Iterator 接口遍历集合元素 Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。 所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。 Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建 Iterator 对象，则必须有一个被迭代的集合。 1234Iterator iterator = coll.iterator();while(iterator.hasNext())&#123;System.out.println(iterator.next());&#125; 使用 foreach 循环遍历集合元素123for(要遍历的元素类型 遍历后元素名称:要遍历的元素名称)&#123; //执行操作&#125; Collection子接口之一：Set接口 HashSet LinkedHashSet TreeSet Set概述 Set接口是Collection的子接口，set接口没有提供额外的方法 Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。 Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals 方法 Set实现类之一：HashSet HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。 HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。 HashSet 具有以下特点： 不能保证元素的排列顺序 HashSet 不是线程安全的 集合元素可以是 null 当向 HashSet 集合中存入一个元素时，HashSet 会调用该对象的 hashCode() 方法来得到该对象的 hashCode 值，然后根据 hashCode 值决定该对象在 HashSet 中的存储位置。 HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。 hashCode() 方法 如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功。 对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。 重写 hashCode() 方法的基本原则 在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值 当两个对象的 equals() 方法比较返回 true 时，这两个对象的 hashCode() 方法的返回值也应相等 对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值 Set实现类之二：LinkedHashSet LinkedHashSet 是 HashSet 的子类 LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的。 LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。 LinkedHashSet 不允许集合元素重复。 Set实现类之三：TreeSetTreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。12345678Comparator comparator()Object first()Object last()Object lower(Object e)Object higher(Object e)SortedSet subSet(fromElement, toElement)SortedSet headSet(toElement)SortedSet tailSet(fromElement) TreeSet 两种排序方法：自然排序和定制排序。默认情况下，TreeSet 采用自然排序。 排 序——自然排序 自然排序：TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序排列 如果试图把一个对象添加到 TreeSet 时，则该对象的类必须实现 Comparable 接口。 实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。 Comparable 的典型实现： BigDecimal、BigInteger 以及所有的数值型对应的包装类：按它们对应的数值大小进行比较 Character：按字符的 unicode值来进行比较 Boolean：true 对应的包装类实例大于 false 对应的包装类实例 String：按字符串中字符的 unicode 值进行比较 Date、Time：后边的时间、日期比前面的时间、日期大 向 TreeSet 中添加元素时，只有第一个元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较。 因为只有相同类的两个实例才会比较大小，所以向 TreeSet 中添加的应该是同一个类的对象 对于 TreeSet 集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(Object obj) 方法比较返回值 当需要把一个对象放入 TreeSet 中，重写该对象对应的 equals() 方法时，应保证该方法与 compareTo(Object obj) 方法有一致的结果：如果两个对象通过 equals() 方法比较返回 true，则通过 * compareTo(Object obj) 方法比较应返回 0 排 序——定制排序 TreeSet的自然排序是根据集合元素的大小，进行元素升序排列。如果需要定制排序，比如降序排列，可通过Comparator接口的帮助。需要重写compare(T o1,T o2)方法。 利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。 要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。 此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异常。 使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。 Collection子接口之二： List接口 ArrayList LinkedList Vector List接口概述 Java中数组用来存储数据的局限性 List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。 List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。 JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。 List 集合里添加了一些根据索引来操作集合元素的方法12345678void add(int index, Object ele)boolean addAll(int index, Collection eles)Object get(int index)int indexOf(Object obj)int lastIndexOf(Object obj)Object remove(int index)Object set(int index, Object ele)List subList(int fromIndex, int toIndex) List实现类之一：ArrayList ArrayList 是 List 接口的典型实现类 本质上，ArrayList是对象引用的一个变长数组 ArrayList 是线程不安全的，而 Vector 是线程安全的，即使为保证 List 集合线程安全，也不推荐使用Vector Arrays.asList(…) 方法返回的 List 集合既不是 ArrayList 实例，也不是 Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合 List实现类之二：LinkedList对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高新增方法：123456void addFirst(Object obj)void addLast(Object obj) Object getFirst()Object getLast()Object removeFirst()Object removeLast() List 实现类之三：Vector Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。 在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。 新增方法：12345void addElement(Object obj)void insertElementAt(Object obj,int index)void setElementAt(Object obj,int index)void removeElement(Object obj)void removeAllElements() ListIterator接口（了解）List 额外提供了一个 listIterator() 方法，该方法返回一个 ListIterator 对象， ListIterator 接口继承了 Iterator 接口，提供了专门操作 List 的方法：1234567void add()boolean hasPrevious()Object previous()Boolean hasNext()Object next() Iterator和ListIterator主要区别(了解)一、ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历。但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。二、ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator 没有此功能。三、ListIterator有add()方法，可以向List中插入对象，而Iterator不能。四、都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iterator仅能遍历，不能修改。因为ListIterator的这些功能，可以实现对LinkedList等List数据结构的操作。 Map接口 HashMap TreeMap Hashtable 概述Map接口 Map与Collection并列存在。用于保存具有映射关系的数据:Key-Value Map 中的 key 和 value 都可以是任何引用类型的数据 Map 中的 key 用Set来存放，不允许重复，即同一个 Map 对象所对应的类，须重写hashCode()和equals()方法。 常用String类作为Map的“键”。 key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value。Map 常用方法 添加、删除操作： 1234Object put(Object key,Object value)Object remove(Object key)void putAll(Map t)void clear() 元视图操作的方法: 123Set keySet()Collection values()Set entrySet() 元素查询的操作： 123456Object get(Object key)boolean containsKey(Object key)boolean containsValue(Object value)int size()boolean isEmpty()boolean equals(Object obj) Map实现类之一：HashMap Map接口的常用实现类：HashMap、TreeMap和Properties。 HashMap是 Map 接口使用频率最高的实现类。 允许使用null键和null值，与HashSet一样，不保证映射的顺序。 HashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法返回 true，hashCode 值也相等。 HashMap 判断两个 value相等的标准是：两个 value 通过 equals() 方法返回 true。 Map实现类之二：LinkedHashMap LinkedHashMap 是 HashMap 的子类 与LinkedHashSet类似，LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致 Map实现类之三：TreeMap TreeMap存储 Key-Value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 Key-Value 对处于有序状态。 TreeMap 的 Key 的排序： 自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException 定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口 TreeMap判断两个key相等的标准：两个key通过compareTo()方法或者compare()方法返回0。 若使用自定义类作为TreeMap的key，所属类需要重写equals()和hashCode()方法，且equals()方法返回true时，compareTo()方法应返回0。 Map实现类之四：Hashtable Hashtable是个古老的 Map 实现类，线程安全。 与HashMap不同，Hashtable 不允许使用 null 作为 key 和 value 与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序 Hashtable判断两个key相等、两个value相等的标准，与hashMap一致。 Map实现类之五：Properties roperties 类是 Hashtable 的子类，该对象用于处理属性文件 由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型 存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法 1234Properties pros = new Properties();pros.load(new FileInputStream(&quot;jdbc.properties&quot;));String user = pros.getProperty(&quot;user&quot;);System.out.println(user); Collections工具类###操作集合的工具类：Collections Collections 是一个操作 Set、List 和 Map 等集合的工具类 Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法 排序操作：（均为static方法） reverse(List)：反转 List 中元素的顺序 shuffle(List)：对 List 集合元素进行随机排序 sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序 sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序 swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换 查找、替换 Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素 Object min(Collection) Object min(Collection，Comparator) int frequency(Collection，Object)：返回指定集合中指定元素的出现次数 void copy(List dest,List src)：将src中的内容复制到dest中 boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值 同步控制Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题 EnumerationEnumeration 接口是 Iterator 迭代器的 “古老版本” 12345Enumeration stringEnum = new StringTokenizer(&quot;a-b*c-d-e-g&quot;, &quot;-&quot;); while(stringEnum.hasMoreElements())&#123; Object obj = stringEnum.nextElement(); System.out.println(obj); &#125;","tags":[{"name":"java学习记录","slug":"java学习记录","permalink":"http://tawen.github.io/tags/java学习记录/"}]},{"title":"java学习记录--Java高级类特性二","date":"2016-12-21T09:17:17.000Z","path":"2016/12/21/blog20161221-3/","text":"关键字：static 使用范围：在Java类中，可用static修饰属性、方法、代码块、内部类 被修饰后的成员具备以下特点: 随着类的加载而加载 优先于对象存在 修饰的成员，被所有对象所共享 访问权限允许时，可不创建对象，直接被类调用 类方法(class Method) 没有对象的实例时，可以用类名.方法名()的形式访问由static标记的类方法。 在static方法内部只能访问类的static属性，不能访问类的非static属性。 因为不需要实例就可以访问static方法，因此static方法内部不能有this。(也不能有super ? YES!) 重载的方法需要同时为static的或者非static的。 理解main方法的语法由于java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public，又因为java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static的，该方法接收一个String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数。 类的成员之四：初始化块 初始化块(代码块)作用： 对Java对象进行初始化 程序的执行顺序： 1、声明成员变量的默认值 2、显式初始化、多个初始化块依次被执行（同级别下按先后顺序执行） 3、构造器再对成员进行赋值操作 关键字：final 在Java中声明类、属性和方法时，可使用关键字final来修饰,表示“最终”。 final标记的类不能被继承。提高安全性，提高程序的可读性。String类、System类、StringBuffer类 final标记的方法不能被子类重写。Object类中的getClass()。 final标记的变量(成员变量或局部变量)即称为常量。名称大写，且只能被赋值一次。 final标记的成员变量必须在声明的同时或在每个构造方法中或代码块中显式赋值，然后才能使用。 final double PI=3.14; 抽象类(abstract class) 用abstract关键字来修饰一个类时，这个类叫做抽象类； 用abstract来修饰一个方法时，该方法叫做抽象方法。 抽象方法：只有方法的声明，没有方法的实现。以分号结束：abstract int abstractMethod( int a ); 含有抽象方法的类必须被声明为抽象类。 抽象类不能被实例化。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。 不能用abstract修饰属性、私有方法、构造器、静态方法、final的方法。 更彻底的抽象：接口(interface) 有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。 接口(interface)是抽象方法和常量值的定义的集合。 从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现。 实现接口类： class SubClass implements InterfaceA{ } 一个类可以实现多个接口，接口也可以继承其它接口。 接口的特点： 用interface来定义。 接口中的所有成员变量都默认是由public static final修饰的。 接口中的所有方法都默认是由public abstract修饰的。 接口没有构造器。 接口采用多继承机制。 实现接口的类中必须提供接口中所有方法的具体实现内容，方可实例化。否则，仍为抽象类。 接口的主要用途就是被实现类实现。（面向接口编程） 与继承关系类似，接口与实现类之间存在多态性 定义Java类的语法格式：先写extends，后写implements 如果实现接口的类中没有实现接口中的全部方法，必须将此类定义为抽象类 接口也可以继承另一个接口，使用extends关键字。 工厂方法(FactoryMethod) 概述：定义一个用于创建对象的接口，让子类决定实例化哪一个类。FactoryMethod使一个类的实例化延迟到其子类。 适用性： 当一个类不知道它所必须创建的对象的类的时候 当一个类希望由它的子类来指定它所创建的对象的时候 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候 类的成员之五 在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。 Inner class一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。 Inner class的名字不能与包含它的类名相同； Inner class可以使用外部类的私有数据，因为它是外部类的成员，同一个类的成员之间可相互访问。而外部类要访问内部类中的成员需要:内部类.成员或者内部类对象.成员。 分类：成员内部类（static成员内部类和非static成员内部类）局部内部类（不谈修饰符）、匿名内部类 Inner class作为类的成员： 可以声明为final的 和外部类不同，Inner class可声明为private或protected； Inner class 可以声明为static的，但此时就不能再使用外层类的非static的成员变量；Inner class作为类： 可以声明为abstract类 ，因此可以被其它的内部类继承 【注意】非static的内部类中的成员不能声明为static的，只有在外部类或static的内部类中才可声明static成员。 匿名内部类 匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。123new 父类构造器（实参列表）|实现接口()&#123; //匿名内部类的类体部分&#125;","tags":[{"name":"java学习记录","slug":"java学习记录","permalink":"http://tawen.github.io/tags/java学习记录/"}]},{"title":"java学习记录--Java高级类特性一","date":"2016-12-21T08:17:17.000Z","path":"2016/12/21/blog20161221-2/","text":"面向对象特征之二：继承 子类继承了父类，就继承了父类的方法和属性。 在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。 在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展”。 关于继承的规则：子类不能直接访问父类中私有的(private)的成员变量和方法。 Java只支持单继承，不允许多重继承 一个子类只能有一个父类 一个父类可以派生出多个子类 方法的重写(override) 重写方法必须和被重写方法具有相同的方法名称、参数列表和返回值类型。 重写方法不能使用比被重写方法更严格的访问权限。 重写和被重写的方法须同时为static的，或同时为非static的 子类方法抛出的异常不能大于父类被重写方法的异常 关键字super在Java类中使用super来调用父类中的指定操作： super可用于访问父类中定义的属性 super可用于调用父类中定义的成员方法 super可用于在子类构造方法中调用父类的构造器注意： 尤其当子父类出现同名成员时，可以用super进行区分 super的追溯不仅限于直接父类 super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识 调用父类的构造器 子类中所有的构造器默认都会访问父类中空参数的构造器 当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的构造器，且必须放在构造器的第一行 如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错 面向对象特征之三：多态多态性，是面向对象中最重要的概念，在java中有两种体现： 方法的重载(overload)和重写(overwrite)。 对象的多态性 ——可以直接应用在抽象类和接口上。 Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。若编译时类型和运行时类型不一致，就出现多态（Polymorphism） 对象的多态 —在Java中,子类的对象可以替代父类的对象使用 一个变量只能有一种确定的数据类型 一个引用类型变量可能指向(引用)多种不同类型的对象 子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型(upcasting)。 一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法 1234Student m = new Student();m.school = “pku”; //合法,Student类有school成员变量Person e = new Student(); e.school = “pku”; //非法,Person类没有school成员变量 属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误。 正常的方法调用1234 Person e = new Person();e.getInfo();Student e = new Student(); e.getInfo(); 虚拟方法调用(多态情况下)12Person e = new Student();e.getInfo(); //调用Student类的getInfo()方法 编译时类型和运行时类型编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类的getInfo()方法。——动态绑定 前提： 需要存在继承或者实现关系 要有覆盖操作 成员方法： 编译时：要查看引用变量所属的类中是否有所调用的方法。 运行时：调用实际对象所属的类中的重写方法。 成员变量： 不具备多态性，只看引用变量所属的类。 子类继承父类 若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量 对象类型转换 (Casting ) 基本数据类型的Casting： 自动类型转换：小的数据类型可以自动转换成大的数据类型如long g=20; double d=12.0f 强制类型转换：可以把大的数据类型强制转换(casting)成小的数据类型如 float f=(float)12.0; int a=(int)1200L 对Java对象的强制类型转换称为造型 从子类到父类的类型转换可以自动进行 从父类到子类的类型转换必须通过造型(强制类型转换)实现 无继承关系的引用类型间的转换是非法的 在造型前可以使用instanceof操作符测试一个对象的类型 Object类、包装类==操作符与equals方法基本类型比较值:只要两个变量的值相等，即为true. 引用类型比较引用(是否指向同一个对象):只有指向同一个对象时，==才返回true.用“==”进行比较时，符号两边的数据类型必须兼容(可自动转换的基本数据类型除外)，否则编译出错 equals()：所有类都继承了Object，也就获得了equals()方法。还可以重写。只能比较引用类型，其作用与“==”相同,比较是否指向同一个对象。 格式:obj1.equals(obj2)特例：当用equals()方法进行比较时，对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对象； 原因：在这些类中重写了Object类的equals()方法。 toString() 方法 toString()方法在Object类中定义，其返回值是String类型，返回类名和它的引用地址。 在进行String与其它类型数据的连接操作时，自动调用toString()方法 Date now=new Date(); System.out.println(“now=”+now); 相当于System.out.println(“now=”+now.toString()); 可以根据需要在用户自定义类型中重写toString()方法 如String 类重写了toString()方法，返回字符串的值。 s1=“hello”; System.out.println(s1);//相当于System.out.println(s1.toString());基本类型数据转换为String类型时，调用了对应包装类的toString()方法int a=10; System.out.println(“a=”+a); 包装类(Wrapper) 针对八种基本定义相应的引用类型—包装类（封装类） 有了类的特点，就可以调用类中的方法。","tags":[{"name":"java学习记录","slug":"java学习记录","permalink":"http://tawen.github.io/tags/java学习记录/"}]},{"title":"java学习记录--Java面向对象编程","date":"2016-12-21T01:17:17.000Z","path":"2016/12/21/blog20161221/","text":"面向对象与面向过程 面向对象的三大特征 封装 (Encapsulation) 继承 (Inheritance) 多态 (Polymorphism) java语言的基本元素：类和对象 类(class)和对象(object)是面向对象的核心概念。 类是对一类事物描述，是抽象的、概念上的定义 对象是实际存在的该类事物的每个个体，因而也称实例(instance)。 “万事万物皆对象” 类的成员之一：属 性 在方法体外，类体内声明的变量称为成员变量。 在方法体内部声明的变量称为局部变量。 注意：二者在初始化值方面的异同: 同：都有生命周期 异：局部变量除形参外，需显式初始化 所有变量: 成员变量:实例变量（不以static修饰）/类变量（以static修饰 局部变量:形参（方法签名中定义的变量）/方法局部变量（在方法内定义）/代码块局部变量（在代码块内定义） 成员变量（属性）和局部变量的区别？ 成员变量： 成员变量定义在类中，在整个类中都可以被访问。 成员变量分为类成员变量和实例成员变量，实例变量存在于对象所在的堆内存中。 成员变量有默认初始化值。 成员变量的权限修饰符可以根据需要，选择任意一个 局部变量： 局部变量只定义在局部范围内，如：方法内，代码块内等。 局部变量存在于栈内存中。 作用的范围结束，变量空间会自动释放。 局部变量没有默认初始化值，每次必须显式初始化。 局部变量声明时不指定权限修饰符。 类的成员之二：方 法什么是方法（函数）？方法是类或对象行为特征的抽象，也称为函数。Java里的方法不能独立存在，所有的方法必须定义在类里。 对象的创建和使用类的访问机制：在一个类中的访问机制：类中的方法可以直接访问类中的成员变量。（例外：static方法访问非static，编译不通过。） 在不同类中的访问机制：先创建要访问类的对象，再用对象访问类中定义的成员 方法的重载(overload) 重载的概念:在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。重载的特点：与返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。 可变个数的形参 1234//下面采用数组形参来定义方法public static void test(int a ,String[] books);//以可变个数形参来定义方法public static void test(int a ,String…books); 1.可变参数：方法参数部分指定类型的参数个数是可变多个2.声明方式：方法名（参数的类型名…参数名）3.可变参数方法的使用与方法参数部分使用数组是一致的4.方法的参数部分有可变形参，需要放在形参声明的最后 Java的实参值如何传入方法呢？ Java里方法的参数传递方式只有一种：值传递。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响。 面向对象特征之一：封装和隐藏使用者对类内部定义的属性(对象的成员变量)的直接操作会导致数据的错误、混乱或安全性问题。 Java中通过将数据声明为私有的(private)，再提供公共的（public）方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的： 隐藏一个类中不需要对外提供的实现细节； 使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作； 便于修改，增强代码的可维护性 类的成员之三：构造器（构造方法）构造器的特征 它具有与类相同的名称 它不声明返回值类型。（与声明为void不同） 不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值 根据参数不同，构造器可以分为如下两类：隐式无参构造器（系统默认提供）显式定义一个或多个构造器（无参、有参） 注 意： Java语言中，每个类都至少有一个构造器 默认构造器的修饰符与所属类的修饰符一致 一旦显式定义了构造器，则系统不再提供默认构造器 一个类可以创建多个重载的构造器 父类的构造器不可被子类继承 几个关键字：this、package、importthis 在java中，this关键字比较难理解，它的作用和其词义很接近。 它在方法内部使用，即这个方法所属对象的引用； 它在构造器内部使用，表示该构造器正在初始化的对象。 this表示当前对象，可以调用类的属性、方法和构造器 什么时候使用this关键字呢？ 当在方法内需要用到调用该方法的对象时，就用this。 注意： 1.使用this()必须放在构造器的首行！ 2.使用this调用本类中其他的构造器，保证至少有一个构造器是不用this的。 关键字—package package语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包。(若缺省该语句，则指定为无名包)。它的格式为： package 顶层包名.子包名 ; 1234567pack\\Test.javapackage p1; //指定类Test属于包p1public class Test&#123; public void display()&#123; System.out.println(&quot;in method display()&quot;); &#125;&#125; 包对应于文件系统的目录，package语句中，用 “.” 来指明包(目录)的层次； 包通常用小写单词，类名首字母通常大写。 关键字—import 为使用定义在不同包中的Java类，需用import语句来引入指定包层次下所需要的类或全部类(.*)。import语句告诉编译器到哪里去寻找类。 语法格式： import 包名[.子包名…]. &lt;类名 |*&gt; 应用举例：1234567import p1.Test; //import p1.*;表示引入p1包中的所有类public class TestPackage&#123; public static void main(String args[])&#123; Test t = new Test(); //Test类在p1包中定义 t.display(); &#125; &#125; 注意： 若引入的包为：java.lang，则编译器默认可获取此包下的类，不需要再显示声明。 import语句出现在package语句之后、类定义之前 一个源文件中可包含多个import语句 可以使用import lee. ;语句，表明导入lee包下的所有类。而lee包下sub子包内的类则不会被导入。import lee.sub.; import语句不是必需的，可坚持在类里使用其它类的全名 JDK 1.5加入import static语句 JavaBean是一种Java语言写成的可重用组件。 所谓javaBean，是指符合如下标准的Java类： 类是公共的 有一个无参的公共的构造器 有属性，且有对应的get、set方法 用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使*用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变","tags":[{"name":"java学习记录","slug":"java学习记录","permalink":"http://tawen.github.io/tags/java学习记录/"}]},{"title":"java学习记录--Java基本语法","date":"2016-12-20T08:17:17.000Z","path":"2016/12/20/blog20161220-3/","text":"关键字 关键字的定义和特点 定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词） 特点：关键字中所有字母都为小写 用于定义数据类型的关键字: class/interface/enum/byte/short/int/long/float/double/char/boolean/void 用于定义数据类型值的关键字: true/false/null 用于定义流程控制的关键字: if/else/switch/case/defeault/while/do/for/break/continue/return 用于定义访问权限修饰符的关键字: private/protected/public 用于定义类，函数，变量修饰符的关键字: abstract/final/static/synchronized 用于定义类与类之间关系的关键字 :extends/implements 用于定义建立实例及引用实例，判断实例的关键字: new/this/super/instanceof 用于异常处理的关键字: try/catch/finally/throw/throws 用于包的关键字: package/import 其他修饰符关键字: native/strictfp/transient/volatile/assert 保留字Java保留字：现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标记符时要避免使用这些保留字 byValue、cast、future、 generic、 inner、 operator、 outer、 rest、 var 、 goto 、const 标识符 标识符： Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符 凡是自己可以起名字的地方都叫标识符。 定义合法标识符规则： 由26个英文字母大小写，0-9 ，_或 $ 组成 数字不可以开头。 不可以使用关键字和保留字，但能包含关键字和保留字。 Java中严格区分大小写，长度无限制。 标识符不能包含空格。 Java中的名称命名规范： 包名：多单词组成时所有字母都小写：xxxyyyzzz 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ 注意：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。 变 量 变量的概念： 内存中的一个存储区域 该区域有自己的名称（变量名）和类型（数据类型） Java中每个变量必须先声明，后使用 该区域的数据可以在同一类型范围内不断变化 使用变量注意： 变量的作用域：一对{ }之间有效 初始化值 定义变量的格式：数据类型 变量名 = 初始化值 变量是通过使用变量名来访问这块区域的 （补充）程序的执行过程 变量的分类-按数据类型对于每一种数据都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间。 补充：变量的分类-按声明的位置的不同 在方法体外，类体内声明的变量称为成员变量。 在方法体内部声明的变量称为局部变量。 注意：二者在初始化值方面的异同:同：都有生命周期 异：局部变量除形参外，需显式初始化。 整数类型：byte、short、int、longJava各整数类型有固定的表数范围和字段长度，不受具体OS的影响，以保证java程序的可移植性。java的整型常量默认为 int 型，声明long型常量须后加‘l’或‘L’ 浮点类型：float、double 与整数类型类似，Java 浮点类型也有固定的表数范围和字段长度，不受具体OS的影响。 Java 的浮点型常量默认为double型，声明float型常量，须后加‘f’或‘F’。 浮点型常量有两种表示形式： 十进制数形式：如：5.12 512.0f .512 (必须有小数点） 科学计数法形式:如：5.12e2 512E2 100E-2 字符类型：char char 型数据用来表示通常意义上“字符”(2字节) 字符型常量的三种表现形式： 字符常量是用单引号(‘ ’)括起来的单个字符，涵盖世界上所有书面语的字符。例如：char c1 = ‘a’; char c2 = ‘中’; char c3 = ‘9’; Java中还允许使用转义字符‘\\’来将其后的字符转变为特殊字符型常量。例如：char c3 = ‘\\n’; // ‘\\n’表示换行符*直接使用 Unicode 值来表示字符型常量：‘\\uXXXX’。其中，XXXX代表一个十六进制整数。如：\\u000a 表示 \\n。 char类型是可以进行运算的。因为它都对应有Unicode码。 Unicode 编码 乱码：世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。 Unicode：一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，使用 Unicode 没有乱码的问题。Unicode 的缺点：Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储：无法区别 Unicode 和 ASCII：计算机无法区分三个字节表示一个符号还是分别表示三个符号 UTF-8 UTF-8 是在互联网上使用最广的一种 Unicode 的实现方式。 UTF-8 是一种变长的编码方式。它可以使用 1-6 个字节表示一个符号，根据不同的符号而变化字节长度。 UTF-8的编码规则： 对于单字节的UTF-8编码，该字节的最高位为0，其余7位用来对字符进行编码（等同于ASCII码）。 对于多字节的UTF-8编码，如果编码包含 n 个字节，那么第一个字节的前 n 位为1，第一个字节的第 n+1 位为0，该字节的剩余各位用来对字符进行编码。在第一个字节之后的所有的字节，都是最高两位为”10”，其余6位用来对字符进行编码。 布尔类型：boolean boolean 类型适于逻辑运算，一般用于程序流程控制： if条件控制语句； while循环控制语句； do-while循环控制语句； for循环控制语句； boolean类型数据只允许取值true和false，无null。 不可以0或非 0 的整数替代false和true，这点和C语言不同。 基本数据类型转换 自动类型转换：容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为： 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。 当把任何基本类型的值和字符串值进行连接运算时(+)，基本类型的值将自动转化为字符串类型。 强制类型转换 自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符（()），但可能造成精度降低或溢出,格外要注意。 通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。 如： String a = “43”; int i = Integer.parseInt(a); boolean类型不可以转换为其它的数据类型。 String类 值null可以赋值给任何引用类型（类、接口、数组）的变量，用以表示这个引用类型变量中保存的地址为空。 String类属于引用类型，可用null赋值。 String类是一个典型的不可变类，String对象创建出来就不可能被改变。创建出的字符串将存放在数据区，保证每个字符串常量只有一个，不会产生多个副本。 12345String s0 = “hello”;String s1 = “hello”;String s2 = “he” + “llo”;System.out.println(s0 ==s1);System.out.println(s0 ==s2); 进 制 二进制：0,1 ，满2进1.以0b或0B开头。 十进制：0-9 ，满10进1. 八进制：0-7 ，满8进1. 以数字0开头表示。 十六进制：0-9及A-F，满16进1. 以0x或0X开头表示。此处的A-F不区分大小写。 原码、反码、补码 所有数字在计算机底层都以二进制形式存在。 计算机以补码的形式保存所有的整数。 正数的原码、反码、补码都相同 负数的补码是其反码加1。 原码：直接将一个数值换成二进制数。 反码：是对原码按位取反，只是最高位（符号位）确定为1。 Java整数常量默认是int类型，当用二进制定义整数时，其第32位是符号位；当是long类型时，二进制默认占64位，第64位是符号位 运算符运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。 如果对负数取模，可以把模数负号忽略不记，如：5%-2=1。 但被模数是负数则不可忽略。此外，取模运算的结果不一定总是整数。 对于除号“/”，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。 例如：int x=3510;x=x/1000*1000; x的结果是？ “+”除字符串相加功能外，还能把非字符串转换成字符串.例如：System.out.println(“5+5=”+5+5); //打印结果是？ 以下二者的区别：System.out.println(‘‘ + ‘\\t’ +’‘);System.out.println(““ + ‘\\t’ +’‘); 算术运算符 符号：= 当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理。 支持连续赋值。 扩展赋值运算符： +=, -=, *=, /=, %= 赋值运算符比较运算符（关系运算符）逻辑运算符 逻辑运算符用于连接布尔型表达式，在Java中不可以写成3&lt;x&lt;6，应该写成x&gt;3 &amp; x&lt;6 。 “&amp;”和“&amp;&amp;”的区别： 单&amp;时，左边无论真假，右边都进行运算； 双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。 “|”和“||”的区别同理，||表示：当左边为真，右边不参与运算。 异或( ^ )与或( | )的不同之处是：当左右都为true时，结果为false。 理解：异或，追求的是“异”! 位运算符三元运算符程序流程控制 顺序结构程序从上到下逐行地执行，中间没有任何判断和跳转。 分支结构根据条件，选择性地执行某段代码。有if…else和switch两种分支语句。 循环结构根据循环条件，重复性的执行某段代码。有while、do…while、for三种循环语句。注：JDK1.5提供了foreach循环，方便的遍历集合、数组元素。","tags":[{"name":"java学习记录","slug":"java学习记录","permalink":"http://tawen.github.io/tags/java学习记录/"}]},{"title":"java学习记录--Java语言概述","date":"2016-12-20T03:17:17.000Z","path":"2016/12/20/blog20161220-2/","text":"常用的DOS命令 dir : 列出当前目录下的文件以及文件夹 md/mkdir : 创建目录 rd/rmdir : 删除目录 cd : 进入指定目录 cd.. : 退回到上一级目录 cd\\: 退回到根目录 del : 删除文件 exit : 退出 dos 命令行 echo : 新建文件 第三代语言:Java跨平台的纯面向对象的语言 Java技术体系平台 Java SE(Java Standard Edition)标准版 支持面向桌面级应用（如Windows下的应用程序）的Java平台，提供了完整的Java核心API，此版本以前称为J2SE Java EE(Java Enterprise Edition)企业版 是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如:Servlet 、Jsp等，主要针对于Web应用程序开发。版本以前称为J2EE Java ME(Java Micro Edition)小型版 支持Java程序运行在移动终端（手机、PDA）上的平台，对Java API有所精简，并加入了针对移动终端的支持，此版本以前称为J2ME Java Card 支持一些Java小程序（Applets）运行在小内存设备（如智能卡）上的平台 Java语言的特点 特点一：面向对象两个基本概念：类、对象三大特性：封装、继承、多态 特点二：健壮性吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制 特点三：跨平台性跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere”原理：只要在需要运行 java 应用程序的操作系统上，先安装一个Java虚拟机 (JVM Java Virtual Machine) 即可。由JVM来负责Java程序在该系统中的运行。 Java两种核心机制 Java虚拟机（Java Virtal Machine） JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。 对于不同的平台，有不同的虚拟机。 Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”。 垃圾收集机制（Garbage Collection） 不再使用的内存空间应回收—— 垃圾回收。 在C/C++等语言中，由程序员负责回收无用内存。 Java 语言消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间。 垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。 Java语言的环境搭建什么是JDK，JRE JDK(Java Development Kit Java开发工具包)JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。其中的开发工具：编译工具(javac.exe) 打包工具(jar.exe)等 JRE(Java Runtime Environment Java运行环境)包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。 简单而言，使用JDK的开发工具完成的java程序，交给JRE去运行。 JVM、JRE、JDK 关系","tags":[{"name":"java学习记录","slug":"java学习记录","permalink":"http://tawen.github.io/tags/java学习记录/"}]},{"title":"JavaScript 之arguments、caller 和 callee 介绍","date":"2016-12-20T02:43:35.000Z","path":"2016/12/20/blog20161220/","text":"1.前言arguments, caller , callee 是什么？在javascript 中有什么样的作用？本篇会对于此做一些基本介绍。 2. argumentsarguments: 在函数调用时， 会自动在该函数内部生成一个名为 arguments的隐藏对象。 该对象类似于数组， 但又不是数组。可以使用[]操作符获取函数调用时传递的实参。123456789101112function testArg() &#123; alert(&quot;real parameter count: &quot;+arguments.length); for(var i = 0; i &lt; arguments.length; i++) &#123; alert(arguments[i]); &#125; &#125; testArg(11); //count: 1 testArg(&apos;hello&apos;,&apos;world&apos;); // count: 2 看上去很简单。 需要注意的是 argument 保存的实参的信息。 上面有说， arguments 不是一个数组，何以见得？ 执行以下部分就可以知道了1234(function () &#123; alert(arguments instanceof Array); // false alert(typeof(arguments)); // object &#125;)(); 对于以上立即执行函数写法不清楚的话， 可以参考http://blog.csdn.net/oscar999/article/details/8507919 只有函数被调用时，arguments对象才会创建，未调用时其值为null：1alert(new Function().arguments);//return null arguments 的完整语法如下：[function.]arguments[n]参数function ：选项。当前正在执行的 Function 对象的名字。 n ：选项。要传递给 Function 对象的从0开始的参数值索引。 3. caller在一个函数调用另一个函数时，被调用函数会自动生成一个caller属性，指向调用它的函数对象。如果该函数当前未被调用，或并非被其他函数调用，则caller为null。 12345678910function testCaller() &#123; var caller = testCaller.caller; alert(caller); &#125; function aCaller() &#123; testCaller(); &#125; aCaller(); 4. callee当函数被调用时，它的arguments.callee对象就会指向自身，也就是一个对自己的引用。由于arguments在函数被调用时才有效，因此arguments.callee在函数未调用时是不存在的（即null.callee），且解引用它会产生异常。1234567function aCallee(arg) &#123; alert(arguments.callee); &#125; function aCaller(arg1, arg2) &#123;aCallee();&#125; aCaller();","tags":[{"name":"js","slug":"js","permalink":"http://tawen.github.io/tags/js/"}]},{"title":"一些网站收集，做个整理","date":"2016-12-19T08:38:37.000Z","path":"2016/12/19/blog20161219-2/","text":"网站收集 这些年的一些网站收集，这是对前端js学习以及设计网站的收藏 前端学习 张孝祥JavaScript 笔记 大漠的W3CPlus JavaScript 标准库 米空格的作品 jquery.easing缓动函数速查表 jQuery源码分析系列 – 艾伦 Aaron 迷你版jQuery——zepto核心源码分析 叶小钗 网页设计福利！30款超实用的JQUERY插件大合集 逐行分析jQuery源码的奥秘 jQuery UI API中文文档 深入理解javascript原型和闭包系列–王福朋 CSS lesscss w3cplus-sass w3cplus-css3 前端框架 KISSUI Bootstrap 百度的图表控件 JS小插件 Poshy Tip 一个可以随意配置的banner效果-jcarousellite 高逼格banner效果 一个回到顶部的炫酷插件 一个延迟加载的插件 一个很不错的js插件网站–jq22 HTML5优秀图表控件 UI素材网站 黄蜂网 花瓣网 优设 视觉中国 UImaker 68Design 设计路上 UI设计 设计之家 懒人图库 昵图网 火星时代 创意酷站营 飞特网 怪兽模板 一个设计大牛的blog 全球WEB设计师名站目录 DESIGNER LIST 怒赞！7个下载UI组件包的顶级网站 一个可爱小弟的个人网站-翁天信 16素材网 苏打苏塔设计量贩铺 模板库 17素材网 高清壁纸–wallhaven 方酷 MobileUI莫贝网 千图网 365PSD UI中国-专业界面交互设计平台 dribbble ui-cloud 致设计 graphberry 深圳网站建设,网站建设,深圳网站设计,深圳网站制作-沙漠风网站建设公司 设计工具 破洛洛 PS联盟 Photoshop图案,PS图案 - 思缘教程网 圆环配色 国外图标网站-findicons 国外图标网站-flaticon 国内图标网站-iconpng ICO图标制作 免费字体图标网站-glyphicons 免费字体图标网站-fontello 免费字体图标网站-icomoon 识别字体网站 25个强大的PS炫光特效教程 一网打尽！200+值得收藏的设计师资源站 PS秘籍帖！不得不看的百位设计师分享的PS技巧 开工福利！300+值得收藏的设计师资源站 WEBAPP百度的GMU、Zepto、iScroll、zTouch、腾讯的FrozenUI、阿里的SUI WEBSITEjquery easyui、 前端工具Gulp、Grunt、Webpack、git - 简易指南、js在线美化工具","tags":[]},{"title":"修改git commit 最后一次提交的注释信息 以及如何退出git bash vim编辑器","date":"2016-12-19T02:24:09.000Z","path":"2016/12/19/blog20161219/","text":"今天用git commit -m “注释”提交的时候，注释写错了，于是各种查资料开始了和git bash vim的纠缠。。。（网上的资料我真是没操作成功，不过最后还是摸索出来了） 首先 使用 git commit –amend/git commit -v 命令，（修改最近一次提交的注释信息），会进入到vim 编辑器 然后 你会发现编辑器里你怎么输入都没反应，这是因为vim处在不可编辑状态，按下字母键 c，此时进入编辑状态，可以开始修改注释信息了 在然后 你会发现你怎么都退出不了，回到shell了，然后操作如下： ESC –》 退出编辑状态；接着 连续按两次大写字母键 Z，接着你会惊喜的发现，终于保存好退出来了！ windows 系统 ，亲测有效！！拿走不谢！","tags":[{"name":"git","slug":"git","permalink":"http://tawen.github.io/tags/git/"}]},{"title":"Git远程操作详解","date":"2016-12-16T03:14:52.000Z","path":"2016/12/16/blog20161216/","text":"Git是目前最流行的版本管理系统，学会Git几乎成了开发者的必备技能。Git有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。 git clone git remote git fetch git pull git push 本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。 一、git clone远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。1$ git clone &lt;版本库的网址&gt; 比如，克隆jQuery的版本库。1$ git clone https://github.com/jquery/jquery.git 该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。1$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt; git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。1234567$ git clone http[s]://example.com/path/to/repo.git/$ git clone ssh://example.com/path/to/repo.git/$ git clone git://example.com/path/to/repo.git/$ git clone /opt/git/project.git $ git clone file:///opt/git/project.git$ git clone ftp[s]://example.com/path/to/repo.git/$ git clone rsync://example.com/path/to/repo.git/ SSH协议还有另一种写法。1$ git clone [user@]example.com:path/to/repo.git/ 通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。 二、git remote为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。不带选项的时候，git remote命令列出所有远程主机。12$ git remoteorigin 使用-v选项，可以参看远程主机的网址。 123$ git remote -vorigin git@github.com:jquery/jquery.git (fetch)origin git@github.com:jquery/jquery.git (push) 上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。123$ git clone -o jQuery https://github.com/jquery/jquery.git$ git remotejQuery 上面命令表示，克隆的时候，指定远程主机叫做jQuery。git remote show命令加上主机名，可以查看该主机的详细信息。1$ git remote show &lt;主机名&gt; git remote add命令用于添加远程主机。1$ git remote add &lt;主机名&gt; &lt;网址&gt; git remote rm命令用于删除远程主机。1$ git remote rm &lt;主机名&gt; git remote rename命令用于远程主机的改名。1$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt; 三、git fetch一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。1$ git fetch &lt;远程主机名&gt; 上面命令将某个远程主机的更新，全部取回本地。git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。1$ git fetch &lt;远程主机名&gt; &lt;分支名&gt; 比如，取回origin主机的master分支。1$ git fetch origin master 所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。12$ git branch -rorigin/master 123$ git branch -a* master remotes/origin/master 上面命令表示，本地主机的当前分支是master，远程分支是origin/master。取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。1$ git checkout -b newBrach origin/master 上面命令表示，在origin/master的基础上，创建一个新分支。此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。1$ git merge origin/master 或者1$ git rebase origin/master 上面命令表示在当前分支上，合并origin/master。 四、git pullgit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。1$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。1$ git pull origin next:master 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。1$ git pull origin next 上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。12$ git fetch origin$ git merge origin/next 在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。Git也允许手动建立追踪关系。1git branch --set-upstream master origin/next 上面命令指定master分支追踪origin/next分支。如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。1$ git pull origin 上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。如果当前分支只有一个追踪分支，连远程主机名都可以省略。1$ git pull 上面命令表示，当前分支自动与唯一一个追踪分支进行合并。如果合并需要采用rebase模式，可以使用–rebase选项。1$ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。1$ git pull -p 等同于下面的命令12$ git fetch --prune origin $ git fetch -p 五、git pushgit push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。1$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。1$ git push origin master 上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。1$ git push origin :master 等同于1$ git push origin --delete master 上面命令表示删除origin主机的master分支。如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。1$ git push origin 上面命令表示，将当前分支推送到origin主机的对应分支。如果当前分支只有一个追踪分支，那么主机名都可以省略。1$ git push 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。1$ git push -u origin master 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。1$ git config --global push.default matching 或者1$ git config --global push.default simple 还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。1$ git push --all origin 上面命令表示，将所有本地分支都推送到origin主机。如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。1$ git push --force origin 上面命令使用–force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用–force选项。最后，git push不会推送标签（tag），除非使用–tags选项。1$ git push origin --tags","tags":[{"name":"git","slug":"git","permalink":"http://tawen.github.io/tags/git/"}]},{"title":"iScroll5 API速查随记","date":"2016-12-15T02:22:29.000Z","path":"2016/12/15/blog20151215/","text":"版本针对iScroll的优化。为了达到更高的性能，iScroll分为了多个版本。你可以选择最适合你的版本。目前我们有以下版本： iscroll.js，这个版本是常规应用的脚本。它包含大多数常用的功能，有很高的性能和很小的体积。 iscroll-lite.js，精简版本。它不支持快速跳跃，滚动条，鼠标滚轮，快捷键绑定。但如果你所需要的是滚动(特别是在移动平台) iScroll 精简版 是又小又快的解决方案。 iscroll-probe.js，探查当前滚动位置是一个要求很高的任务,这就是为什么我决定建立一个专门的版本。如果你需要知道滚动位置在任何给定的时间,这是iScroll给你的。（我正在做更多的测试,这可能最终在常规iscroll.js脚本，请留意）。 iscroll-zoom.js，在标准滚动功能上增加缩放功能。 iscroll-infinite.js，可以做无限缓存的滚动。处理很长的列表的元素为移动设备并非易事。 iScroll infinite版本使用缓存机制,允许你滚动一个潜在的无限数量的元素。 入门IScroll是一个类，每个需要使用滚动功能的区域均要进行初始化。每个页面上的iScroll实例数目在设备的CPU和内存能承受的范围内是没有限制的。 尽可能保持DOM结构的简洁。iScroll使用硬件合成层但是有一个限制硬件可以处理的元素。最佳的HTML结构如下：1234567&lt;div id=&quot;wrapper&quot;&gt; &lt;ul&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; ... &lt;/ul&gt;&lt;/div&gt; iScroll作用于滚动区域的外层。在上面的例子中，UL元素能进行滚动。只有容器元素的第一个子元素能进行滚动，其他子元素完全被忽略。 最基本的脚本初始化的方式如下：123&lt;script type=&quot;text/javascript&quot;&gt; var myScroll = new IScroll(&apos;#wrapper&apos;);&lt;/script&gt; 第一个参数可以是滚动容器元素的DOM选择器字符串，也可以是滚动容器元素的引用对象。下面是一个有效的语法：12var wrapper = document.getElementById(&apos;wrapper&apos;);var myScroll = new IScroll(wrapper); 所以基本上你要么直接传递元素，要么传递一个querySelector字符串。因此可以使用css名称代替ID去选择一个滚动器容器,如下:12var myScroll = new IScroll(&apos;.wrapper&apos;);` 注意，iScroll使用的是querySelector 而不是 querySelectorAll，所以iScroll只会作用到选择器选中元素的第一个。如果你需要对多个对象使用iScroll，你需要构建自己的循环机制。 初始化当DOM准备完成后iScroll需要被初始化。最保险的方式是在window的onload事件中启动它。在DOMContentLoaded事件中或者inline initialization中做也可以，需要记住的是脚本需要知道滚动区域的高度和宽度。如果你有一些图片在滚动区域导致不能立马获取区域的高度和宽度，iScroll的滚动尺寸有可能会错误。 为滚动起容器增加position:relative或者absolute样式。这将解决大多数滚动器容器大小计算不正确的问题。综上所述，最小的iScroll配置如下：1234567891011121314151617181920&lt;head&gt; ... &lt;script type=&quot;text/javascript&quot; src=&quot;iscroll.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var myScroll; function loaded() &#123; myScroll = new IScroll(&apos;#wrapper&apos;); &#125; &lt;/script&gt; &lt;/head&gt; ... &lt;body onload=&quot;loaded()&quot;&gt; &lt;div id=&quot;wrapper&quot;&gt; &lt;ul&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; ... &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; 如果你有一个复杂的DOM结构，最好在onload事件之后适当的延迟，再去初始化iScroll。最好给浏览器100或者200毫秒的间隙再去初始化iScroll。 配置在iScroll初始化阶段可以通过构造函数的第二个参数配置它。1234var myScroll = new IScroll(&apos;#wrapper&apos;, &#123; mouseWheel: true, scrollbars: true&#125;); 上面的例子示例了在iScroll初始化时开启鼠标滚轮支持和滚动条支持。 在初始化后你可以通过options对象访问标准化值。例如： js console.dir(myScroll.options);上面的语句将返回myScroll实例的配置信息。所谓的标准化意味着如果你设置useTransform:true，但是浏览器并不支持CSStransforms，那么useTransform属性值将为false。 理解核心iScroll使用基于设备和浏览器性能的各种技术来进行滚动。通常不需要你来配置引擎，iScroll会为你选择最佳的方式。 尽管如此，理解iScroll工作机制和了解如何去配置他们也是很重要的。1options.useTransform 默认情况下引擎会使用CSStransform属性。如果现在还是2007年，那么可以设置这个属性为false，这就是说：引擎将使用top/left属性来进行滚动。这个属性在滚动器感知到Flash，iframe或者视频插件内容时会有用，但是需要注意：性能会有极大的损耗。默认值：true1options.useTransition iScroll使用CSS transition来实现动画效果（动量和弹力）。如果设置为false，那么将使用requestAnimationFrame代替。在现在浏览器中这两者之间的差异并不明显。在老的设备上transitions执行得更好。默认值：true1options.HWCompositing 这个选项尝试使用translateZ(0)来把滚动器附加到硬件层，以此来改变CSS属性。在移动设备上这将提高性能，但在有些情况下,你可能想要禁用它(特别是如果你有太多的元素和硬件性能跟不上)。默认值：true 如果不确定iScroll的最优配置。从性能角度出发，上面的所有选项应该设置为true。（或者更好的方式，让他们自动设置属性为true）。你可以尝试这配置他们，但是要小心内存泄漏。 基本功能options.bounce当滚动器到达容器边界时他将执行一个小反弹动画。在老的或者性能低的设备上禁用反弹对实现平滑的滚动有帮助。默认值：true options.click为了重写原生滚动条，iScroll禁止了一些默认的浏览器行为，比如鼠标的点击。如果你想你的应用程序响应click事件，那么该设置次属性为true。请注意，建议使用自定义的tap 事件来代替它（见下面）。默认属性：false options.disableMouse options.disablePointer options.disableTouch默认情况下，iScroll监听所有的指针事件，并且对这些事件中第一个被触发的做出反应。这看上去是浪费资源，但是在大量的浏览器/设备上兼容，特定的事件侦测证明是无效的，所以listen-to-all是一个安全的做法。 如果你有一种设备侦测的内部机制，或者你知道你的脚本将在什么地方运行，你可以把你不需要的事件禁用（鼠标，指针或者触摸事件）。下面的例子是禁用鼠标和指针事件：1234var myScroll = new IScroll(&apos;#wrapper&apos;, &#123; disableMouse: true, disablePointer: true&#125;); 默认值：false options.eventPassthrough有些时候你想保留原生纵向的滚动条但想为横向滚动条增加iScroll功能（比如走马灯）。设置这个属性为true并且iScroll区域只将影响横向滚动，纵向滚动将滚动整个页面。 在移动设备上访问event passthrough demo。注意，这个值也可以设置为horizontal，其作用和上面介绍的相反（横向滚动条保持原生，纵向滚动条使用iScroll）。 options.freeScroll此属性针对于两个两个纬度的滚动条（当你需要横向和纵向滚动条）。通常情况下你开始滚动一个方向上的滚动条，另外一个方向上会被锁定不动。有些时候，你需要无约束的移动（横向和纵向可以同时响应），在这样的情况下此属性需要设置为true。请参考 2D scroll demo。默认值：false options.keyBindings此属性为true时激活键盘（和远程控制）绑定。请参考下面的Key bindings内容。默认值：false options.invertWheelDirection当鼠标滚轮支持激活后，在有些情况下需要反转滚动的方向。（比如，鼠标滚轮向下滚动条向上，反之亦然）。默认值：false options.momentum在用户快速触摸屏幕时，你可以开/关势能动画。关闭此功能将大幅度提升性能。默认值：true options.mouseWheel侦听鼠标滚轮事件。默认值：false options.preventDefault当事件触发时师傅执行preventDefault()。此属性应该设置为true，除非你真的知道你需要怎么做。请参考下面的Advanced features中的preventDefaultException，可以获取更多控制preventDefault行为的信息。默认值：true options.scrollbars是否显示为默认的滚动条。更多信息请查看Scrollbar默认值：false options.scrollX options.scrollY默认情况下只有纵向滚动条可以使用。如果你需要使用横向滚动条，需要将scrollX 属性值设置为 true。请参考示例horizontal demo。 也可以参考freeScroll选项。 默认值：scrollX: false，scrollY: true 注意属性 scrollX/Y: true 与overflow: auto有相同的效果。设置一个方向上的值为 false 可以节省一些检测的时间和CPU的计算周期。 options.startX options.startY默认情况下iScroll从0, 0 (top left)位置开始，通过此属性可以让滚动条从不同的位置开始滚动。默认值：0 options.tap设置此属性为true，当滚动区域被点击或者触摸但并没有滚动时，可以让iScroll抛出一个自定义的tap事件。这是处理与可以点击元素之间的用户交互的建议方式。侦听tap事件和侦听标准事件的方式一致。示例如下：12element.addEventListener(&apos;tap&apos;, doSomething, false); \\\\ Native$(&apos;#element&apos;).on(&apos;tap&apos;, doSomething); \\\\ jQuery 你可以通过传递一个字符串来自定义事件名称。比如： tap: ‘myCustomTapEvent’在这个示例里你应该侦听名为myCustomTapEvent的事件。默认值：false 滚动条滚动条不只是像名字所表达的意义一样，在内部它们是作为indicators的引用。 一个指示器侦听滚动条的位置并且现实它在全局中的位置，但是它可以做更多的事情。先从最基本的开始。 options.scrollbars正如我们在基本功能介绍中提到的，激活滚动条只需要做一件事情，这件事情就是：123var myScroll = new IScroll(&apos;#wrapper&apos;, &#123; scrollbars: true&#125;); 当然这个默认的行为是可以定制的。 options.fadeScrollbars不想使用滚动条淡入淡出方式时，需要设置此属性为false以便节省资源。默认值：false options.interactiveScrollbars此属性可以让滚动条能拖动，用户可以与之交互。默认值：false options.resizeScrollbars滚动条尺寸改变基于容器和滚动区域的宽/高之间的比例。此属性设置为false让滚动条固定大小。这可能有助于自定义滚动条样式（参考下面的滚动条样式）。默认值：true options.shrinkScrollbars当在滚动区域外面滚动时滚动条是否可以收缩到较小的尺寸。有效的值为：clip 和 scale。clip是移动指示器到它容器的外面，效果就是滚动条收缩起来，简单的移动到屏幕以外的区域。属性设置为此值后将大大的提升整个iScroll的性能。scale是关闭属性useTransition，之后所有的动画效果将使用requestAnimationFrame实现。指示器实际上有各种尺寸，并且最终的效果最好。默认值：false 注意改变大小不是在GPU上执行的，所以’scale’ 是在CPU上执行。 请参考 滚动条示例。 滚动条样式如果你不喜欢默认的滚动条样式，而且你认为你可以做的更好，你可以自定义滚动条样式。第一步就是设置选项scrollbars的值为custom： var myScroll = new IScroll(‘#wrapper’, { scrollbars: ‘custom’});使用下面的CSS类可以简单的改变滚动条样式。 .iScrollHorizontalScrollbar，这个样式应用到横向滚动条的容器。这个元素实际上承载了滚动条指示器。.iScrollVerticalScrollbar，和上面的样式类似，只不过适用于纵向滚动条容器。.iScrollIndicator，真正的滚动条指示器。.iScrollBothScrollbars，这个样式将在双向滚动条显示的情况下被加载到容器元素上。通常情况下其中一个（横向或者纵向）是可见的自定义滚动条样式示例。 如果你设置resizeScrollbars: false，滚动条将是固定大小，否则它将基于滚动区域的尺寸变化。 指示上面所有关于滚动条的选项实际上是包装了一个底层的选项indicators。它看起来或多或少像这样：123456789101112131415var myScroll = new IScroll(&apos;#wrapper&apos;, &#123; indicators: &#123; el: [element|element selector] fade: false, ignoreBoundaries: false, interactive: false, listenX: true, listenY: true, resize: true, shrink: false, speedRatioX: 0, speedRatioY: 0, &#125;&#125;);options.indicators.el 这是一个强制性的参数，它保留了指向滚动条容器元素的引用。容器里的第一个子元素就是指示器。有效的语法如下：123indicators: &#123; el: document.getElementById(&apos;indicator&apos;)&#125; 更简单的方式：123indicators: &#123; el: &apos;#indicator&apos;&#125; 注意，滚动条可以在你的文档的任意地方，它不需要在滚动条包装器内。 options.indicators.ignoreBoundaries这个属性是告诉指示器忽略它容器所带来的边界。当我们能改变滚动条速度的比率，在让滚动条滚动时这个属性很有用。比如你想让指示器是滚动条速度的两倍，指示器将很快到达它的结尾。这个属性被用在视差滚动。默认值：false options.indicators.listenX options.indicators.listenY指示器的那一个轴（横向和纵向）被侦听。可以设置一个或者都设置默认值：true options.indicators.speedRatioX options.indicators.speedRatioY指示器移动的速度和主要滚动条大小的关系。默认情况下是设置为自动。你很少需要去改变这个值。默认值：0 options.indicators.fade options.indicators.interactive options.indicators.resize options.indicators.shrink这几个选项和我们已经介绍过的滚动条中的一样，在这里不重复介绍。请参考迷你地图示例，你将体验indicators选项的神奇力量。 你应该已经注意到选项indicators是复数，是的，实际上，传递一个对象数组你可以得到一个虚拟的无限大小的指示器。我不知道你是否需要，但是，这里我是想你介绍参数设置，所以要提及此。 视差滚动视差滚动是指示器功能的一个 附属功能指示器是一个遵循主滚动条移动和动画的层。如果你了解它你就会理解这个功能背后的力量。增加这个功能你就可以创建任意数量的指示器和视差滚动。请参考 视差滚动示例. 滚动的编程接口当然还可以通过编程来进行滚动。 scrollTo(x, y, time, easing)对应存在的一个叫做myScroll的iScroll实例，可以通过下面的方式滚动到任意的位置： myScroll.scrollTo(0, -100);通过上面的方式将向下滚动100个像素。记住：0永远是左上角。需要滚动你必须传递负数。time 和 easing是可选项。他们控制滚动周期（毫秒级别）和动画的擦除效果。擦除功能是一个有效的IScroll.utils.ease对象。例如应用一个一秒的经典擦除动画你应该这么做： myScroll.scrollTo(0, -100, 1000, IScroll.utils.ease.elastic);擦除动画的类型选项有：quadratic, circular, back, bounce, elastic。 scrollBy(x, y, time, easing) 和上面一个方法类似，但是可以传递X和Y的值从当前位置进行滚动。 myScroll.scrollBy(0, -10);上面这个语句将在当前位置向下滚动10个像素。如果你当前所在位置为-100，那么滚动结束后位置为-110. scrollToElement(el, time, offsetX, offsetY, easing) 这是一个很有用的方法，你会喜欢它的。在这个方法中只有一个强制的参数就是el。传递一个元素或者一个选择器，iScroll将尝试滚动到这个元素的左上角位置。time是可选项，用于设置动画周期。offsetX 和 offsetY定义像素级的偏移量，所以你可以滚动到元素并且加上特别的偏移量。但并不仅限于此。如果把这两个参数设置为true，元素将会位于屏幕的中间。请参考例子 滚动到元素 example。easing参数和scrollTo方法里的一样。 对齐iScroll能对齐到固定的位置和元素。 options.snap 最简单的对齐配置如下：123var myScroll = new IScroll(&apos;#wrapper&apos;, &#123; snap: true&#125;); 这将按照页面容器的大小自动分割滚动条。snap属性也可以传递字符类型类型的值。这个值是滚动条将要对齐到的元素的选择器。比如下面：123var myScroll = new IScroll(&apos;#wrapper&apos;, &#123; snap: &apos;li&apos;&#125;); 这个示例中滚动条将会对齐到每一个LI标记的元素。下面将帮助你快速浏览iScroll提供的关于对齐的一系列有趣的方法。 goToPage(x, y, time, easing) x 和 y呈现你想滚动到横向轴或者纵向轴的页面数。如果你需要在单个唯独上使用滚动条，只需要为你不需要的轴向传递0值。time属性是动画周期，easing属性是滚动到指定点使用的擦除功能类型。请参考高级功能中的option.bounceEasing。这两个属性都是可选项。 myScroll.goToPage(10, 0, 1000);上面这个例子将在一秒内沿着横向滚动到第10页。 next() prev() 滚动到当前位置的下一页或者前一页。 缩放为了使用缩放功能，你最好使用iscroll-zoom.js脚本。 options.zoom 此属性设置为true启用缩放功能。默认值：false options.zoomMax 最大缩放级数。默认值：4 options.zoomMin 最小缩放级数。默认值：1 options.zoomStart 初始的缩放级数。默认值：1 options.wheelAction 鼠标滚轮的动作可以设置为zoom，这样在滚动滚轮时缩放操作会代替原来的滚动操作。默认值：undefined（即：鼠标滚轮滚动） 和前面的示例一样，一个好的缩放功能的配置如下： myScroll = new IScroll(‘#wrapper’, { zoom: true, mouseWheel: true, wheelAction: ‘zoom’});缩放功能使用的CSS的转换功能。iScroll只能在支持此CSS功能的浏览器上执行。 一些浏览器（特别是基于webkit的）采取的快照缩放区域就放在硬件合成层(比如当你申请转换)。该快照作为纹理的缩放区域,它几乎不能被更新。这意味着您的纹理将基于scale 1 进行缩放,将导致文本和图像模糊,清晰度低。 一个简单的解决方案是使用实际分辨率双倍（或者三倍）装载内容，然后放到一个按照scale(0.5)比例缩小的div中。这种方法大多数情况下能适用。 请参考 缩放示例。 zoom(scale, x, y, time) 一个有意思的的方法，能让你进行缩放编程。scale是缩放因子。x 和 y是缩放关注点，即缩放的中心。如果没有指定，这个中心就是屏幕中心。time是毫秒级别的动画周期（可选项）。 无限滚动iScroll集成智能缓存系统，允许处理的使用(重用)一群元素几乎无限数量的数据。无限滚动开发的早期阶段，尽管它可以被认为是稳定的，但它还没有准备好被广泛使用。请参考 无限滚动示例 并请提交你的建议和报告bug。 高级选项下面这些选项主要针对核心开发人员。 options.bindToWrapper move事件通常绑定到文档而不是滚动器容器（wrapper）。当你在滚动器容器（wrapper）外移动光标/手指，滚动条将不断滚动。这通常是你想要的,但是你也可以绑定事件转移到滚动器容器（wrapper）本身。这样做一旦指针离开了容器，滚动就会停止。默认值：false options.bounceEasing 擦除功能在弹跳动画过程中执行。有效的值为：’quadratic’, ‘circular’, ‘back’, ‘bounce’, ‘elastic’. 参见bounce easing demo，往下拽滚动条然后释放。bounceEasing比上面的示例更强大。你可以自定义一个消除的方式，比如：1234bounceEasing: &#123; style: &apos;cubic-bezier(0,0,1,1)&apos;, fn: function (k) &#123; return k; &#125;&#125; 上面这个示例将执行一个线性的擦出。style选项将在在每次动画执行时使用CSS转场执行。fn和requestAnimationFrame一起使用。如果一个擦出功能太复杂，不能由一个三次贝塞尔曲线展现，那么为style属性传递 ‘’ （空字符串）。默认值：circular 注意：bounce 和 elastic这两种方式不能被CSS转场执行。 options.bounceTime 弹跳动画的持续时间，使用毫秒级。默认值：600 options.deceleration 这个值可以改变改变动画的势头持续时间/速度。更高的数字使动画更短。你可以从0.01开始去体验，这个值和基本的值比较，基本上没有动能。默认值：0.0006 options.mouseWheelSpeed 设置鼠标滚轮滚动的速度值。默认值：20 options.preventDefaultException 调用preventDefault()方法时所有的异常将被触发，尽管preventDefault设置了值。这是一个强大的选项，如果你想为所有包含formfield样式名称的元素上应用preventDefault()方法，你可以设置为下面的值： preventDefaultException: { className: /(^|\\s)formfield(\\s|$)/ }默认值：{ tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/ }. options.resizePolling 当你改变窗口的大小iScroll重新计算元素的位置和尺寸。这可能是一个相当艰巨的任务。轮询设置为60毫秒。通过降低这个值你获得更好的视觉效果，但会占用更多的CPU资源。默认值是一个很好的折中。默认值：60 刷新iScroll需要知道包装器和滚动器确切的尺寸，在iScroll初始化的时候进行计算，如果元素大小发生了变化，需要告诉iScroll DOM发生了变化。下面将提供调用refresh方法的正确时机。 每次触摸DOM，浏览器渲染器重绘页面。一旦发生了重画我们可以安全地读新的DOM属性。重新绘制阶段不是瞬时发生的只是范围结束时触发。这就是为什么我们需要给渲染器刷新iScroll之前一点时间。 为了确保javascript得到更新后的属性，应该像下面的例子这样使用刷新方法：123456789ajax(&apos;page.php&apos;, onCompletion);function onCompletion () &#123; // Update here your DOM setTimeout(function () &#123; myScroll.refresh(); &#125;, 0);&#125;; 这里调用refresh()使用了零秒等待，如果你需要立即刷新iScroll边界就是如此使用。当然还有其他方法可以等待页面重绘，但零超时方式相当稳定。 如果你有一个相当复杂的HTML结构，你应该给浏览器更多的执行事件，可以设置100到200毫秒的超时时间。 这通常适用于所有任务必须在DOM上进行。通常给渲染器一些执行的时间。 自定义事件Custom events iScroll还提供额一些你可以挂靠的有用的自定义事件。使用on(type, fn)方法注册事件。 myScroll = new IScroll(‘#wrapper’);myScroll.on(‘scrollEnd’, doSomething);上面的代码会在每次滚动停止是执行doSomething方法。可以挂靠的事件如下： beforeScrollStart，在用户触摸屏幕但还没有开始滚动时触发。scrollCancel，滚动初始化完成，但没有执行。scrollStart，开始滚动scroll，内容滚动时触发，只有在scroll-probe.js版本中有效，请参考onScroll event。scrollEnd，停止滚动时触发。flick，用户打开左/右。zoomStart，开始缩放。zoomEnd，缩放结束。onScroll事件 scroll事件在iScroll probe edition版本中有效（仅包含在iscroll-probe.js脚本文件中）。可以通过改变probeType选项值来改变scroll事件的触发时机。 options.probeType 这个属性是调节在scroll事件触发中探针的活跃度或者频率。有效值有：1, 2, 3。数值越高表示更活跃的探测。探针活跃度越高对CPU的影响就越大。 probeType: 1 对性能没有影响。scroll事件只有在滚动条不繁忙的时候触发。probeType: 2 除了在势能和反弹范围内，将在scroll事件周期内一直执行。这类似于原生的onScroll事件。probeType: 3 像素级的触发scroll事件。注意，此时滚动只关注requestAnimationFrame (即：useTransition:false).请参考 probe demo. 按键绑定你可以激活keyBindings选项来支持键盘控制。默认情况下iScroll监听方向键，上下翻页建，home/end键，但这些按键绑定完全可以自定义。你可以通过传递一个包含按键代码列表的对象来进行按键绑定。默认的按键值如下: keyBindings: { pageUp: 33, pageDown: 34, end: 35, home: 36, left: 37, up: 38, right: 39, down: 40}当然你也可以传递字符串进行按键绑定（例如：pageUp: ‘a’）。只要你设置了对于的按键值，那么iScroll就会响应你的设置。 滚动条信息iScroll存储了很多有用的信息，您可以使用它们来增强您的应用。你可能会发现有用的： myScroll.x/y，当前位置myScroll.directionX/Y，最后的方向 (-1 down/right, 0 still, 1 up/left)myScroll.currentPage，当前对齐捕获点下面是关于处理时间的代码示例：123456myScroll = new IScroll(&apos;#wrapper&apos;);myScroll.on(&apos;scrollEnd&apos;, function () &#123; if ( this.x &lt; -1000 ) &#123; // do something &#125;&#125;); 如果 x 位置是低于-1000 像素滚轮停止时，上述执行某些代码。请注意我用这个产品而不是 myScroll，您可以使用两个当然，但 iScroll 传递本身作为这种情况下，当触发自定义事件的功能。 销毁在不需要使用iScoll的时候调用iScroll实例的公共方法destroy()可以释放一些内存。 myScroll.destroy();myScroll = null;原文链接:http://iiunknown.gitbooks.io/iscroll-5-api-cn/content/","tags":[{"name":"iScroll","slug":"iScroll","permalink":"http://tawen.github.io/tags/iScroll/"}]},{"title":"我的第一篇blog","date":"2016-12-14T03:20:25.000Z","path":"2016/12/14/about/","text":"今天天气虽然有点冷，但是阳光明媚。。。欢迎大家关注的我新浪微博! hexo发布blog的命令：1hexo clean &amp; hexo g &amp; hexo deploy markdown在线编辑器:1http://dillinger.io/","tags":[{"name":"生活","slug":"生活","permalink":"http://tawen.github.io/tags/生活/"}]},{"title":"HEXO","date":"2016-12-14T02:20:25.000Z","path":"2016/12/14/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"HEXO","slug":"HEXO","permalink":"http://tawen.github.io/tags/HEXO/"}]}]